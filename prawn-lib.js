/* Generated by Opal 0.11.0 */
Opal.modules["set"] = function(Opal) {
  function $rb_minus(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs - rhs : lhs['$-'](rhs);
  }
  function $rb_lt(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs < rhs : lhs['$<'](rhs);
  }
  function $rb_le(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs <= rhs : lhs['$<='](rhs);
  }
  var self = Opal.top, $nesting = [], nil = Opal.nil, $breaker = Opal.breaker, $slice = Opal.slice, $klass = Opal.klass, $truthy = Opal.truthy, $send = Opal.send, $module = Opal.module;

  Opal.add_stubs(['$include', '$new', '$nil?', '$===', '$raise', '$each', '$add', '$call', '$merge', '$class', '$respond_to?', '$subtract', '$dup', '$join', '$to_a', '$equal?', '$instance_of?', '$==', '$instance_variable_get', '$is_a?', '$size', '$all?', '$include?', '$[]=', '$-', '$enum_for', '$[]', '$<<', '$replace', '$delete', '$select', '$each_key', '$to_proc', '$empty?', '$eql?', '$instance_eval', '$clear', '$<', '$<=', '$keys']);
  
  (function($base, $super, $parent_nesting) {
    function $Set(){};
    var self = $Set = $klass($base, $super, 'Set', $Set);

    var def = self.$$proto, $nesting = [self].concat($parent_nesting), TMP_Set_$$_1, TMP_Set_initialize_2, TMP_Set_dup_4, TMP_Set_$_5, TMP_Set_inspect_6, TMP_Set_$eq$eq_8, TMP_Set_add_9, TMP_Set_classify_10, TMP_Set_collect$B_13, TMP_Set_delete_15, TMP_Set_delete$q_16, TMP_Set_delete_if_17, TMP_Set_add$q_20, TMP_Set_each_21, TMP_Set_empty$q_22, TMP_Set_eql$q_24, TMP_Set_clear_25, TMP_Set_include$q_26, TMP_Set_merge_28, TMP_Set_replace_29, TMP_Set_size_30, TMP_Set_subtract_32, TMP_Set_$_33, TMP_Set_superset$q_35, TMP_Set_proper_superset$q_37, TMP_Set_subset$q_39, TMP_Set_proper_subset$q_41, TMP_Set_to_a_42;

    def.hash = nil;
    
    self.$include(Opal.const_get_relative($nesting, 'Enumerable'));
    Opal.defs(self, '$[]', TMP_Set_$$_1 = function($a_rest) {
      var self = this, ary;

      var $args_len = arguments.length, $rest_len = $args_len - 0;
      if ($rest_len < 0) { $rest_len = 0; }
      ary = new Array($rest_len);
      for (var $arg_idx = 0; $arg_idx < $args_len; $arg_idx++) {
        ary[$arg_idx - 0] = arguments[$arg_idx];
      }
      return self.$new(ary)
    }, TMP_Set_$$_1.$$arity = -1);
    
    Opal.defn(self, '$initialize', TMP_Set_initialize_2 = function $$initialize(enum$) {
      var TMP_3, self = this, $iter = TMP_Set_initialize_2.$$p, block = $iter || nil;

      if (enum$ == null) {
        enum$ = nil;
      }
      if ($iter) TMP_Set_initialize_2.$$p = null;
      
      self.hash = Opal.const_get_relative($nesting, 'Hash').$new();
      if ($truthy(enum$['$nil?']())) {
        return nil};
      if ($truthy(Opal.const_get_relative($nesting, 'Enumerable')['$==='](enum$))) {
        } else {
        self.$raise(Opal.const_get_relative($nesting, 'ArgumentError'), "value must be enumerable")
      };
      if ($truthy(block)) {
        return $send(enum$, 'each', [], (TMP_3 = function(item){var self = TMP_3.$$s || this;
if (item == null) item = nil;
        return self.$add(block.$call(item))}, TMP_3.$$s = self, TMP_3.$$arity = 1, TMP_3))
        } else {
        return self.$merge(enum$)
      };
    }, TMP_Set_initialize_2.$$arity = -1);
    
    Opal.defn(self, '$dup', TMP_Set_dup_4 = function $$dup() {
      var self = this, result = nil;

      
      result = self.$class().$new();
      return result.$merge(self);
    }, TMP_Set_dup_4.$$arity = 0);
    
    Opal.defn(self, '$-', TMP_Set_$_5 = function(enum$) {
      var self = this;

      
      if ($truthy(enum$['$respond_to?']("each"))) {
        } else {
        self.$raise(Opal.const_get_relative($nesting, 'ArgumentError'), "value must be enumerable")
      };
      return self.$dup().$subtract(enum$);
    }, TMP_Set_$_5.$$arity = 1);
    Opal.alias(self, "difference", "-");
    
    Opal.defn(self, '$inspect', TMP_Set_inspect_6 = function $$inspect() {
      var self = this;

      return "" + "#<Set: {" + (self.$to_a().$join(",")) + "}>"
    }, TMP_Set_inspect_6.$$arity = 0);
    
    Opal.defn(self, '$==', TMP_Set_$eq$eq_8 = function(other) {
      var $a, TMP_7, self = this;

      if ($truthy(self['$equal?'](other))) {
        return true
      } else if ($truthy(other['$instance_of?'](self.$class()))) {
        return self.hash['$=='](other.$instance_variable_get("@hash"))
      } else if ($truthy(($truthy($a = other['$is_a?'](Opal.const_get_relative($nesting, 'Set'))) ? self.$size()['$=='](other.$size()) : $a))) {
        return $send(other, 'all?', [], (TMP_7 = function(o){var self = TMP_7.$$s || this;
          if (self.hash == null) self.hash = nil;
if (o == null) o = nil;
        return self.hash['$include?'](o)}, TMP_7.$$s = self, TMP_7.$$arity = 1, TMP_7))
        } else {
        return false
      }
    }, TMP_Set_$eq$eq_8.$$arity = 1);
    
    Opal.defn(self, '$add', TMP_Set_add_9 = function $$add(o) {
      var self = this, $writer = nil;

      
      
      $writer = [o, true];
      $send(self.hash, '[]=', Opal.to_a($writer));
      $writer[$rb_minus($writer["length"], 1)];;
      return self;
    }, TMP_Set_add_9.$$arity = 1);
    Opal.alias(self, "<<", "add");
    
    Opal.defn(self, '$classify', TMP_Set_classify_10 = function $$classify() {
      var TMP_11, TMP_12, self = this, $iter = TMP_Set_classify_10.$$p, block = $iter || nil, result = nil;

      if ($iter) TMP_Set_classify_10.$$p = null;
      
      if ((block !== nil)) {
        } else {
        return self.$enum_for("classify")
      };
      result = $send(Opal.const_get_relative($nesting, 'Hash'), 'new', [], (TMP_11 = function(h, k){var self = TMP_11.$$s || this, $writer = nil;
if (h == null) h = nil;if (k == null) k = nil;
      
        $writer = [k, self.$class().$new()];
        $send(h, '[]=', Opal.to_a($writer));
        return $writer[$rb_minus($writer["length"], 1)];}, TMP_11.$$s = self, TMP_11.$$arity = 2, TMP_11));
      $send(self, 'each', [], (TMP_12 = function(item){var self = TMP_12.$$s || this;
if (item == null) item = nil;
      return result['$[]'](Opal.yield1(block, item)).$add(item)}, TMP_12.$$s = self, TMP_12.$$arity = 1, TMP_12));
      return result;
    }, TMP_Set_classify_10.$$arity = 0);
    
    Opal.defn(self, '$collect!', TMP_Set_collect$B_13 = function() {
      var TMP_14, self = this, $iter = TMP_Set_collect$B_13.$$p, block = $iter || nil, result = nil;

      if ($iter) TMP_Set_collect$B_13.$$p = null;
      
      if ((block !== nil)) {
        } else {
        return self.$enum_for("collect!")
      };
      result = self.$class().$new();
      $send(self, 'each', [], (TMP_14 = function(item){var self = TMP_14.$$s || this;
if (item == null) item = nil;
      return result['$<<'](Opal.yield1(block, item))}, TMP_14.$$s = self, TMP_14.$$arity = 1, TMP_14));
      return self.$replace(result);
    }, TMP_Set_collect$B_13.$$arity = 0);
    Opal.alias(self, "map!", "collect!");
    
    Opal.defn(self, '$delete', TMP_Set_delete_15 = function(o) {
      var self = this;

      
      self.hash.$delete(o);
      return self;
    }, TMP_Set_delete_15.$$arity = 1);
    
    Opal.defn(self, '$delete?', TMP_Set_delete$q_16 = function(o) {
      var self = this;

      if ($truthy(self['$include?'](o))) {
        
        self.$delete(o);
        return self;
        } else {
        return nil
      }
    }, TMP_Set_delete$q_16.$$arity = 1);
    
    Opal.defn(self, '$delete_if', TMP_Set_delete_if_17 = function $$delete_if() {try {

      var $a, TMP_18, TMP_19, self = this, $iter = TMP_Set_delete_if_17.$$p, $yield = $iter || nil;

      if ($iter) TMP_Set_delete_if_17.$$p = null;
      
      ($truthy($a = ($yield !== nil)) ? $a : Opal.ret(self.$enum_for("delete_if")));
      $send($send(self, 'select', [], (TMP_18 = function(o){var self = TMP_18.$$s || this;
if (o == null) o = nil;
      return Opal.yield1($yield, o);}, TMP_18.$$s = self, TMP_18.$$arity = 1, TMP_18)), 'each', [], (TMP_19 = function(o){var self = TMP_19.$$s || this;
        if (self.hash == null) self.hash = nil;
if (o == null) o = nil;
      return self.hash.$delete(o)}, TMP_19.$$s = self, TMP_19.$$arity = 1, TMP_19));
      return self;
      } catch ($returner) { if ($returner === Opal.returner) { return $returner.$v } throw $returner; }
    }, TMP_Set_delete_if_17.$$arity = 0);
    
    Opal.defn(self, '$add?', TMP_Set_add$q_20 = function(o) {
      var self = this;

      if ($truthy(self['$include?'](o))) {
        return nil
        } else {
        return self.$add(o)
      }
    }, TMP_Set_add$q_20.$$arity = 1);
    
    Opal.defn(self, '$each', TMP_Set_each_21 = function $$each() {
      var self = this, $iter = TMP_Set_each_21.$$p, block = $iter || nil;

      if ($iter) TMP_Set_each_21.$$p = null;
      
      if ((block !== nil)) {
        } else {
        return self.$enum_for("each")
      };
      $send(self.hash, 'each_key', [], block.$to_proc());
      return self;
    }, TMP_Set_each_21.$$arity = 0);
    
    Opal.defn(self, '$empty?', TMP_Set_empty$q_22 = function() {
      var self = this;

      return self.hash['$empty?']()
    }, TMP_Set_empty$q_22.$$arity = 0);
    
    Opal.defn(self, '$eql?', TMP_Set_eql$q_24 = function(other) {
      var TMP_23, self = this;

      return self.hash['$eql?']($send(other, 'instance_eval', [], (TMP_23 = function(){var self = TMP_23.$$s || this;
        if (self.hash == null) self.hash = nil;

      return self.hash}, TMP_23.$$s = self, TMP_23.$$arity = 0, TMP_23)))
    }, TMP_Set_eql$q_24.$$arity = 1);
    
    Opal.defn(self, '$clear', TMP_Set_clear_25 = function $$clear() {
      var self = this;

      
      self.hash.$clear();
      return self;
    }, TMP_Set_clear_25.$$arity = 0);
    
    Opal.defn(self, '$include?', TMP_Set_include$q_26 = function(o) {
      var self = this;

      return self.hash['$include?'](o)
    }, TMP_Set_include$q_26.$$arity = 1);
    Opal.alias(self, "member?", "include?");
    
    Opal.defn(self, '$merge', TMP_Set_merge_28 = function $$merge(enum$) {
      var TMP_27, self = this;

      
      $send(enum$, 'each', [], (TMP_27 = function(item){var self = TMP_27.$$s || this;
if (item == null) item = nil;
      return self.$add(item)}, TMP_27.$$s = self, TMP_27.$$arity = 1, TMP_27));
      return self;
    }, TMP_Set_merge_28.$$arity = 1);
    
    Opal.defn(self, '$replace', TMP_Set_replace_29 = function $$replace(enum$) {
      var self = this;

      
      self.$clear();
      self.$merge(enum$);
      return self;
    }, TMP_Set_replace_29.$$arity = 1);
    
    Opal.defn(self, '$size', TMP_Set_size_30 = function $$size() {
      var self = this;

      return self.hash.$size()
    }, TMP_Set_size_30.$$arity = 0);
    Opal.alias(self, "length", "size");
    
    Opal.defn(self, '$subtract', TMP_Set_subtract_32 = function $$subtract(enum$) {
      var TMP_31, self = this;

      
      $send(enum$, 'each', [], (TMP_31 = function(item){var self = TMP_31.$$s || this;
if (item == null) item = nil;
      return self.$delete(item)}, TMP_31.$$s = self, TMP_31.$$arity = 1, TMP_31));
      return self;
    }, TMP_Set_subtract_32.$$arity = 1);
    
    Opal.defn(self, '$|', TMP_Set_$_33 = function(enum$) {
      var self = this;

      
      if ($truthy(enum$['$respond_to?']("each"))) {
        } else {
        self.$raise(Opal.const_get_relative($nesting, 'ArgumentError'), "value must be enumerable")
      };
      return self.$dup().$merge(enum$);
    }, TMP_Set_$_33.$$arity = 1);
    
    Opal.defn(self, '$superset?', TMP_Set_superset$q_35 = function(set) {
      var $a, TMP_34, self = this;

      
      ($truthy($a = set['$is_a?'](Opal.const_get_relative($nesting, 'Set'))) ? $a : self.$raise(Opal.const_get_relative($nesting, 'ArgumentError'), "value must be a set"));
      if ($truthy($rb_lt(self.$size(), set.$size()))) {
        return false};
      return $send(set, 'all?', [], (TMP_34 = function(o){var self = TMP_34.$$s || this;
if (o == null) o = nil;
      return self['$include?'](o)}, TMP_34.$$s = self, TMP_34.$$arity = 1, TMP_34));
    }, TMP_Set_superset$q_35.$$arity = 1);
    Opal.alias(self, ">=", "superset?");
    
    Opal.defn(self, '$proper_superset?', TMP_Set_proper_superset$q_37 = function(set) {
      var $a, TMP_36, self = this;

      
      ($truthy($a = set['$is_a?'](Opal.const_get_relative($nesting, 'Set'))) ? $a : self.$raise(Opal.const_get_relative($nesting, 'ArgumentError'), "value must be a set"));
      if ($truthy($rb_le(self.$size(), set.$size()))) {
        return false};
      return $send(set, 'all?', [], (TMP_36 = function(o){var self = TMP_36.$$s || this;
if (o == null) o = nil;
      return self['$include?'](o)}, TMP_36.$$s = self, TMP_36.$$arity = 1, TMP_36));
    }, TMP_Set_proper_superset$q_37.$$arity = 1);
    Opal.alias(self, ">", "proper_superset?");
    
    Opal.defn(self, '$subset?', TMP_Set_subset$q_39 = function(set) {
      var $a, TMP_38, self = this;

      
      ($truthy($a = set['$is_a?'](Opal.const_get_relative($nesting, 'Set'))) ? $a : self.$raise(Opal.const_get_relative($nesting, 'ArgumentError'), "value must be a set"));
      if ($truthy($rb_lt(set.$size(), self.$size()))) {
        return false};
      return $send(self, 'all?', [], (TMP_38 = function(o){var self = TMP_38.$$s || this;
if (o == null) o = nil;
      return set['$include?'](o)}, TMP_38.$$s = self, TMP_38.$$arity = 1, TMP_38));
    }, TMP_Set_subset$q_39.$$arity = 1);
    Opal.alias(self, "<=", "subset?");
    
    Opal.defn(self, '$proper_subset?', TMP_Set_proper_subset$q_41 = function(set) {
      var $a, TMP_40, self = this;

      
      ($truthy($a = set['$is_a?'](Opal.const_get_relative($nesting, 'Set'))) ? $a : self.$raise(Opal.const_get_relative($nesting, 'ArgumentError'), "value must be a set"));
      if ($truthy($rb_le(set.$size(), self.$size()))) {
        return false};
      return $send(self, 'all?', [], (TMP_40 = function(o){var self = TMP_40.$$s || this;
if (o == null) o = nil;
      return set['$include?'](o)}, TMP_40.$$s = self, TMP_40.$$arity = 1, TMP_40));
    }, TMP_Set_proper_subset$q_41.$$arity = 1);
    Opal.alias(self, "<", "proper_subset?");
    Opal.alias(self, "+", "|");
    Opal.alias(self, "union", "|");
    return (Opal.defn(self, '$to_a', TMP_Set_to_a_42 = function $$to_a() {
      var self = this;

      return self.hash.$keys()
    }, TMP_Set_to_a_42.$$arity = 0), nil) && 'to_a';
  })($nesting[0], null, $nesting);
  return (function($base, $parent_nesting) {
    var $Enumerable, self = $Enumerable = $module($base, 'Enumerable');

    var def = self.$$proto, $nesting = [self].concat($parent_nesting), TMP_Enumerable_to_set_43;

    
    Opal.defn(self, '$to_set', TMP_Enumerable_to_set_43 = function $$to_set(klass, $a_rest) {
      var self = this, args, $iter = TMP_Enumerable_to_set_43.$$p, block = $iter || nil;

      if (klass == null) {
        klass = Opal.const_get_relative($nesting, 'Set');
      }
      var $args_len = arguments.length, $rest_len = $args_len - 1;
      if ($rest_len < 0) { $rest_len = 0; }
      args = new Array($rest_len);
      for (var $arg_idx = 1; $arg_idx < $args_len; $arg_idx++) {
        args[$arg_idx - 1] = arguments[$arg_idx];
      }
      if ($iter) TMP_Enumerable_to_set_43.$$p = null;
      return $send(klass, 'new', [self].concat(Opal.to_a(args)), block.$to_proc())
    }, TMP_Enumerable_to_set_43.$$arity = -1)
  })($nesting[0], $nesting);
};

/* Generated by Opal 0.11.0 */
Opal.modules["stringio"] = function(Opal) {
  function $rb_ge(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs >= rhs : lhs['$>='](rhs);
  }
  function $rb_gt(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs > rhs : lhs['$>'](rhs);
  }
  function $rb_plus(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs + rhs : lhs['$+'](rhs);
  }
  function $rb_minus(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs - rhs : lhs['$-'](rhs);
  }
  var self = Opal.top, $nesting = [], nil = Opal.nil, $breaker = Opal.breaker, $slice = Opal.slice, $klass = Opal.klass, $truthy = Opal.truthy;

  Opal.add_stubs(['$include', '$new', '$call', '$close', '$attr_accessor', '$length', '$include?', '$!', '$check_readable', '$==', '$===', '$>=', '$raise', '$>', '$+', '$-', '$seek', '$enum_for', '$eof?', '$ord', '$[]', '$check_writable', '$String', '$write', '$closed_write?', '$closed_read?']);
  return (function($base, $super, $parent_nesting) {
    function $StringIO(){};
    var self = $StringIO = $klass($base, $super, 'StringIO', $StringIO);

    var def = self.$$proto, $nesting = [self].concat($parent_nesting), TMP_StringIO_open_1, TMP_StringIO_initialize_2, TMP_StringIO_eof$q_3, TMP_StringIO_seek_4, TMP_StringIO_tell_5, TMP_StringIO_rewind_6, TMP_StringIO_each_byte_7, TMP_StringIO_each_char_8, TMP_StringIO_write_9, TMP_StringIO_read_10, TMP_StringIO_close_11, TMP_StringIO_close_read_12, TMP_StringIO_close_write_13, TMP_StringIO_closed$q_14, TMP_StringIO_closed_read$q_15, TMP_StringIO_closed_write$q_16, TMP_StringIO_check_writable_17, TMP_StringIO_check_readable_18;

    def.position = def.string = def.closed = nil;
    
    self.$include(Opal.const_get_qualified(Opal.const_get_relative($nesting, 'IO'), 'Readable'));
    self.$include(Opal.const_get_qualified(Opal.const_get_relative($nesting, 'IO'), 'Writable'));
    Opal.defs(self, '$open', TMP_StringIO_open_1 = function $$open(string, mode) {
      var self = this, $iter = TMP_StringIO_open_1.$$p, block = $iter || nil, io = nil, res = nil;

      if (string == null) {
        string = "";
      }
      if (mode == null) {
        mode = nil;
      }
      if ($iter) TMP_StringIO_open_1.$$p = null;
      
      io = self.$new(string, mode);
      res = block.$call(io);
      io.$close();
      return res;
    }, TMP_StringIO_open_1.$$arity = -1);
    self.$attr_accessor("string");
    
    Opal.defn(self, '$initialize', TMP_StringIO_initialize_2 = function $$initialize(string, mode) {
      var $a, self = this;

      if (string == null) {
        string = "";
      }
      if (mode == null) {
        mode = "rw";
      }
      
      self.string = string;
      self.position = string.$length();
      if ($truthy(($truthy($a = mode['$include?']("r")) ? mode['$include?']("w")['$!']() : $a))) {
        return (self.closed = "write")
      } else if ($truthy(($truthy($a = mode['$include?']("w")) ? mode['$include?']("r")['$!']() : $a))) {
        return (self.closed = "read")
        } else {
        return nil
      };
    }, TMP_StringIO_initialize_2.$$arity = -1);
    
    Opal.defn(self, '$eof?', TMP_StringIO_eof$q_3 = function() {
      var self = this;

      
      self.$check_readable();
      return self.position['$=='](self.string.$length());
    }, TMP_StringIO_eof$q_3.$$arity = 0);
    Opal.alias(self, "eof", "eof?");
    
    Opal.defn(self, '$seek', TMP_StringIO_seek_4 = function $$seek(pos, whence) {
      var self = this, $case = nil;

      if (whence == null) {
        whence = Opal.const_get_qualified(Opal.const_get_relative($nesting, 'IO'), 'SEEK_SET');
      }
      
      $case = whence;
      if (Opal.const_get_qualified(Opal.const_get_relative($nesting, 'IO'), 'SEEK_SET')['$===']($case)) {
      if ($truthy($rb_ge(pos, 0))) {
        } else {
        self.$raise(Opal.const_get_qualified(Opal.const_get_relative($nesting, 'Errno'), 'EINVAL'))
      };
      self.position = pos;}
      else if (Opal.const_get_qualified(Opal.const_get_relative($nesting, 'IO'), 'SEEK_CUR')['$===']($case)) {if ($truthy($rb_gt($rb_plus(self.position, pos), self.string.$length()))) {
        self.position = self.string.$length()
        } else {
        self.position = $rb_plus(self.position, pos)
      }}
      else if (Opal.const_get_qualified(Opal.const_get_relative($nesting, 'IO'), 'SEEK_END')['$===']($case)) {if ($truthy($rb_gt(pos, self.string.$length()))) {
        self.position = 0
        } else {
        self.position = $rb_minus(self.position, pos)
      }};
      return 0;
    }, TMP_StringIO_seek_4.$$arity = -2);
    
    Opal.defn(self, '$tell', TMP_StringIO_tell_5 = function $$tell() {
      var self = this;

      return self.position
    }, TMP_StringIO_tell_5.$$arity = 0);
    Opal.alias(self, "pos", "tell");
    Opal.alias(self, "pos=", "seek");
    
    Opal.defn(self, '$rewind', TMP_StringIO_rewind_6 = function $$rewind() {
      var self = this;

      return self.$seek(0)
    }, TMP_StringIO_rewind_6.$$arity = 0);
    
    Opal.defn(self, '$each_byte', TMP_StringIO_each_byte_7 = function $$each_byte() {
      var $a, self = this, $iter = TMP_StringIO_each_byte_7.$$p, block = $iter || nil, i = nil;

      if ($iter) TMP_StringIO_each_byte_7.$$p = null;
      
      if ($truthy(block)) {
        } else {
        return self.$enum_for("each_byte")
      };
      self.$check_readable();
      i = self.position;
      while (!($truthy(self['$eof?']()))) {
        
        block.$call(self.string['$[]'](i).$ord());
        i = $rb_plus(i, 1);
      };
      return self;
    }, TMP_StringIO_each_byte_7.$$arity = 0);
    
    Opal.defn(self, '$each_char', TMP_StringIO_each_char_8 = function $$each_char() {
      var $a, self = this, $iter = TMP_StringIO_each_char_8.$$p, block = $iter || nil, i = nil;

      if ($iter) TMP_StringIO_each_char_8.$$p = null;
      
      if ($truthy(block)) {
        } else {
        return self.$enum_for("each_char")
      };
      self.$check_readable();
      i = self.position;
      while (!($truthy(self['$eof?']()))) {
        
        block.$call(self.string['$[]'](i));
        i = $rb_plus(i, 1);
      };
      return self;
    }, TMP_StringIO_each_char_8.$$arity = 0);
    
    Opal.defn(self, '$write', TMP_StringIO_write_9 = function $$write(string) {
      var self = this, before = nil, after = nil;

      
      self.$check_writable();
      string = self.$String(string);
      if (self.string.$length()['$=='](self.position)) {
        
        self.string = $rb_plus(self.string, string);
        return (self.position = $rb_plus(self.position, string.$length()));
        } else {
        
        before = self.string['$[]'](Opal.Range.$new(0, $rb_minus(self.position, 1), false));
        after = self.string['$[]'](Opal.Range.$new($rb_plus(self.position, string.$length()), -1, false));
        self.string = $rb_plus($rb_plus(before, string), after);
        return (self.position = $rb_plus(self.position, string.$length()));
      };
    }, TMP_StringIO_write_9.$$arity = 1);
    
    Opal.defn(self, '$read', TMP_StringIO_read_10 = function $$read(length, outbuf) {
      var self = this, string = nil, str = nil;

      if (length == null) {
        length = nil;
      }
      if (outbuf == null) {
        outbuf = nil;
      }
      
      self.$check_readable();
      if ($truthy(self['$eof?']())) {
        return nil};
      string = (function() {if ($truthy(length)) {
        
        str = self.string['$[]'](self.position, length);
        self.position = $rb_plus(self.position, length);
        return str;
        } else {
        
        str = self.string['$[]'](Opal.Range.$new(self.position, -1, false));
        self.position = self.string.$length();
        return str;
      }; return nil; })();
      if ($truthy(outbuf)) {
        return outbuf.$write(string)
        } else {
        return string
      };
    }, TMP_StringIO_read_10.$$arity = -1);
    
    Opal.defn(self, '$close', TMP_StringIO_close_11 = function $$close() {
      var self = this;

      return (self.closed = "both")
    }, TMP_StringIO_close_11.$$arity = 0);
    
    Opal.defn(self, '$close_read', TMP_StringIO_close_read_12 = function $$close_read() {
      var self = this;

      if (self.closed['$==']("write")) {
        return (self.closed = "both")
        } else {
        return (self.closed = "read")
      }
    }, TMP_StringIO_close_read_12.$$arity = 0);
    
    Opal.defn(self, '$close_write', TMP_StringIO_close_write_13 = function $$close_write() {
      var self = this;

      if (self.closed['$==']("read")) {
        return (self.closed = "both")
        } else {
        return (self.closed = "write")
      }
    }, TMP_StringIO_close_write_13.$$arity = 0);
    
    Opal.defn(self, '$closed?', TMP_StringIO_closed$q_14 = function() {
      var self = this;

      return self.closed['$==']("both")
    }, TMP_StringIO_closed$q_14.$$arity = 0);
    
    Opal.defn(self, '$closed_read?', TMP_StringIO_closed_read$q_15 = function() {
      var $a, self = this;

      return ($truthy($a = self.closed['$==']("read")) ? $a : self.closed['$==']("both"))
    }, TMP_StringIO_closed_read$q_15.$$arity = 0);
    
    Opal.defn(self, '$closed_write?', TMP_StringIO_closed_write$q_16 = function() {
      var $a, self = this;

      return ($truthy($a = self.closed['$==']("write")) ? $a : self.closed['$==']("both"))
    }, TMP_StringIO_closed_write$q_16.$$arity = 0);
    
    Opal.defn(self, '$check_writable', TMP_StringIO_check_writable_17 = function $$check_writable() {
      var self = this;

      if ($truthy(self['$closed_write?']())) {
        return self.$raise(Opal.const_get_relative($nesting, 'IOError'), "not opened for writing")
        } else {
        return nil
      }
    }, TMP_StringIO_check_writable_17.$$arity = 0);
    return (Opal.defn(self, '$check_readable', TMP_StringIO_check_readable_18 = function $$check_readable() {
      var self = this;

      if ($truthy(self['$closed_read?']())) {
        return self.$raise(Opal.const_get_relative($nesting, 'IOError'), "not opened for reading")
        } else {
        return nil
      }
    }, TMP_StringIO_check_readable_18.$$arity = 0), nil) && 'check_readable';
  })($nesting[0], Opal.const_get_relative($nesting, 'IO'), $nesting)
};

/* Generated by Opal 0.11.0 */
Opal.modules["corelib/comparable"] = function(Opal) {
  function $rb_gt(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs > rhs : lhs['$>'](rhs);
  }
  function $rb_lt(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs < rhs : lhs['$<'](rhs);
  }
  var self = Opal.top, $nesting = [], nil = Opal.nil, $breaker = Opal.breaker, $slice = Opal.slice, $module = Opal.module, $truthy = Opal.truthy;

  Opal.add_stubs(['$===', '$>', '$<', '$equal?', '$<=>', '$normalize', '$raise', '$class']);
  return (function($base, $parent_nesting) {
    var $Comparable, self = $Comparable = $module($base, 'Comparable');

    var def = self.$$proto, $nesting = [self].concat($parent_nesting), TMP_Comparable_normalize_1, TMP_Comparable_$eq$eq_2, TMP_Comparable_$gt_3, TMP_Comparable_$gt$eq_4, TMP_Comparable_$lt_5, TMP_Comparable_$lt$eq_6, TMP_Comparable_between$q_7, TMP_Comparable_clamp_8;

    
    Opal.defs(self, '$normalize', TMP_Comparable_normalize_1 = function $$normalize(what) {
      var self = this;

      
      if ($truthy(Opal.const_get_relative($nesting, 'Integer')['$==='](what))) {
        return what};
      if ($truthy($rb_gt(what, 0))) {
        return 1};
      if ($truthy($rb_lt(what, 0))) {
        return -1};
      return 0;
    }, TMP_Comparable_normalize_1.$$arity = 1);
    
    Opal.defn(self, '$==', TMP_Comparable_$eq$eq_2 = function(other) {
      var self = this, cmp = nil;

      try {
        
        if ($truthy(self['$equal?'](other))) {
          return true};
        
      if (self["$<=>"] == Opal.Kernel["$<=>"]) {
        return false;
      }

      // check for infinite recursion
      if (self.$$comparable) {
        delete self.$$comparable;
        return false;
      }
    ;
        if ($truthy((cmp = self['$<=>'](other)))) {
          } else {
          return false
        };
        return Opal.const_get_relative($nesting, 'Comparable').$normalize(cmp) == 0;
      } catch ($err) {
        if (Opal.rescue($err, [Opal.const_get_relative($nesting, 'StandardError')])) {
          try {
            return false
          } finally { Opal.pop_exception() }
        } else { throw $err; }
      }
    }, TMP_Comparable_$eq$eq_2.$$arity = 1);
    
    Opal.defn(self, '$>', TMP_Comparable_$gt_3 = function(other) {
      var self = this, cmp = nil;

      
      if ($truthy((cmp = self['$<=>'](other)))) {
        } else {
        self.$raise(Opal.const_get_relative($nesting, 'ArgumentError'), "" + "comparison of " + (self.$class()) + " with " + (other.$class()) + " failed")
      };
      return Opal.const_get_relative($nesting, 'Comparable').$normalize(cmp) > 0;
    }, TMP_Comparable_$gt_3.$$arity = 1);
    
    Opal.defn(self, '$>=', TMP_Comparable_$gt$eq_4 = function(other) {
      var self = this, cmp = nil;

      
      if ($truthy((cmp = self['$<=>'](other)))) {
        } else {
        self.$raise(Opal.const_get_relative($nesting, 'ArgumentError'), "" + "comparison of " + (self.$class()) + " with " + (other.$class()) + " failed")
      };
      return Opal.const_get_relative($nesting, 'Comparable').$normalize(cmp) >= 0;
    }, TMP_Comparable_$gt$eq_4.$$arity = 1);
    
    Opal.defn(self, '$<', TMP_Comparable_$lt_5 = function(other) {
      var self = this, cmp = nil;

      
      if ($truthy((cmp = self['$<=>'](other)))) {
        } else {
        self.$raise(Opal.const_get_relative($nesting, 'ArgumentError'), "" + "comparison of " + (self.$class()) + " with " + (other.$class()) + " failed")
      };
      return Opal.const_get_relative($nesting, 'Comparable').$normalize(cmp) < 0;
    }, TMP_Comparable_$lt_5.$$arity = 1);
    
    Opal.defn(self, '$<=', TMP_Comparable_$lt$eq_6 = function(other) {
      var self = this, cmp = nil;

      
      if ($truthy((cmp = self['$<=>'](other)))) {
        } else {
        self.$raise(Opal.const_get_relative($nesting, 'ArgumentError'), "" + "comparison of " + (self.$class()) + " with " + (other.$class()) + " failed")
      };
      return Opal.const_get_relative($nesting, 'Comparable').$normalize(cmp) <= 0;
    }, TMP_Comparable_$lt$eq_6.$$arity = 1);
    
    Opal.defn(self, '$between?', TMP_Comparable_between$q_7 = function(min, max) {
      var self = this;

      
      if ($rb_lt(self, min)) {
        return false};
      if ($rb_gt(self, max)) {
        return false};
      return true;
    }, TMP_Comparable_between$q_7.$$arity = 2);
    
    Opal.defn(self, '$clamp', TMP_Comparable_clamp_8 = function $$clamp(min, max) {
      var self = this, cmp = nil;

      
      cmp = min['$<=>'](max);
      if ($truthy(cmp)) {
        } else {
        self.$raise(Opal.const_get_relative($nesting, 'ArgumentError'), "" + "comparison of " + (min.$class()) + " with " + (max.$class()) + " failed")
      };
      if ($truthy($rb_gt(Opal.const_get_relative($nesting, 'Comparable').$normalize(cmp), 0))) {
        self.$raise(Opal.const_get_relative($nesting, 'ArgumentError'), "min argument must be smaller than max argument")};
      if ($truthy($rb_lt(Opal.const_get_relative($nesting, 'Comparable').$normalize(self['$<=>'](min)), 0))) {
        return min};
      if ($truthy($rb_gt(Opal.const_get_relative($nesting, 'Comparable').$normalize(self['$<=>'](max)), 0))) {
        return max};
      return self;
    }, TMP_Comparable_clamp_8.$$arity = 2);
  })($nesting[0], $nesting)
};

/* Generated by Opal 0.11.0 */
Opal.modules["pathname"] = function(Opal) {
  function $rb_plus(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs + rhs : lhs['$+'](rhs);
  }
  var self = Opal.top, $nesting = [], nil = Opal.nil, $breaker = Opal.breaker, $slice = Opal.slice, $klass = Opal.klass, $truthy = Opal.truthy, $send = Opal.send, $module = Opal.module;

  Opal.add_stubs(['$require', '$include', '$quote', '$===', '$to_s', '$path', '$respond_to?', '$to_path', '$is_a?', '$nil?', '$raise', '$class', '$==', '$attr_reader', '$!', '$relative?', '$chop_basename', '$basename', '$=~', '$new', '$source', '$[]', '$rindex', '$sub', '$absolute?', '$expand_path', '$plus', '$unshift', '$length', '$!=', '$empty?', '$first', '$shift', '$+', '$join', '$dirname', '$pop', '$reverse_each', '$directory?', '$extname', '$<=>', '$nonzero?', '$proc', '$casecmp', '$cleanpath', '$inspect', '$include?', '$fill', '$map', '$entries']);
  
  self.$require("corelib/comparable");
  (function($base, $super, $parent_nesting) {
    function $Pathname(){};
    var self = $Pathname = $klass($base, $super, 'Pathname', $Pathname);

    var def = self.$$proto, $nesting = [self].concat($parent_nesting), TMP_Pathname_initialize_1, TMP_Pathname_$eq$eq_2, TMP_Pathname_absolute$q_3, TMP_Pathname_relative$q_4, TMP_Pathname_chop_basename_5, TMP_Pathname_root$q_6, TMP_Pathname_parent_7, TMP_Pathname_sub_8, TMP_Pathname_cleanpath_9, TMP_Pathname_to_path_10, TMP_Pathname_hash_11, TMP_Pathname_expand_path_12, TMP_Pathname_$_13, TMP_Pathname_plus_14, TMP_Pathname_join_16, TMP_Pathname_split_17, TMP_Pathname_dirname_18, TMP_Pathname_basename_19, TMP_Pathname_directory$q_20, TMP_Pathname_extname_21, TMP_Pathname_$lt$eq$gt_22, TMP_Pathname_23, TMP_Pathname_24, TMP_Pathname_relative_path_from_25, TMP_Pathname_entries_27;

    def.path = nil;
    
    self.$include(Opal.const_get_relative($nesting, 'Comparable'));
    Opal.const_set($nesting[0], 'SEPARATOR_PAT', new RegExp(Opal.const_get_relative($nesting, 'Regexp').$quote(Opal.const_get_qualified(Opal.const_get_relative($nesting, 'File'), 'SEPARATOR'))));
    
    Opal.defn(self, '$initialize', TMP_Pathname_initialize_1 = function $$initialize(path) {
      var self = this;

      
      if ($truthy(Opal.const_get_relative($nesting, 'Pathname')['$==='](path))) {
        self.path = path.$path().$to_s()
      } else if ($truthy(path['$respond_to?']("to_path"))) {
        self.path = path.$to_path()
      } else if ($truthy(path['$is_a?'](Opal.const_get_relative($nesting, 'String')))) {
        self.path = path
      } else if ($truthy(path['$nil?']())) {
        self.$raise(Opal.const_get_relative($nesting, 'TypeError'), "no implicit conversion of nil into String")
        } else {
        self.$raise(Opal.const_get_relative($nesting, 'TypeError'), "" + "no implicit conversion of " + (path.$class()) + " into String")
      };
      if (self.path['$==']("\u0000")) {
        return self.$raise(Opal.const_get_relative($nesting, 'ArgumentError'))
        } else {
        return nil
      };
    }, TMP_Pathname_initialize_1.$$arity = 1);
    self.$attr_reader("path");
    
    Opal.defn(self, '$==', TMP_Pathname_$eq$eq_2 = function(other) {
      var self = this;

      return other.$path()['$=='](self.path)
    }, TMP_Pathname_$eq$eq_2.$$arity = 1);
    
    Opal.defn(self, '$absolute?', TMP_Pathname_absolute$q_3 = function() {
      var self = this;

      return self['$relative?']()['$!']()
    }, TMP_Pathname_absolute$q_3.$$arity = 0);
    
    Opal.defn(self, '$relative?', TMP_Pathname_relative$q_4 = function() {
      var $a, $b, $c, self = this, path = nil, r = nil;

      
      path = self.path;
      while ($truthy((r = self.$chop_basename(path)))) {
        $c = r, $b = Opal.to_ary($c), (path = ($b[0] == null ? nil : $b[0])), $c
      };
      return path['$==']("");
    }, TMP_Pathname_relative$q_4.$$arity = 0);
    
    Opal.defn(self, '$chop_basename', TMP_Pathname_chop_basename_5 = function $$chop_basename(path) {
      var self = this, base = nil;

      
      base = Opal.const_get_relative($nesting, 'File').$basename(path);
      if ($truthy(Opal.const_get_relative($nesting, 'Regexp').$new("" + "^" + (Opal.const_get_qualified(Opal.const_get_relative($nesting, 'Pathname'), 'SEPARATOR_PAT').$source()) + "?$")['$=~'](base))) {
        return nil
        } else {
        return [path['$[]'](0, path.$rindex(base)), base]
      };
    }, TMP_Pathname_chop_basename_5.$$arity = 1);
    
    Opal.defn(self, '$root?', TMP_Pathname_root$q_6 = function() {
      var self = this;

      return self.path['$==']("/")
    }, TMP_Pathname_root$q_6.$$arity = 0);
    
    Opal.defn(self, '$parent', TMP_Pathname_parent_7 = function $$parent() {
      var self = this, new_path = nil;

      
      new_path = self.path.$sub(/\/([^\/]+\/?$)/, "");
      if (new_path['$==']("")) {
        new_path = (function() {if ($truthy(self['$absolute?']())) {
          return "/"
          } else {
          return "."
        }; return nil; })()};
      return Opal.const_get_relative($nesting, 'Pathname').$new(new_path);
    }, TMP_Pathname_parent_7.$$arity = 0);
    
    Opal.defn(self, '$sub', TMP_Pathname_sub_8 = function $$sub($a_rest) {
      var self = this, args;

      var $args_len = arguments.length, $rest_len = $args_len - 0;
      if ($rest_len < 0) { $rest_len = 0; }
      args = new Array($rest_len);
      for (var $arg_idx = 0; $arg_idx < $args_len; $arg_idx++) {
        args[$arg_idx - 0] = arguments[$arg_idx];
      }
      return Opal.const_get_relative($nesting, 'Pathname').$new($send(self.path, 'sub', Opal.to_a(args)))
    }, TMP_Pathname_sub_8.$$arity = -1);
    
    Opal.defn(self, '$cleanpath', TMP_Pathname_cleanpath_9 = function $$cleanpath() {
      var self = this;

      return Opal.normalize(self.path)
    }, TMP_Pathname_cleanpath_9.$$arity = 0);
    
    Opal.defn(self, '$to_path', TMP_Pathname_to_path_10 = function $$to_path() {
      var self = this;

      return self.path
    }, TMP_Pathname_to_path_10.$$arity = 0);
    
    Opal.defn(self, '$hash', TMP_Pathname_hash_11 = function $$hash() {
      var self = this;

      return self.path
    }, TMP_Pathname_hash_11.$$arity = 0);
    
    Opal.defn(self, '$expand_path', TMP_Pathname_expand_path_12 = function $$expand_path() {
      var self = this;

      return Opal.const_get_relative($nesting, 'File').$expand_path(self.path)
    }, TMP_Pathname_expand_path_12.$$arity = 0);
    
    Opal.defn(self, '$+', TMP_Pathname_$_13 = function(other) {
      var self = this;

      
      if ($truthy(Opal.const_get_relative($nesting, 'Pathname')['$==='](other))) {
        } else {
        other = Opal.const_get_relative($nesting, 'Pathname').$new(other)
      };
      return Opal.const_get_relative($nesting, 'Pathname').$new(self.$plus(self.path, other.$to_s()));
    }, TMP_Pathname_$_13.$$arity = 1);
    
    Opal.defn(self, '$plus', TMP_Pathname_plus_14 = function $$plus(path1, path2) {
      var $a, $b, $c, self = this, prefix2 = nil, index_list2 = nil, basename_list2 = nil, r2 = nil, basename2 = nil, prefix1 = nil, r1 = nil, basename1 = nil, suffix2 = nil;

      
      prefix2 = path2;
      index_list2 = [];
      basename_list2 = [];
      while ($truthy((r2 = self.$chop_basename(prefix2)))) {
        
        $c = r2, $b = Opal.to_ary($c), (prefix2 = ($b[0] == null ? nil : $b[0])), (basename2 = ($b[1] == null ? nil : $b[1])), $c;
        index_list2.$unshift(prefix2.$length());
        basename_list2.$unshift(basename2);
      };
      if ($truthy(prefix2['$!='](""))) {
        return path2};
      prefix1 = path1;
      while ($truthy(true)) {
        
        while ($truthy(($truthy($c = basename_list2['$empty?']()['$!']()) ? basename_list2.$first()['$=='](".") : $c))) {
          
          index_list2.$shift();
          basename_list2.$shift();
        };
        if ($truthy((r1 = self.$chop_basename(prefix1)))) {
          } else {
          break;
        };
        $c = r1, $b = Opal.to_ary($c), (prefix1 = ($b[0] == null ? nil : $b[0])), (basename1 = ($b[1] == null ? nil : $b[1])), $c;
        if (basename1['$=='](".")) {
          continue;};
        if ($truthy(($truthy($b = ($truthy($c = basename1['$==']("..")) ? $c : basename_list2['$empty?']())) ? $b : basename_list2.$first()['$!=']("..")))) {
          
          prefix1 = $rb_plus(prefix1, basename1);
          break;;};
        index_list2.$shift();
        basename_list2.$shift();
      };
      r1 = self.$chop_basename(prefix1);
      if ($truthy(($truthy($a = r1['$!']()) ? new RegExp(Opal.const_get_relative($nesting, 'SEPARATOR_PAT'))['$=~'](Opal.const_get_relative($nesting, 'File').$basename(prefix1)) : $a))) {
        while ($truthy(($truthy($b = basename_list2['$empty?']()['$!']()) ? basename_list2.$first()['$==']("..") : $b))) {
          
          index_list2.$shift();
          basename_list2.$shift();
        }};
      if ($truthy(basename_list2['$empty?']()['$!']())) {
        
        suffix2 = path2['$[]'](Opal.Range.$new(index_list2.$first(), -1, false));
        if ($truthy(r1)) {
          return Opal.const_get_relative($nesting, 'File').$join(prefix1, suffix2)
          } else {
          return $rb_plus(prefix1, suffix2)
        };
      } else if ($truthy(r1)) {
        return prefix1
        } else {
        return Opal.const_get_relative($nesting, 'File').$dirname(prefix1)
      };
    }, TMP_Pathname_plus_14.$$arity = 2);
    
    Opal.defn(self, '$join', TMP_Pathname_join_16 = function $$join($a_rest) {try {

      var TMP_15, self = this, args, result = nil;

      var $args_len = arguments.length, $rest_len = $args_len - 0;
      if ($rest_len < 0) { $rest_len = 0; }
      args = new Array($rest_len);
      for (var $arg_idx = 0; $arg_idx < $args_len; $arg_idx++) {
        args[$arg_idx - 0] = arguments[$arg_idx];
      }
      
      if ($truthy(args['$empty?']())) {
        return self};
      result = args.$pop();
      if ($truthy(Opal.const_get_relative($nesting, 'Pathname')['$==='](result))) {
        } else {
        result = Opal.const_get_relative($nesting, 'Pathname').$new(result)
      };
      if ($truthy(result['$absolute?']())) {
        return result};
      $send(args, 'reverse_each', [], (TMP_15 = function(arg){var self = TMP_15.$$s || this;
if (arg == null) arg = nil;
      
        if ($truthy(Opal.const_get_relative($nesting, 'Pathname')['$==='](arg))) {
          } else {
          arg = Opal.const_get_relative($nesting, 'Pathname').$new(arg)
        };
        result = $rb_plus(arg, result);
        if ($truthy(result['$absolute?']())) {
          Opal.ret(result)
          } else {
          return nil
        };}, TMP_15.$$s = self, TMP_15.$$arity = 1, TMP_15));
      return $rb_plus(self, result);
      } catch ($returner) { if ($returner === Opal.returner) { return $returner.$v } throw $returner; }
    }, TMP_Pathname_join_16.$$arity = -1);
    
    Opal.defn(self, '$split', TMP_Pathname_split_17 = function $$split() {
      var self = this;

      return [self.$dirname(), self.$basename()]
    }, TMP_Pathname_split_17.$$arity = 0);
    
    Opal.defn(self, '$dirname', TMP_Pathname_dirname_18 = function $$dirname() {
      var self = this;

      return Opal.const_get_relative($nesting, 'Pathname').$new(Opal.const_get_relative($nesting, 'File').$dirname(self.path))
    }, TMP_Pathname_dirname_18.$$arity = 0);
    
    Opal.defn(self, '$basename', TMP_Pathname_basename_19 = function $$basename() {
      var self = this;

      return Opal.const_get_relative($nesting, 'Pathname').$new(Opal.const_get_relative($nesting, 'File').$basename(self.path))
    }, TMP_Pathname_basename_19.$$arity = 0);
    
    Opal.defn(self, '$directory?', TMP_Pathname_directory$q_20 = function() {
      var self = this;

      return Opal.const_get_relative($nesting, 'File')['$directory?'](self.path)
    }, TMP_Pathname_directory$q_20.$$arity = 0);
    
    Opal.defn(self, '$extname', TMP_Pathname_extname_21 = function $$extname() {
      var self = this;

      return Opal.const_get_relative($nesting, 'File').$extname(self.path)
    }, TMP_Pathname_extname_21.$$arity = 0);
    
    Opal.defn(self, '$<=>', TMP_Pathname_$lt$eq$gt_22 = function(other) {
      var self = this;

      return self.$path()['$<=>'](other.$path())
    }, TMP_Pathname_$lt$eq$gt_22.$$arity = 1);
    Opal.alias(self, "eql?", "==");
    Opal.alias(self, "===", "==");
    Opal.alias(self, "to_str", "to_path");
    Opal.alias(self, "to_s", "to_path");
    Opal.const_set($nesting[0], 'SAME_PATHS', (function() {if ($truthy(Opal.const_get_qualified(Opal.const_get_relative($nesting, 'File'), 'FNM_SYSCASE')['$nonzero?']())) {
      return $send(self, 'proc', [], (TMP_Pathname_23 = function(a, b){var self = TMP_Pathname_23.$$s || this;
if (a == null) a = nil;if (b == null) b = nil;
      return a.$casecmp(b)['$=='](0)}, TMP_Pathname_23.$$s = self, TMP_Pathname_23.$$arity = 2, TMP_Pathname_23))
      } else {
      return $send(self, 'proc', [], (TMP_Pathname_24 = function(a, b){var self = TMP_Pathname_24.$$s || this;
if (a == null) a = nil;if (b == null) b = nil;
      return a['$=='](b)}, TMP_Pathname_24.$$s = self, TMP_Pathname_24.$$arity = 2, TMP_Pathname_24))
    }; return nil; })());
    
    Opal.defn(self, '$relative_path_from', TMP_Pathname_relative_path_from_25 = function $$relative_path_from(base_directory) {
      var $a, $b, $c, self = this, dest_directory = nil, dest_prefix = nil, dest_names = nil, r = nil, basename = nil, base_prefix = nil, base_names = nil, relpath_names = nil;

      
      dest_directory = self.$cleanpath().$to_s();
      base_directory = base_directory.$cleanpath().$to_s();
      dest_prefix = dest_directory;
      dest_names = [];
      while ($truthy((r = self.$chop_basename(dest_prefix)))) {
        
        $c = r, $b = Opal.to_ary($c), (dest_prefix = ($b[0] == null ? nil : $b[0])), (basename = ($b[1] == null ? nil : $b[1])), $c;
        if ($truthy(basename['$!=']("."))) {
          dest_names.$unshift(basename)};
      };
      base_prefix = base_directory;
      base_names = [];
      while ($truthy((r = self.$chop_basename(base_prefix)))) {
        
        $c = r, $b = Opal.to_ary($c), (base_prefix = ($b[0] == null ? nil : $b[0])), (basename = ($b[1] == null ? nil : $b[1])), $c;
        if ($truthy(basename['$!=']("."))) {
          base_names.$unshift(basename)};
      };
      if ($truthy(Opal.const_get_relative($nesting, 'SAME_PATHS')['$[]'](dest_prefix, base_prefix))) {
        } else {
        self.$raise(Opal.const_get_relative($nesting, 'ArgumentError'), "" + "different prefix: " + (dest_prefix.$inspect()) + " and " + (base_directory.$inspect()))
      };
      while ($truthy(($truthy($b = ($truthy($c = dest_names['$empty?']()['$!']()) ? base_names['$empty?']()['$!']() : $c)) ? Opal.const_get_relative($nesting, 'SAME_PATHS')['$[]'](dest_names.$first(), base_names.$first()) : $b))) {
        
        dest_names.$shift();
        base_names.$shift();
      };
      if ($truthy(base_names['$include?'](".."))) {
        self.$raise(Opal.const_get_relative($nesting, 'ArgumentError'), "" + "base_directory has ..: " + (base_directory.$inspect()))};
      base_names.$fill("..");
      relpath_names = $rb_plus(base_names, dest_names);
      if ($truthy(relpath_names['$empty?']())) {
        return Opal.const_get_relative($nesting, 'Pathname').$new(".")
        } else {
        return Opal.const_get_relative($nesting, 'Pathname').$new($send(Opal.const_get_relative($nesting, 'File'), 'join', Opal.to_a(relpath_names)))
      };
    }, TMP_Pathname_relative_path_from_25.$$arity = 1);
    return (Opal.defn(self, '$entries', TMP_Pathname_entries_27 = function $$entries() {
      var TMP_26, self = this;

      return $send(Opal.const_get_relative($nesting, 'Dir').$entries(self.path), 'map', [], (TMP_26 = function(f){var self = TMP_26.$$s || this;
if (f == null) f = nil;
      return self.$class().$new(f)}, TMP_26.$$s = self, TMP_26.$$arity = 1, TMP_26))
    }, TMP_Pathname_entries_27.$$arity = 0), nil) && 'entries';
  })($nesting[0], null, $nesting);
  return (function($base, $parent_nesting) {
    var $Kernel, self = $Kernel = $module($base, 'Kernel');

    var def = self.$$proto, $nesting = [self].concat($parent_nesting), TMP_Kernel_Pathname_28;

    
    Opal.defn(self, '$Pathname', TMP_Kernel_Pathname_28 = function $$Pathname(path) {
      var self = this;

      return Opal.const_get_relative($nesting, 'Pathname').$new(path)
    }, TMP_Kernel_Pathname_28.$$arity = 1)
  })($nesting[0], $nesting);
};

/* Generated by Opal 0.11.0 */
Opal.modules["ttfunk/directory"] = function(Opal) {
  function $rb_minus(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs - rhs : lhs['$-'](rhs);
  }
  var self = Opal.top, $nesting = [], nil = Opal.nil, $breaker = Opal.breaker, $slice = Opal.slice, $module = Opal.module, $klass = Opal.klass, $hash2 = Opal.hash2, $send = Opal.send;

  Opal.add_stubs(['$attr_reader', '$seek', '$unpack', '$read', '$times', '$[]=', '$-']);
  return (function($base, $parent_nesting) {
    var $TTFunk, self = $TTFunk = $module($base, 'TTFunk');

    var def = self.$$proto, $nesting = [self].concat($parent_nesting);

    (function($base, $super, $parent_nesting) {
      function $Directory(){};
      var self = $Directory = $klass($base, $super, 'Directory', $Directory);

      var def = self.$$proto, $nesting = [self].concat($parent_nesting), TMP_Directory_initialize_2;

      
      self.$attr_reader("tables");
      self.$attr_reader("scaler_type");
      return (Opal.defn(self, '$initialize', TMP_Directory_initialize_2 = function $$initialize(io, offset) {
        var $a, $b, TMP_1, self = this, table_count = nil;

        if (offset == null) {
          offset = 0;
        }
        
        io.$seek(offset);
        $b = io.$read(12).$unpack("Nn"), $a = Opal.to_ary($b), (self.scaler_type = ($a[0] == null ? nil : $a[0])), (table_count = ($a[1] == null ? nil : $a[1])), $b;
        self.tables = $hash2([], {});
        return $send(table_count, 'times', [], (TMP_1 = function(){var self = TMP_1.$$s || this, $c, $d, tag = nil, checksum = nil, length = nil, $writer = nil;
          if (self.tables == null) self.tables = nil;

        
          $d = io.$read(16).$unpack("a4N*"), $c = Opal.to_ary($d), (tag = ($c[0] == null ? nil : $c[0])), (checksum = ($c[1] == null ? nil : $c[1])), (offset = ($c[2] == null ? nil : $c[2])), (length = ($c[3] == null ? nil : $c[3])), $d;
          
          $writer = [tag, $hash2(["tag", "checksum", "offset", "length"], {"tag": tag, "checksum": checksum, "offset": offset, "length": length})];
          $send(self.tables, '[]=', Opal.to_a($writer));
          return $writer[$rb_minus($writer["length"], 1)];;}, TMP_1.$$s = self, TMP_1.$$arity = 0, TMP_1));
      }, TMP_Directory_initialize_2.$$arity = -2), nil) && 'initialize';
    })($nesting[0], null, $nesting)
  })($nesting[0], $nesting)
};

/* Generated by Opal 0.11.0 */
Opal.modules["ttfunk/resource_file"] = function(Opal) {
  function $rb_plus(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs + rhs : lhs['$+'](rhs);
  }
  function $rb_minus(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs - rhs : lhs['$-'](rhs);
  }
  function $rb_lt(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs < rhs : lhs['$<'](rhs);
  }
  var self = Opal.top, $nesting = [], nil = Opal.nil, $breaker = Opal.breaker, $slice = Opal.slice, $module = Opal.module, $klass = Opal.klass, $send = Opal.send, $hash2 = Opal.hash2, $truthy = Opal.truthy;

  Opal.add_stubs(['$attr_reader', '$open', '$new', '$unpack', '$read', '$+', '$pos=', '$-', '$first', '$upto', '$[]=', '$parse_from', '$pack', '$<', '$<<', '$[]', '$is_a?', '$keys', '$private', '$pos']);
  return (function($base, $parent_nesting) {
    var $TTFunk, self = $TTFunk = $module($base, 'TTFunk');

    var def = self.$$proto, $nesting = [self].concat($parent_nesting);

    (function($base, $super, $parent_nesting) {
      function $ResourceFile(){};
      var self = $ResourceFile = $klass($base, $super, 'ResourceFile', $ResourceFile);

      var def = self.$$proto, $nesting = [self].concat($parent_nesting), TMP_ResourceFile_open_2, TMP_ResourceFile_initialize_7, TMP_ResourceFile_$$_9, TMP_ResourceFile_resources_for_10, TMP_ResourceFile_parse_from_11;

      def.io = def.map = nil;
      
      self.$attr_reader("map");
      Opal.defs(self, '$open', TMP_ResourceFile_open_2 = function $$open(path) {
        var TMP_1, self = this, $iter = TMP_ResourceFile_open_2.$$p, $yield = $iter || nil;

        if ($iter) TMP_ResourceFile_open_2.$$p = null;
        return $send(Opal.const_get_qualified('::', 'File'), 'open', [path, "rb"], (TMP_1 = function(io){var self = TMP_1.$$s || this, file = nil;
if (io == null) io = nil;
        
          file = self.$new(io);
          return Opal.yield1($yield, file);;}, TMP_1.$$s = self, TMP_1.$$arity = 1, TMP_1))
      }, TMP_ResourceFile_open_2.$$arity = 1);
      
      Opal.defn(self, '$initialize', TMP_ResourceFile_initialize_7 = function $$initialize(io) {
        var $a, $b, TMP_3, self = this, data_offset = nil, map_offset = nil, map_length = nil, $writer = nil, type_list_offset = nil, name_list_offset = nil, max_index = nil;

        
        self.io = io;
        $b = self.io.$read(16).$unpack("NNx4N"), $a = Opal.to_ary($b), (data_offset = ($a[0] == null ? nil : $a[0])), (map_offset = ($a[1] == null ? nil : $a[1])), (map_length = ($a[2] == null ? nil : $a[2])), $b;
        self.map = $hash2([], {});
        
        $writer = [$rb_plus(map_offset, 24)];
        $send(self.io, 'pos=', Opal.to_a($writer));
        $writer[$rb_minus($writer["length"], 1)];;
        $b = self.io.$read(4).$unpack("n*"), $a = Opal.to_ary($b), (type_list_offset = ($a[0] == null ? nil : $a[0])), (name_list_offset = ($a[1] == null ? nil : $a[1])), $b;
        type_list_offset = $rb_plus(type_list_offset, map_offset);
        name_list_offset = $rb_plus(name_list_offset, map_offset);
        
        $writer = [type_list_offset];
        $send(self.io, 'pos=', Opal.to_a($writer));
        $writer[$rb_minus($writer["length"], 1)];;
        max_index = self.io.$read(2).$unpack("n").$first();
        return $send((0), 'upto', [max_index], (TMP_3 = function(){var self = TMP_3.$$s || this, $c, $d, TMP_4, type = nil, max_type_index = nil, ref_list_offset = nil;
          if (self.io == null) self.io = nil;
          if (self.map == null) self.map = nil;

        
          $d = self.io.$read(8).$unpack("A4nn"), $c = Opal.to_ary($d), (type = ($c[0] == null ? nil : $c[0])), (max_type_index = ($c[1] == null ? nil : $c[1])), (ref_list_offset = ($c[2] == null ? nil : $c[2])), $d;
          
          $writer = [type, $hash2(["list", "named"], {"list": [], "named": $hash2([], {})})];
          $send(self.map, '[]=', Opal.to_a($writer));
          $writer[$rb_minus($writer["length"], 1)];;
          return $send(self, 'parse_from', [$rb_plus(type_list_offset, ref_list_offset)], (TMP_4 = function(){var self = TMP_4.$$s || this, TMP_5;

          return $send((0), 'upto', [max_type_index], (TMP_5 = function(){var self = TMP_5.$$s || this, $e, $f, TMP_6, id = nil, name_ofs = nil, attr = nil, data_ofs = nil, handle = nil, entry = nil;
              if (self.io == null) self.io = nil;
              if (self.map == null) self.map = nil;

            
              $f = self.io.$read(5).$unpack("nnC"), $e = Opal.to_ary($f), (id = ($e[0] == null ? nil : $e[0])), (name_ofs = ($e[1] == null ? nil : $e[1])), (attr = ($e[2] == null ? nil : $e[2])), $f;
              data_ofs = self.io.$read(3);
              data_ofs = $rb_plus(data_offset, [0, data_ofs].$pack("CA*").$unpack("N").$first());
              handle = self.io.$read(4).$unpack("N").$first();
              entry = $hash2(["id", "attributes", "offset", "handle"], {"id": id, "attributes": attr, "offset": data_ofs, "handle": handle});
              if ($truthy($rb_lt($rb_plus(name_list_offset, name_ofs), $rb_plus(map_offset, map_length)))) {
                $send(self, 'parse_from', [$rb_plus(name_ofs, name_list_offset)], (TMP_6 = function(){var self = TMP_6.$$s || this, len = nil;
                  if (self.io == null) self.io = nil;

                
                  len = self.io.$read(1).$unpack("C").$first();
                  
                  $writer = ["name", self.io.$read(len)];
                  $send(entry, '[]=', Opal.to_a($writer));
                  return $writer[$rb_minus($writer["length"], 1)];;}, TMP_6.$$s = self, TMP_6.$$arity = 0, TMP_6))};
              self.map['$[]'](type)['$[]']("list")['$<<'](entry);
              if ($truthy(entry['$[]']("name"))) {
                
                $writer = [entry['$[]']("name"), entry];
                $send(self.map['$[]'](type)['$[]']("named"), '[]=', Opal.to_a($writer));
                return $writer[$rb_minus($writer["length"], 1)];
                } else {
                return nil
              };}, TMP_5.$$s = self, TMP_5.$$arity = 0, TMP_5))}, TMP_4.$$s = self, TMP_4.$$arity = 0, TMP_4));}, TMP_3.$$s = self, TMP_3.$$arity = 0, TMP_3));
      }, TMP_ResourceFile_initialize_7.$$arity = 1);
      
      Opal.defn(self, '$[]', TMP_ResourceFile_$$_9 = function(type, index) {try {

        var TMP_8, self = this, collection = nil;

        if (index == null) {
          index = 0;
        }
        if ($truthy(self.map['$[]'](type))) {
          
          collection = (function() {if ($truthy(index['$is_a?'](Opal.const_get_relative($nesting, 'Integer')))) {
            return "list"
            } else {
            return "named"
          }; return nil; })();
          if ($truthy(self.map['$[]'](type)['$[]'](collection)['$[]'](index))) {
            return $send(self, 'parse_from', [self.map['$[]'](type)['$[]'](collection)['$[]'](index)['$[]']("offset")], (TMP_8 = function(){var self = TMP_8.$$s || this, length = nil;
              if (self.io == null) self.io = nil;

            
              length = self.io.$read(4).$unpack("N").$first();
              Opal.ret(self.io.$read(length));}, TMP_8.$$s = self, TMP_8.$$arity = 0, TMP_8))
            } else {
            return nil
          };
          } else {
          return nil
        }
        } catch ($returner) { if ($returner === Opal.returner) { return $returner.$v } throw $returner; }
      }, TMP_ResourceFile_$$_9.$$arity = -2);
      
      Opal.defn(self, '$resources_for', TMP_ResourceFile_resources_for_10 = function $$resources_for(type) {
        var $a, $b, self = this;

        return ($truthy($a = ($truthy($b = self.map['$[]'](type)) ? self.map['$[]'](type)['$[]']("named") : $b)) ? $a : $hash2([], {})).$keys()
      }, TMP_ResourceFile_resources_for_10.$$arity = 1);
      self.$private();
      return (Opal.defn(self, '$parse_from', TMP_ResourceFile_parse_from_11 = function $$parse_from(offset) {
        var self = this, $iter = TMP_ResourceFile_parse_from_11.$$p, $yield = $iter || nil, saved = nil, $writer = nil;

        if ($iter) TMP_ResourceFile_parse_from_11.$$p = null;
        return (function() { try {
        
        saved = self.io.$pos();
        
        $writer = [offset];
        $send(self.io, 'pos=', Opal.to_a($writer));
        $writer[$rb_minus($writer["length"], 1)];;
        return Opal.yieldX($yield, []);;
        } finally {
          (($writer = [saved]), $send(self.io, 'pos=', Opal.to_a($writer)), $writer[$rb_minus($writer["length"], 1)])
        }; })()
      }, TMP_ResourceFile_parse_from_11.$$arity = 1), nil) && 'parse_from';
    })($nesting[0], null, $nesting)
  })($nesting[0], $nesting)
};

/* Generated by Opal 0.11.0 */
Opal.modules["ttfunk/collection"] = function(Opal) {
  function $rb_times(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs * rhs : lhs['$*'](rhs);
  }
  function $rb_minus(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs - rhs : lhs['$-'](rhs);
  }
  var self = Opal.top, $nesting = [], nil = Opal.nil, $breaker = Opal.breaker, $slice = Opal.slice, $module = Opal.module, $klass = Opal.klass, $send = Opal.send, $truthy = Opal.truthy;

  Opal.add_stubs(['$include', '$open', '$new', '$read', '$==', '$raise', '$unpack', '$first', '$*', '$rewind', '$length', '$times', '$count', '$[]', '$[]=', '$-']);
  return (function($base, $parent_nesting) {
    var $TTFunk, self = $TTFunk = $module($base, 'TTFunk');

    var def = self.$$proto, $nesting = [self].concat($parent_nesting);

    (function($base, $super, $parent_nesting) {
      function $Collection(){};
      var self = $Collection = $klass($base, $super, 'Collection', $Collection);

      var def = self.$$proto, $nesting = [self].concat($parent_nesting), TMP_Collection_open_2, TMP_Collection_initialize_3, TMP_Collection_count_4, TMP_Collection_each_6, TMP_Collection_$$_7;

      def.offsets = def.cache = def.contents = nil;
      
      self.$include(Opal.const_get_relative($nesting, 'Enumerable'));
      Opal.defs(self, '$open', TMP_Collection_open_2 = function $$open(path) {
        var TMP_1, self = this, $iter = TMP_Collection_open_2.$$p, $yield = $iter || nil;

        if ($iter) TMP_Collection_open_2.$$p = null;
        return $send(Opal.const_get_qualified('::', 'File'), 'open', [path, "rb"], (TMP_1 = function(io){var self = TMP_1.$$s || this;
if (io == null) io = nil;
        return Opal.yield1($yield, self.$new(io));}, TMP_1.$$s = self, TMP_1.$$arity = 1, TMP_1))
      }, TMP_Collection_open_2.$$arity = 1);
      
      Opal.defn(self, '$initialize', TMP_Collection_initialize_3 = function $$initialize(io) {
        var $a, $b, self = this, tag = nil, _major = nil, _minor = nil, count = nil;

        
        tag = io.$read(4);
        if (tag['$==']("ttcf")) {
          } else {
          self.$raise(Opal.const_get_relative($nesting, 'ArgumentError'), "not a TTC file")
        };
        $b = io.$read(4).$unpack("n*"), $a = Opal.to_ary($b), (_major = ($a[0] == null ? nil : $a[0])), (_minor = ($a[1] == null ? nil : $a[1])), $b;
        count = io.$read(4).$unpack("N").$first();
        self.offsets = io.$read($rb_times(count, 4)).$unpack("N*");
        io.$rewind();
        self.contents = io.$read();
        return (self.cache = []);
      }, TMP_Collection_initialize_3.$$arity = 1);
      
      Opal.defn(self, '$count', TMP_Collection_count_4 = function $$count() {
        var self = this;

        return self.offsets.$length()
      }, TMP_Collection_count_4.$$arity = 0);
      
      Opal.defn(self, '$each', TMP_Collection_each_6 = function $$each() {
        var TMP_5, self = this, $iter = TMP_Collection_each_6.$$p, $yield = $iter || nil;

        if ($iter) TMP_Collection_each_6.$$p = null;
        
        $send(self.$count(), 'times', [], (TMP_5 = function(index){var self = TMP_5.$$s || this;
if (index == null) index = nil;
        return Opal.yield1($yield, self['$[]'](index));}, TMP_5.$$s = self, TMP_5.$$arity = 1, TMP_5));
        return self;
      }, TMP_Collection_each_6.$$arity = 0);
      return (Opal.defn(self, '$[]', TMP_Collection_$$_7 = function(index) {
        var $a, self = this, $writer = nil;

        return ($truthy($a = self.cache['$[]'](index)) ? $a : (($writer = [index, Opal.const_get_qualified(Opal.const_get_relative($nesting, 'TTFunk'), 'File').$new(self.contents, self.offsets['$[]'](index))]), $send(self.cache, '[]=', Opal.to_a($writer)), $writer[$rb_minus($writer["length"], 1)]))
      }, TMP_Collection_$$_7.$$arity = 1), nil) && '[]';
    })($nesting[0], null, $nesting)
  })($nesting[0], $nesting)
};

/* Generated by Opal 0.11.0 */
Opal.modules["ttfunk/reader"] = function(Opal) {
  function $rb_times(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs * rhs : lhs['$*'](rhs);
  }
  function $rb_ge(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs >= rhs : lhs['$>='](rhs);
  }
  function $rb_plus(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs + rhs : lhs['$+'](rhs);
  }
  function $rb_minus(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs - rhs : lhs['$-'](rhs);
  }
  var self = Opal.top, $nesting = [], nil = Opal.nil, $breaker = Opal.breaker, $slice = Opal.slice, $module = Opal.module, $send = Opal.send, $truthy = Opal.truthy;

  Opal.add_stubs(['$private', '$contents', '$unpack', '$read', '$io', '$map', '$*', '$to_signed', '$>=', '$-@', '$+', '$^', '$pos', '$pos=', '$-', '$each_with_index', '$printf', '$==', '$%', '$puts', '$print', '$length']);
  return (function($base, $parent_nesting) {
    var $TTFunk, self = $TTFunk = $module($base, 'TTFunk');

    var def = self.$$proto, $nesting = [self].concat($parent_nesting);

    (function($base, $parent_nesting) {
      var $Reader, self = $Reader = $module($base, 'Reader');

      var def = self.$$proto, $nesting = [self].concat($parent_nesting), TMP_Reader_io_1, TMP_Reader_read_2, TMP_Reader_read_signed_4, TMP_Reader_to_signed_5, TMP_Reader_parse_from_6, TMP_Reader_hexdump_8;

      
      self.$private();
      
      Opal.defn(self, '$io', TMP_Reader_io_1 = function $$io() {
        var self = this;
        if (self.file == null) self.file = nil;

        return self.file.$contents()
      }, TMP_Reader_io_1.$$arity = 0);
      
      Opal.defn(self, '$read', TMP_Reader_read_2 = function $$read(bytes, format) {
        var self = this;

        return self.$io().$read(bytes).$unpack(format)
      }, TMP_Reader_read_2.$$arity = 2);
      
      Opal.defn(self, '$read_signed', TMP_Reader_read_signed_4 = function $$read_signed(count) {
        var TMP_3, self = this;

        return $send(self.$read($rb_times(count, 2), "n*"), 'map', [], (TMP_3 = function(i){var self = TMP_3.$$s || this;
if (i == null) i = nil;
        return self.$to_signed(i)}, TMP_3.$$s = self, TMP_3.$$arity = 1, TMP_3))
      }, TMP_Reader_read_signed_4.$$arity = 1);
      
      Opal.defn(self, '$to_signed', TMP_Reader_to_signed_5 = function $$to_signed(n) {
        var self = this;

        if ($truthy($rb_ge(n, 32768))) {
          return $rb_plus(n['$^'](65535), 1)['$-@']()
          } else {
          return n
        }
      }, TMP_Reader_to_signed_5.$$arity = 1);
      
      Opal.defn(self, '$parse_from', TMP_Reader_parse_from_6 = function $$parse_from(position) {
        var self = this, $iter = TMP_Reader_parse_from_6.$$p, $yield = $iter || nil, saved = nil, $writer = nil, result = nil;

        if ($iter) TMP_Reader_parse_from_6.$$p = null;
        
        saved = self.$io().$pos();
        
        $writer = [position];
        $send(self.$io(), 'pos=', Opal.to_a($writer));
        $writer[$rb_minus($writer["length"], 1)];;
        result = Opal.yield1($yield, position);
        
        $writer = [saved];
        $send(self.$io(), 'pos=', Opal.to_a($writer));
        $writer[$rb_minus($writer["length"], 1)];;
        return result;
      }, TMP_Reader_parse_from_6.$$arity = 1);
      
      Opal.defn(self, '$hexdump', TMP_Reader_hexdump_8 = function $$hexdump(string) {
        var TMP_7, self = this, bytes = nil;

        
        bytes = string.$unpack("C*");
        $send(bytes, 'each_with_index', [], (TMP_7 = function(c, i){var self = TMP_7.$$s || this;
if (c == null) c = nil;if (i == null) i = nil;
        
          self.$printf("%02X", c);
          if ($rb_plus(i, 1)['$%'](16)['$=='](0)) {
            return self.$puts()
          } else if ($rb_plus(i, 1)['$%'](8)['$=='](0)) {
            return self.$print("  ")
            } else {
            return self.$print(" ")
          };}, TMP_7.$$s = self, TMP_7.$$arity = 2, TMP_7));
        if (bytes.$length()['$%'](16)['$=='](0)) {
          return nil
          } else {
          return self.$puts()
        };
      }, TMP_Reader_hexdump_8.$$arity = 1);
    })($nesting[0], $nesting)
  })($nesting[0], $nesting)
};

/* Generated by Opal 0.11.0 */
Opal.modules["ttfunk/encoding/mac_roman"] = function(Opal) {
  var self = Opal.top, $nesting = [], nil = Opal.nil, $breaker = Opal.breaker, $slice = Opal.slice, $module = Opal.module, $klass = Opal.klass, $send = Opal.send, $range = Opal.range, $hash = Opal.hash, $truthy = Opal.truthy;

  Opal.add_stubs(['$freeze', '$update', '$[]', '$flatten', '$zip', '$invert', '$!', '$nil?', '$pack', '$to_unicode_codepoints', '$unpack', '$from_unicode_codepoints', '$map']);
  return (function($base, $parent_nesting) {
    var $TTFunk, self = $TTFunk = $module($base, 'TTFunk');

    var def = self.$$proto, $nesting = [self].concat($parent_nesting);

    (function($base, $parent_nesting) {
      var $Encoding, self = $Encoding = $module($base, 'Encoding');

      var def = self.$$proto, $nesting = [self].concat($parent_nesting);

      (function($base, $super, $parent_nesting) {
        function $MacRoman(){};
        var self = $MacRoman = $klass($base, $super, 'MacRoman', $MacRoman);

        var def = self.$$proto, $nesting = [self].concat($parent_nesting), TMP_MacRoman_covers$q_1, TMP_MacRoman_to_utf8_2, TMP_MacRoman_to_unicode_3, TMP_MacRoman_from_utf8_4, TMP_MacRoman_from_unicode_5, TMP_MacRoman_to_unicode_codepoints_7, TMP_MacRoman_from_unicode_codepoints_9;

        
        Opal.const_set($nesting[0], 'TO_UNICODE', $send(Opal.const_get_relative($nesting, 'Hash'), '[]', Opal.to_a($range(0, 255, false).$zip($range(0, 255, false)).$flatten())).$update($hash(129, 197, 130, 199, 131, 201, 132, 209, 133, 214, 134, 220, 135, 225, 136, 224, 137, 226, 138, 228, 139, 227, 140, 229, 141, 231, 142, 233, 143, 232, 144, 234, 145, 235, 146, 237, 147, 236, 148, 238, 149, 239, 150, 241, 151, 243, 152, 242, 153, 244, 154, 246, 155, 245, 156, 250, 157, 249, 158, 251, 159, 252, 160, 8224, 161, 176, 164, 167, 165, 8226, 166, 182, 167, 223, 168, 174, 170, 8482, 171, 180, 172, 168, 173, 8800, 174, 198, 175, 216, 176, 8734, 178, 8804, 179, 8805, 180, 165, 182, 8706, 183, 8721, 184, 8719, 185, 960, 186, 8747, 187, 170, 188, 186, 189, 937, 190, 230, 191, 248, 192, 191, 193, 161, 194, 172, 195, 8730, 196, 402, 197, 8776, 198, 8710, 199, 171, 200, 187, 201, 8230, 202, 160, 203, 192, 204, 195, 205, 213, 206, 338, 207, 339, 208, 8211, 209, 8212, 210, 8220, 211, 8221, 212, 8216, 213, 8217, 214, 247, 215, 9674, 216, 255, 217, 376, 218, 8260, 219, 8364, 220, 8249, 221, 8250, 222, 64257, 223, 64258, 224, 8225, 225, 183, 226, 8218, 227, 8222, 228, 8240, 229, 194, 230, 202, 231, 193, 232, 203, 233, 200, 234, 205, 235, 206, 236, 207, 237, 204, 238, 211, 239, 212, 240, 63743, 241, 210, 242, 218, 243, 219, 244, 217, 245, 305, 246, 710, 247, 732, 248, 175, 249, 728, 250, 729, 251, 730, 252, 184, 253, 733, 254, 731, 255, 711)).$freeze());
        Opal.const_set($nesting[0], 'FROM_UNICODE', Opal.const_get_relative($nesting, 'TO_UNICODE').$invert().$freeze());
        Opal.const_set($nesting[0], 'POSTSCRIPT_GLYPH_MAPPING', [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 0, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130, 131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 145, 146, 147, 148, 149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159, 160, 161, 162, 163, 164, 165, 166, 167, 168, 169, 170, 171, 172, 173, 174, 175, 176, 177, 178, 179, 180, 181, 182, 183, 184, 185, 186, 187, 188, "Euro", 190, 191, 192, 193, 194, 195, 196, 197, 198, 199, 200, 201, 202, 203, 204, 205, 206, 207, 208, 209, 210, 211, 212, 213, 214, 215, 216, 217, 218, 219, 220, 221, 222, 223, 224, 225].$freeze());
        Opal.defs(self, '$covers?', TMP_MacRoman_covers$q_1 = function(character) {
          var self = this;

          return Opal.const_get_relative($nesting, 'FROM_UNICODE')['$[]'](character)['$nil?']()['$!']()
        }, TMP_MacRoman_covers$q_1.$$arity = 1);
        Opal.defs(self, '$to_utf8', TMP_MacRoman_to_utf8_2 = function $$to_utf8(string) {
          var self = this;

          return self.$to_unicode_codepoints(string.$unpack("C*")).$pack("U*")
        }, TMP_MacRoman_to_utf8_2.$$arity = 1);
        Opal.defs(self, '$to_unicode', TMP_MacRoman_to_unicode_3 = function $$to_unicode(string) {
          var self = this;

          return self.$to_unicode_codepoints(string.$unpack("C*")).$pack("n*")
        }, TMP_MacRoman_to_unicode_3.$$arity = 1);
        Opal.defs(self, '$from_utf8', TMP_MacRoman_from_utf8_4 = function $$from_utf8(string) {
          var self = this;

          return self.$from_unicode_codepoints(string.$unpack("U*")).$pack("C*")
        }, TMP_MacRoman_from_utf8_4.$$arity = 1);
        Opal.defs(self, '$from_unicode', TMP_MacRoman_from_unicode_5 = function $$from_unicode(string) {
          var self = this;

          return self.$from_unicode_codepoints(string.$unpack("n*")).$pack("C*")
        }, TMP_MacRoman_from_unicode_5.$$arity = 1);
        Opal.defs(self, '$to_unicode_codepoints', TMP_MacRoman_to_unicode_codepoints_7 = function $$to_unicode_codepoints(array) {
          var TMP_6, self = this;

          return $send(array, 'map', [], (TMP_6 = function(code){var self = TMP_6.$$s || this;
if (code == null) code = nil;
          return Opal.const_get_relative($nesting, 'TO_UNICODE')['$[]'](code)}, TMP_6.$$s = self, TMP_6.$$arity = 1, TMP_6))
        }, TMP_MacRoman_to_unicode_codepoints_7.$$arity = 1);
        return Opal.defs(self, '$from_unicode_codepoints', TMP_MacRoman_from_unicode_codepoints_9 = function $$from_unicode_codepoints(array) {
          var TMP_8, self = this;

          return $send(array, 'map', [], (TMP_8 = function(code){var self = TMP_8.$$s || this, $a;
if (code == null) code = nil;
          return ($truthy($a = Opal.const_get_relative($nesting, 'FROM_UNICODE')['$[]'](code)) ? $a : 0)}, TMP_8.$$s = self, TMP_8.$$arity = 1, TMP_8))
        }, TMP_MacRoman_from_unicode_codepoints_9.$$arity = 1);
      })($nesting[0], null, $nesting)
    })($nesting[0], $nesting)
  })($nesting[0], $nesting)
};

/* Generated by Opal 0.11.0 */
Opal.modules["ttfunk/encoding/windows_1252"] = function(Opal) {
  var self = Opal.top, $nesting = [], nil = Opal.nil, $breaker = Opal.breaker, $slice = Opal.slice, $module = Opal.module, $klass = Opal.klass, $send = Opal.send, $range = Opal.range, $hash = Opal.hash, $truthy = Opal.truthy;

  Opal.add_stubs(['$freeze', '$update', '$[]', '$flatten', '$zip', '$invert', '$!', '$nil?', '$pack', '$to_unicode_codepoints', '$unpack', '$from_unicode_codepoints', '$map']);
  return (function($base, $parent_nesting) {
    var $TTFunk, self = $TTFunk = $module($base, 'TTFunk');

    var def = self.$$proto, $nesting = [self].concat($parent_nesting);

    (function($base, $parent_nesting) {
      var $Encoding, self = $Encoding = $module($base, 'Encoding');

      var def = self.$$proto, $nesting = [self].concat($parent_nesting);

      (function($base, $super, $parent_nesting) {
        function $Windows1252(){};
        var self = $Windows1252 = $klass($base, $super, 'Windows1252', $Windows1252);

        var def = self.$$proto, $nesting = [self].concat($parent_nesting), TMP_Windows1252_covers$q_1, TMP_Windows1252_to_utf8_2, TMP_Windows1252_to_unicode_3, TMP_Windows1252_from_utf8_4, TMP_Windows1252_from_unicode_5, TMP_Windows1252_to_unicode_codepoints_7, TMP_Windows1252_from_unicode_codepoints_9;

        
        Opal.const_set($nesting[0], 'TO_UNICODE', $send(Opal.const_get_relative($nesting, 'Hash'), '[]', Opal.to_a($range(0, 255, false).$zip($range(0, 255, false)).$flatten())).$update($hash(128, 8364, 130, 8218, 131, 402, 132, 8222, 133, 8230, 134, 8224, 135, 8225, 136, 710, 137, 8240, 138, 352, 139, 8249, 140, 338, 142, 381, 145, 8216, 146, 8217, 147, 8220, 148, 8221, 149, 8226, 150, 8211, 151, 8212, 152, 732, 153, 8482, 154, 353, 155, 8250, 156, 338, 158, 382, 159, 376)).$freeze());
        Opal.const_set($nesting[0], 'FROM_UNICODE', Opal.const_get_relative($nesting, 'TO_UNICODE').$invert().$freeze());
        Opal.const_set($nesting[0], 'POSTSCRIPT_GLYPH_MAPPING', [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 0, "Euro", 0, 196, 166, 197, 171, 130, 194, 216, 198, 228, 190, 176, 0, 230, 0, 0, 182, 183, 180, 181, 135, 178, 179, 217, 140, 229, 191, 177, 0, 231, 186, 3, 163, 132, 133, 189, 150, 232, 134, 142, 139, 157, 169, 164, 16, 138, 218, 131, 147, 242, 243, 141, 151, 136, 195, 222, 241, 158, 170, 245, 244, 246, 162, 173, 201, 199, 174, 98, 99, 144, 100, 203, 101, 200, 202, 207, 204, 205, 206, 233, 102, 211, 208, 209, 175, 103, 240, 145, 214, 212, 213, 104, 235, 237, 137, 106, 105, 107, 109, 108, 110, 160, 111, 113, 112, 114, 115, 117, 116, 118, 119, 234, 120, 122, 121, 123, 125, 124, 184, 161, 127, 126, 128, 129, 236, 238, 186].$freeze());
        Opal.defs(self, '$covers?', TMP_Windows1252_covers$q_1 = function(character) {
          var self = this;

          return Opal.const_get_relative($nesting, 'FROM_UNICODE')['$[]'](character)['$nil?']()['$!']()
        }, TMP_Windows1252_covers$q_1.$$arity = 1);
        Opal.defs(self, '$to_utf8', TMP_Windows1252_to_utf8_2 = function $$to_utf8(string) {
          var self = this;

          return self.$to_unicode_codepoints(string.$unpack("C*")).$pack("U*")
        }, TMP_Windows1252_to_utf8_2.$$arity = 1);
        Opal.defs(self, '$to_unicode', TMP_Windows1252_to_unicode_3 = function $$to_unicode(string) {
          var self = this;

          return self.$to_unicode_codepoints(string.$unpack("C*")).$pack("n*")
        }, TMP_Windows1252_to_unicode_3.$$arity = 1);
        Opal.defs(self, '$from_utf8', TMP_Windows1252_from_utf8_4 = function $$from_utf8(string) {
          var self = this;

          return self.$from_unicode_codepoints(string.$unpack("U*")).$pack("C*")
        }, TMP_Windows1252_from_utf8_4.$$arity = 1);
        Opal.defs(self, '$from_unicode', TMP_Windows1252_from_unicode_5 = function $$from_unicode(string) {
          var self = this;

          return self.$from_unicode_codepoints(string.$unpack("n*")).$pack("C*")
        }, TMP_Windows1252_from_unicode_5.$$arity = 1);
        Opal.defs(self, '$to_unicode_codepoints', TMP_Windows1252_to_unicode_codepoints_7 = function $$to_unicode_codepoints(array) {
          var TMP_6, self = this;

          return $send(array, 'map', [], (TMP_6 = function(code){var self = TMP_6.$$s || this;
if (code == null) code = nil;
          return Opal.const_get_relative($nesting, 'TO_UNICODE')['$[]'](code)}, TMP_6.$$s = self, TMP_6.$$arity = 1, TMP_6))
        }, TMP_Windows1252_to_unicode_codepoints_7.$$arity = 1);
        return Opal.defs(self, '$from_unicode_codepoints', TMP_Windows1252_from_unicode_codepoints_9 = function $$from_unicode_codepoints(array) {
          var TMP_8, self = this;

          return $send(array, 'map', [], (TMP_8 = function(code){var self = TMP_8.$$s || this, $a;
if (code == null) code = nil;
          return ($truthy($a = Opal.const_get_relative($nesting, 'FROM_UNICODE')['$[]'](code)) ? $a : 0)}, TMP_8.$$s = self, TMP_8.$$arity = 1, TMP_8))
        }, TMP_Windows1252_from_unicode_codepoints_9.$$arity = 1);
      })($nesting[0], null, $nesting)
    })($nesting[0], $nesting)
  })($nesting[0], $nesting)
};

/* Generated by Opal 0.11.0 */
Opal.modules["ttfunk/table/cmap/format00"] = function(Opal) {
  function $rb_plus(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs + rhs : lhs['$+'](rhs);
  }
  function $rb_minus(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs - rhs : lhs['$-'](rhs);
  }
  var self = Opal.top, $nesting = [], nil = Opal.nil, $breaker = Opal.breaker, $slice = Opal.slice, $module = Opal.module, $klass = Opal.klass, $hash = Opal.hash, $send = Opal.send, $hash2 = Opal.hash2, $truthy = Opal.truthy;

  Opal.add_stubs(['$attr_reader', '$new', '$each_with_object', '$sort', '$keys', '$[]', '$+', '$[]=', '$-', '$pack', '$private', '$read']);
  
  self.$require("ttfunk/table/cmap/format00"+ '/../' + "../../encoding/mac_roman");
  self.$require("ttfunk/table/cmap/format00"+ '/../' + "../../encoding/windows_1252");
  return (function($base, $parent_nesting) {
    var $TTFunk, self = $TTFunk = $module($base, 'TTFunk');

    var def = self.$$proto, $nesting = [self].concat($parent_nesting);

    (function($base, $super, $parent_nesting) {
      function $Table(){};
      var self = $Table = $klass($base, $super, 'Table', $Table);

      var def = self.$$proto, $nesting = [self].concat($parent_nesting);

      return (function($base, $super, $parent_nesting) {
        function $Cmap(){};
        var self = $Cmap = $klass($base, $super, 'Cmap', $Cmap);

        var def = self.$$proto, $nesting = [self].concat($parent_nesting);

        return (function($base, $parent_nesting) {
          var $Format00, self = $Format00 = $module($base, 'Format00');

          var def = self.$$proto, $nesting = [self].concat($parent_nesting), TMP_Format00_encode_2, TMP_Format00_$$_3, TMP_Format00_supported$q_4, TMP_Format00_parse_cmap$B_5;

          
          self.$attr_reader("language");
          self.$attr_reader("code_map");
          Opal.defs(self, '$encode', TMP_Format00_encode_2 = function $$encode(charmap) {
            var TMP_1, self = this, next_id = nil, glyph_indexes = nil, glyph_map = nil, new_map = nil, subtable = nil;

            
            next_id = 0;
            glyph_indexes = Opal.const_get_relative($nesting, 'Array').$new(256, 0);
            glyph_map = $hash(0, 0);
            new_map = $send(charmap.$keys().$sort(), 'each_with_object', [$hash2([], {})], (TMP_1 = function(code, map){var self = TMP_1.$$s || this, $a, $writer = nil;
if (code == null) code = nil;if (map == null) map = nil;
            
              ($truthy($a = glyph_map['$[]'](charmap['$[]'](code))) ? $a : (($writer = [charmap['$[]'](code), (next_id = $rb_plus(next_id, 1))]), $send(glyph_map, '[]=', Opal.to_a($writer)), $writer[$rb_minus($writer["length"], 1)]));
              
              $writer = [code, $hash2(["old", "new"], {"old": charmap['$[]'](code), "new": glyph_map['$[]'](charmap['$[]'](code))})];
              $send(map, '[]=', Opal.to_a($writer));
              $writer[$rb_minus($writer["length"], 1)];;
              
              $writer = [code, glyph_map['$[]'](charmap['$[]'](code))];
              $send(glyph_indexes, '[]=', Opal.to_a($writer));
              $writer[$rb_minus($writer["length"], 1)];;
              return map;}, TMP_1.$$s = self, TMP_1.$$arity = 2, TMP_1));
            subtable = [0, 262, 0].concat(Opal.to_a(glyph_indexes)).$pack("nnnC*");
            return $hash2(["charmap", "subtable", "max_glyph_id"], {"charmap": new_map, "subtable": subtable, "max_glyph_id": $rb_plus(next_id, 1)});
          }, TMP_Format00_encode_2.$$arity = 1);
          
          Opal.defn(self, '$[]', TMP_Format00_$$_3 = function(code) {
            var $a, self = this;
            if (self.code_map == null) self.code_map = nil;

            return ($truthy($a = self.code_map['$[]'](code)) ? $a : 0)
          }, TMP_Format00_$$_3.$$arity = 1);
          
          Opal.defn(self, '$supported?', TMP_Format00_supported$q_4 = function() {
            var self = this;

            return true
          }, TMP_Format00_supported$q_4.$$arity = 0);
          self.$private();
          
          Opal.defn(self, '$parse_cmap!', TMP_Format00_parse_cmap$B_5 = function() {
            var self = this;

            
            self.language = self.$read(4, "x2n");
            return (self.code_map = self.$read(256, "C*"));
          }, TMP_Format00_parse_cmap$B_5.$$arity = 0);
        })($nesting[0], $nesting)
      })($nesting[0], null, $nesting)
    })($nesting[0], null, $nesting)
  })($nesting[0], $nesting);
};

/* Generated by Opal 0.11.0 */
Opal.modules["ttfunk/table/cmap/format04"] = function(Opal) {
  function $rb_plus(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs + rhs : lhs['$+'](rhs);
  }
  function $rb_minus(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs - rhs : lhs['$-'](rhs);
  }
  function $rb_ge(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs >= rhs : lhs['$>='](rhs);
  }
  function $rb_times(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs * rhs : lhs['$*'](rhs);
  }
  function $rb_divide(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs / rhs : lhs['$/'](rhs);
  }
  var self = Opal.top, $nesting = [], nil = Opal.nil, $breaker = Opal.breaker, $slice = Opal.slice, $module = Opal.module, $klass = Opal.klass, $hash = Opal.hash, $send = Opal.send, $hash2 = Opal.hash2, $truthy = Opal.truthy;

  Opal.add_stubs(['$attr_reader', '$each_with_object', '$sort', '$keys', '$[]', '$+', '$[]=', '$-', '$nil?', '$!=', '$<<', '$length', '$each_with_index', '$zip', '$==', '$>=', '$*', '$upto', '$-@', '$pack', '$**', '$to_i', '$/', '$log', '$private', '$read', '$io', '$read_signed', '$pos', '$&']);
  return (function($base, $parent_nesting) {
    var $TTFunk, self = $TTFunk = $module($base, 'TTFunk');

    var def = self.$$proto, $nesting = [self].concat($parent_nesting);

    (function($base, $super, $parent_nesting) {
      function $Table(){};
      var self = $Table = $klass($base, $super, 'Table', $Table);

      var def = self.$$proto, $nesting = [self].concat($parent_nesting);

      return (function($base, $super, $parent_nesting) {
        function $Cmap(){};
        var self = $Cmap = $klass($base, $super, 'Cmap', $Cmap);

        var def = self.$$proto, $nesting = [self].concat($parent_nesting);

        return (function($base, $parent_nesting) {
          var $Format04, self = $Format04 = $module($base, 'Format04');

          var def = self.$$proto, $nesting = [self].concat($parent_nesting), TMP_Format04_encode_4, TMP_Format04_$$_5, TMP_Format04_supported$q_6, TMP_Format04_parse_cmap$B_9;

          
          self.$attr_reader("language");
          self.$attr_reader("code_map");
          Opal.defs(self, '$encode', TMP_Format04_encode_4 = function $$encode(charmap) {
            var TMP_1, TMP_2, self = this, end_codes = nil, start_codes = nil, next_id = nil, last = nil, difference = nil, glyph_map = nil, new_map = nil, segcount = nil, deltas = nil, range_offsets = nil, glyph_indices = nil, offset = nil, subtable = nil, search_range = nil, entry_selector = nil, range_shift = nil;

            
            end_codes = [];
            start_codes = [];
            next_id = 0;
            last = (difference = nil);
            glyph_map = $hash(0, 0);
            new_map = $send(charmap.$keys().$sort(), 'each_with_object', [$hash2([], {})], (TMP_1 = function(code, map){var self = TMP_1.$$s || this, $a, old = nil, $writer = nil, delta = nil;
if (code == null) code = nil;if (map == null) map = nil;
            
              old = charmap['$[]'](code);
              ($truthy($a = glyph_map['$[]'](old)) ? $a : (($writer = [old, (next_id = $rb_plus(next_id, 1))]), $send(glyph_map, '[]=', Opal.to_a($writer)), $writer[$rb_minus($writer["length"], 1)]));
              
              $writer = [code, $hash2(["old", "new"], {"old": old, "new": glyph_map['$[]'](old)})];
              $send(map, '[]=', Opal.to_a($writer));
              $writer[$rb_minus($writer["length"], 1)];;
              delta = $rb_minus(glyph_map['$[]'](old), code);
              if ($truthy(($truthy($a = last['$nil?']()) ? $a : delta['$!='](difference)))) {
                
                if ($truthy(last)) {
                  end_codes['$<<'](last)};
                start_codes['$<<'](code);
                difference = delta;};
              last = code;
              return map;}, TMP_1.$$s = self, TMP_1.$$arity = 2, TMP_1));
            if ($truthy(last)) {
              end_codes['$<<'](last)};
            end_codes['$<<'](65535);
            start_codes['$<<'](65535);
            segcount = start_codes.$length();
            deltas = [];
            range_offsets = [];
            glyph_indices = [];
            offset = 0;
            (function(){var $brk = Opal.new_brk(); try {return $send(start_codes.$zip(end_codes), 'each_with_index', [], (TMP_2 = function($a, segment){var self = TMP_2.$$s || this, $a_args, a, b, TMP_3, start_glyph_id = nil;

              if ($a == null) {
                $a = nil;
              }
              $a = Opal.to_ary($a);
              $a_args = Opal.slice.call($a, 0, $a.length);
              a = $a_args.splice(0,1)[0];
              if (a == null) {
                a = nil;
              }
              b = $a_args.splice(0,1)[0];
              if (b == null) {
                b = nil;
              }if (segment == null) segment = nil;
            
              if (a['$=='](65535)) {
                
                deltas['$<<'](0);
                range_offsets['$<<'](0);
                
                Opal.brk(nil, $brk);};
              start_glyph_id = new_map['$[]'](a)['$[]']("new");
              if ($truthy($rb_ge($rb_minus(a, start_glyph_id), 32768))) {
                
                deltas['$<<'](0);
                range_offsets['$<<']($rb_times(2, $rb_minus($rb_plus(glyph_indices.$length(), segcount), segment)));
                $send(a, 'upto', [b], (TMP_3 = function(code){var self = TMP_3.$$s || this;
if (code == null) code = nil;
                return glyph_indices['$<<'](new_map['$[]'](code)['$[]']("new"))}, TMP_3.$$s = self, TMP_3.$$arity = 1, TMP_3));
                } else {
                
                deltas['$<<']($rb_plus(a['$-@'](), start_glyph_id));
                range_offsets['$<<'](0);
              };
              return (offset = $rb_plus(offset, 2));}, TMP_2.$$s = self, TMP_2.$$brk = $brk, TMP_2.$$arity = 2, TMP_2.$$has_top_level_mlhs_arg = true, TMP_2))
            } catch (err) { if (err === $brk) { return err.$v } else { throw err } }})();
            subtable = [4, $rb_plus($rb_plus(16, $rb_times(8, segcount)), $rb_times(2, glyph_indices.$length())), 0].$pack("nnn");
            search_range = $rb_times(2, (2)['$**']($rb_divide(Opal.const_get_relative($nesting, 'Math').$log(segcount), Opal.const_get_relative($nesting, 'Math').$log(2)).$to_i()));
            entry_selector = $rb_divide(Opal.const_get_relative($nesting, 'Math').$log($rb_divide(search_range, 2)), Opal.const_get_relative($nesting, 'Math').$log(2)).$to_i();
            range_shift = $rb_minus($rb_times(2, segcount), search_range);
            subtable['$<<']([$rb_times(segcount, 2), search_range, entry_selector, range_shift].$pack("nnnn"));
            subtable['$<<'](end_codes.$pack("n*"))['$<<']("\u0000\u0000")['$<<'](start_codes.$pack("n*"));
            subtable['$<<'](deltas.$pack("n*"))['$<<'](range_offsets.$pack("n*"));
            subtable['$<<'](glyph_indices.$pack("n*"));
            return $hash2(["charmap", "subtable", "max_glyph_id"], {"charmap": new_map, "subtable": subtable, "max_glyph_id": $rb_plus(next_id, 1)});
          }, TMP_Format04_encode_4.$$arity = 1);
          
          Opal.defn(self, '$[]', TMP_Format04_$$_5 = function(code) {
            var $a, self = this;
            if (self.code_map == null) self.code_map = nil;

            return ($truthy($a = self.code_map['$[]'](code)) ? $a : 0)
          }, TMP_Format04_$$_5.$$arity = 1);
          
          Opal.defn(self, '$supported?', TMP_Format04_supported$q_6 = function() {
            var self = this;

            return true
          }, TMP_Format04_supported$q_6.$$arity = 0);
          self.$private();
          
          Opal.defn(self, '$parse_cmap!', TMP_Format04_parse_cmap$B_9 = function() {
            var $a, $b, TMP_7, self = this, length = nil, segcount_x2 = nil, segcount = nil, end_code = nil, start_code = nil, id_delta = nil, id_range_offset = nil, glyph_ids = nil;
            if (self.offset == null) self.offset = nil;

            
            $b = self.$read(6, "nnn"), $a = Opal.to_ary($b), (length = ($a[0] == null ? nil : $a[0])), (self.language = ($a[1] == null ? nil : $a[1])), (segcount_x2 = ($a[2] == null ? nil : $a[2])), $b;
            segcount = $rb_divide(segcount_x2, 2);
            self.$io().$read(6);
            end_code = self.$read(segcount_x2, "n*");
            self.$io().$read(2);
            start_code = self.$read(segcount_x2, "n*");
            id_delta = self.$read_signed(segcount);
            id_range_offset = self.$read(segcount_x2, "n*");
            glyph_ids = self.$read($rb_plus($rb_minus(length, self.$io().$pos()), self.offset), "n*");
            self.code_map = $hash2([], {});
            return $send(end_code, 'each_with_index', [], (TMP_7 = function(tail, i){var self = TMP_7.$$s || this, TMP_8;
if (tail == null) tail = nil;if (i == null) i = nil;
            return $send(start_code['$[]'](i), 'upto', [tail], (TMP_8 = function(code){var self = TMP_8.$$s || this, $c, glyph_id = nil, index = nil, $writer = nil;
                if (self.code_map == null) self.code_map = nil;
if (code == null) code = nil;
              
                if (id_range_offset['$[]'](i)['$=='](0)) {
                  glyph_id = $rb_plus(code, id_delta['$[]'](i))
                  } else {
                  
                  index = $rb_minus($rb_plus($rb_divide(id_range_offset['$[]'](i), 2), $rb_minus(code, start_code['$[]'](i))), $rb_minus(segcount, i));
                  glyph_id = ($truthy($c = glyph_ids['$[]'](index)) ? $c : 0);
                  if ($truthy(glyph_id['$!='](0))) {
                    glyph_id = $rb_plus(glyph_id, id_delta['$[]'](i))};
                };
                
                $writer = [code, glyph_id['$&'](65535)];
                $send(self.code_map, '[]=', Opal.to_a($writer));
                return $writer[$rb_minus($writer["length"], 1)];;}, TMP_8.$$s = self, TMP_8.$$arity = 1, TMP_8))}, TMP_7.$$s = self, TMP_7.$$arity = 2, TMP_7));
          }, TMP_Format04_parse_cmap$B_9.$$arity = 0);
        })($nesting[0], $nesting)
      })($nesting[0], null, $nesting)
    })($nesting[0], null, $nesting)
  })($nesting[0], $nesting)
};

/* Generated by Opal 0.11.0 */
Opal.modules["ttfunk/table/cmap/format06"] = function(Opal) {
  function $rb_minus(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs - rhs : lhs['$-'](rhs);
  }
  function $rb_plus(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs + rhs : lhs['$+'](rhs);
  }
  function $rb_times(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs * rhs : lhs['$*'](rhs);
  }
  var self = Opal.top, $nesting = [], nil = Opal.nil, $breaker = Opal.breaker, $slice = Opal.slice, $module = Opal.module, $klass = Opal.klass, $hash = Opal.hash, $send = Opal.send, $hash2 = Opal.hash2, $truthy = Opal.truthy;

  Opal.add_stubs(['$attr_reader', '$sort', '$keys', '$first', '$last', '$-', '$+', '$new', '$each_with_object', '$[]', '$[]=', '$pack', '$*', '$private', '$read', '$each', '$&']);
  return (function($base, $parent_nesting) {
    var $TTFunk, self = $TTFunk = $module($base, 'TTFunk');

    var def = self.$$proto, $nesting = [self].concat($parent_nesting);

    (function($base, $super, $parent_nesting) {
      function $Table(){};
      var self = $Table = $klass($base, $super, 'Table', $Table);

      var def = self.$$proto, $nesting = [self].concat($parent_nesting);

      return (function($base, $super, $parent_nesting) {
        function $Cmap(){};
        var self = $Cmap = $klass($base, $super, 'Cmap', $Cmap);

        var def = self.$$proto, $nesting = [self].concat($parent_nesting);

        return (function($base, $parent_nesting) {
          var $Format06, self = $Format06 = $module($base, 'Format06');

          var def = self.$$proto, $nesting = [self].concat($parent_nesting), TMP_Format06_encode_2, TMP_Format06_$$_3, TMP_Format06_supported$q_4, TMP_Format06_parse_cmap$B_6;

          
          self.$attr_reader("language");
          self.$attr_reader("code_map");
          Opal.defs(self, '$encode', TMP_Format06_encode_2 = function $$encode(charmap) {
            var TMP_1, self = this, next_id = nil, glyph_map = nil, sorted_chars = nil, low_char = nil, high_char = nil, entry_count = nil, glyph_indexes = nil, new_map = nil, subtable = nil;

            
            next_id = 0;
            glyph_map = $hash(0, 0);
            sorted_chars = charmap.$keys().$sort();
            low_char = sorted_chars.$first();
            high_char = sorted_chars.$last();
            entry_count = $rb_minus($rb_plus(1, high_char), low_char);
            glyph_indexes = Opal.const_get_relative($nesting, 'Array').$new(entry_count, 0);
            new_map = $send(charmap.$keys().$sort(), 'each_with_object', [$hash2([], {})], (TMP_1 = function(code, map){var self = TMP_1.$$s || this, $a, $writer = nil;
if (code == null) code = nil;if (map == null) map = nil;
            
              ($truthy($a = glyph_map['$[]'](charmap['$[]'](code))) ? $a : (($writer = [charmap['$[]'](code), (next_id = $rb_plus(next_id, 1))]), $send(glyph_map, '[]=', Opal.to_a($writer)), $writer[$rb_minus($writer["length"], 1)]));
              
              $writer = [code, $hash2(["old", "new"], {"old": charmap['$[]'](code), "new": glyph_map['$[]'](charmap['$[]'](code))})];
              $send(map, '[]=', Opal.to_a($writer));
              $writer[$rb_minus($writer["length"], 1)];;
              
              $writer = [$rb_minus(code, low_char), glyph_map['$[]'](charmap['$[]'](code))];
              $send(glyph_indexes, '[]=', Opal.to_a($writer));
              return $writer[$rb_minus($writer["length"], 1)];;}, TMP_1.$$s = self, TMP_1.$$arity = 2, TMP_1));
            subtable = [6, $rb_plus(10, $rb_times(entry_count, 2)), 0, low_char, entry_count].concat(Opal.to_a(glyph_indexes)).$pack("n*");
            return $hash2(["charmap", "subtable", "max_glyph_id"], {"charmap": new_map, "subtable": subtable, "max_glyph_id": $rb_plus(next_id, 1)});
          }, TMP_Format06_encode_2.$$arity = 1);
          
          Opal.defn(self, '$[]', TMP_Format06_$$_3 = function(code) {
            var $a, self = this;
            if (self.code_map == null) self.code_map = nil;

            return ($truthy($a = self.code_map['$[]'](code)) ? $a : 0)
          }, TMP_Format06_$$_3.$$arity = 1);
          
          Opal.defn(self, '$supported?', TMP_Format06_supported$q_4 = function() {
            var self = this;

            return true
          }, TMP_Format06_supported$q_4.$$arity = 0);
          self.$private();
          
          Opal.defn(self, '$parse_cmap!', TMP_Format06_parse_cmap$B_6 = function() {
            var $a, $b, TMP_5, self = this, firstcode = nil, entrycount = nil;

            
            $b = self.$read(8, "x2nnn"), $a = Opal.to_ary($b), (self.language = ($a[0] == null ? nil : $a[0])), (firstcode = ($a[1] == null ? nil : $a[1])), (entrycount = ($a[2] == null ? nil : $a[2])), $b;
            self.code_map = $hash2([], {});
            return $send(Opal.Range.$new(firstcode,$rb_plus(firstcode, entrycount), true), 'each', [], (TMP_5 = function(code){var self = TMP_5.$$s || this, $writer = nil;
              if (self.code_map == null) self.code_map = nil;
if (code == null) code = nil;
            
              $writer = [code, self.$read(2, "n").$first()['$&'](65535)];
              $send(self.code_map, '[]=', Opal.to_a($writer));
              return $writer[$rb_minus($writer["length"], 1)];}, TMP_5.$$s = self, TMP_5.$$arity = 1, TMP_5));
          }, TMP_Format06_parse_cmap$B_6.$$arity = 0);
        })($nesting[0], $nesting)
      })($nesting[0], null, $nesting)
    })($nesting[0], null, $nesting)
  })($nesting[0], $nesting)
};

/* Generated by Opal 0.11.0 */
Opal.modules["ttfunk/table/cmap/format10"] = function(Opal) {
  function $rb_minus(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs - rhs : lhs['$-'](rhs);
  }
  function $rb_plus(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs + rhs : lhs['$+'](rhs);
  }
  function $rb_times(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs * rhs : lhs['$*'](rhs);
  }
  var self = Opal.top, $nesting = [], nil = Opal.nil, $breaker = Opal.breaker, $slice = Opal.slice, $module = Opal.module, $klass = Opal.klass, $hash = Opal.hash, $send = Opal.send, $hash2 = Opal.hash2, $truthy = Opal.truthy;

  Opal.add_stubs(['$attr_reader', '$sort', '$keys', '$first', '$last', '$-', '$+', '$new', '$each_with_object', '$[]', '$[]=', '$pack', '$*', '$private', '$read', '$!=', '$raise', '$each', '$&']);
  return (function($base, $parent_nesting) {
    var $TTFunk, self = $TTFunk = $module($base, 'TTFunk');

    var def = self.$$proto, $nesting = [self].concat($parent_nesting);

    (function($base, $super, $parent_nesting) {
      function $Table(){};
      var self = $Table = $klass($base, $super, 'Table', $Table);

      var def = self.$$proto, $nesting = [self].concat($parent_nesting);

      return (function($base, $super, $parent_nesting) {
        function $Cmap(){};
        var self = $Cmap = $klass($base, $super, 'Cmap', $Cmap);

        var def = self.$$proto, $nesting = [self].concat($parent_nesting);

        return (function($base, $parent_nesting) {
          var $Format10, self = $Format10 = $module($base, 'Format10');

          var def = self.$$proto, $nesting = [self].concat($parent_nesting), TMP_Format10_encode_2, TMP_Format10_$$_3, TMP_Format10_supported$q_4, TMP_Format10_parse_cmap$B_6;

          
          self.$attr_reader("language");
          self.$attr_reader("code_map");
          Opal.defs(self, '$encode', TMP_Format10_encode_2 = function $$encode(charmap) {
            var TMP_1, self = this, next_id = nil, glyph_map = nil, sorted_chars = nil, low_char = nil, high_char = nil, entry_count = nil, glyph_indexes = nil, new_map = nil, subtable = nil;

            
            next_id = 0;
            glyph_map = $hash(0, 0);
            sorted_chars = charmap.$keys().$sort();
            low_char = sorted_chars.$first();
            high_char = sorted_chars.$last();
            entry_count = $rb_minus($rb_plus(1, high_char), low_char);
            glyph_indexes = Opal.const_get_relative($nesting, 'Array').$new(entry_count, 0);
            new_map = $send(charmap.$keys().$sort(), 'each_with_object', [$hash2([], {})], (TMP_1 = function(code, map){var self = TMP_1.$$s || this, $a, $writer = nil;
if (code == null) code = nil;if (map == null) map = nil;
            
              ($truthy($a = glyph_map['$[]'](charmap['$[]'](code))) ? $a : (($writer = [charmap['$[]'](code), (next_id = $rb_plus(next_id, 1))]), $send(glyph_map, '[]=', Opal.to_a($writer)), $writer[$rb_minus($writer["length"], 1)]));
              
              $writer = [code, $hash2(["old", "new"], {"old": charmap['$[]'](code), "new": glyph_map['$[]'](charmap['$[]'](code))})];
              $send(map, '[]=', Opal.to_a($writer));
              $writer[$rb_minus($writer["length"], 1)];;
              
              $writer = [$rb_minus(code, low_char), glyph_map['$[]'](charmap['$[]'](code))];
              $send(glyph_indexes, '[]=', Opal.to_a($writer));
              return $writer[$rb_minus($writer["length"], 1)];;}, TMP_1.$$s = self, TMP_1.$$arity = 2, TMP_1));
            subtable = [10, 0, $rb_plus(20, $rb_times(entry_count, 4)), 0, low_char, entry_count].concat(Opal.to_a(glyph_indexes)).$pack("nnN*");
            return $hash2(["charmap", "subtable", "max_glyph_id"], {"charmap": new_map, "subtable": subtable, "max_glyph_id": $rb_plus(next_id, 1)});
          }, TMP_Format10_encode_2.$$arity = 1);
          
          Opal.defn(self, '$[]', TMP_Format10_$$_3 = function(code) {
            var $a, self = this;
            if (self.code_map == null) self.code_map = nil;

            return ($truthy($a = self.code_map['$[]'](code)) ? $a : 0)
          }, TMP_Format10_$$_3.$$arity = 1);
          
          Opal.defn(self, '$supported?', TMP_Format10_supported$q_4 = function() {
            var self = this;

            return true
          }, TMP_Format10_supported$q_4.$$arity = 0);
          self.$private();
          
          Opal.defn(self, '$parse_cmap!', TMP_Format10_parse_cmap$B_6 = function() {
            var $a, $b, TMP_5, self = this, fractional_version = nil, firstcode = nil, entrycount = nil;

            
            $b = self.$read(18, "nx4NNN"), $a = Opal.to_ary($b), (fractional_version = ($a[0] == null ? nil : $a[0])), (self.language = ($a[1] == null ? nil : $a[1])), (firstcode = ($a[2] == null ? nil : $a[2])), (entrycount = ($a[3] == null ? nil : $a[3])), $b;
            if ($truthy(fractional_version['$!='](0))) {
              self.$raise(Opal.const_get_relative($nesting, 'NotImplementedError'), "" + "cmap version 10." + (fractional_version) + " is not supported")};
            self.code_map = $hash2([], {});
            return $send(Opal.Range.$new(firstcode,$rb_plus(firstcode, entrycount), true), 'each', [], (TMP_5 = function(code){var self = TMP_5.$$s || this, $writer = nil;
              if (self.code_map == null) self.code_map = nil;
if (code == null) code = nil;
            
              $writer = [code, self.$read(2, "n").$first()['$&'](65535)];
              $send(self.code_map, '[]=', Opal.to_a($writer));
              return $writer[$rb_minus($writer["length"], 1)];}, TMP_5.$$s = self, TMP_5.$$arity = 1, TMP_5));
          }, TMP_Format10_parse_cmap$B_6.$$arity = 0);
        })($nesting[0], $nesting)
      })($nesting[0], null, $nesting)
    })($nesting[0], null, $nesting)
  })($nesting[0], $nesting)
};

/* Generated by Opal 0.11.0 */
Opal.modules["ttfunk/table/cmap/format12"] = function(Opal) {
  function $rb_plus(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs + rhs : lhs['$+'](rhs);
  }
  function $rb_minus(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs - rhs : lhs['$-'](rhs);
  }
  function $rb_gt(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs > rhs : lhs['$>'](rhs);
  }
  function $rb_times(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs * rhs : lhs['$*'](rhs);
  }
  var self = Opal.top, $nesting = [], nil = Opal.nil, $breaker = Opal.breaker, $slice = Opal.slice, $module = Opal.module, $klass = Opal.klass, $hash = Opal.hash, $send = Opal.send, $hash2 = Opal.hash2, $truthy = Opal.truthy;

  Opal.add_stubs(['$attr_reader', '$each_with_object', '$sort', '$keys', '$[]', '$+', '$[]=', '$-', '$>', '$<<', '$push', '$pop', '$pack', '$*', '$size', '$each_with_index', '$private', '$read', '$!=', '$raise', '$each']);
  return (function($base, $parent_nesting) {
    var $TTFunk, self = $TTFunk = $module($base, 'TTFunk');

    var def = self.$$proto, $nesting = [self].concat($parent_nesting);

    (function($base, $super, $parent_nesting) {
      function $Table(){};
      var self = $Table = $klass($base, $super, 'Table', $Table);

      var def = self.$$proto, $nesting = [self].concat($parent_nesting);

      return (function($base, $super, $parent_nesting) {
        function $Cmap(){};
        var self = $Cmap = $klass($base, $super, 'Cmap', $Cmap);

        var def = self.$$proto, $nesting = [self].concat($parent_nesting);

        return (function($base, $parent_nesting) {
          var $Format12, self = $Format12 = $module($base, 'Format12');

          var def = self.$$proto, $nesting = [self].concat($parent_nesting), TMP_Format12_encode_3, TMP_Format12_$$_4, TMP_Format12_supported$q_5, TMP_Format12_parse_cmap$B_8;

          
          self.$attr_reader("language");
          self.$attr_reader("code_map");
          Opal.defs(self, '$encode', TMP_Format12_encode_3 = function $$encode(charmap) {
            var TMP_1, TMP_2, self = this, next_id = nil, glyph_map = nil, range_firstglyphs = nil, range_firstcodes = nil, range_lengths = nil, last_glyph = nil, last_code = nil, new_map = nil, subtable = nil;

            
            next_id = 0;
            glyph_map = $hash(0, 0);
            range_firstglyphs = [];
            range_firstcodes = [];
            range_lengths = [];
            last_glyph = (last_code = -999);
            new_map = $send(charmap.$keys().$sort(), 'each_with_object', [$hash2([], {})], (TMP_1 = function(code, map){var self = TMP_1.$$s || this, $a, $writer = nil;
if (code == null) code = nil;if (map == null) map = nil;
            
              ($truthy($a = glyph_map['$[]'](charmap['$[]'](code))) ? $a : (($writer = [charmap['$[]'](code), (next_id = $rb_plus(next_id, 1))]), $send(glyph_map, '[]=', Opal.to_a($writer)), $writer[$rb_minus($writer["length"], 1)]));
              
              $writer = [code, $hash2(["old", "new"], {"old": charmap['$[]'](code), "new": glyph_map['$[]'](charmap['$[]'](code))})];
              $send(map, '[]=', Opal.to_a($writer));
              $writer[$rb_minus($writer["length"], 1)];;
              if ($truthy(($truthy($a = $rb_gt(code, $rb_plus(last_code, 1))) ? $a : $rb_gt(glyph_map['$[]'](charmap['$[]'](code)), $rb_plus(last_glyph, 1))))) {
                
                range_firstcodes['$<<'](code);
                range_firstglyphs['$<<'](glyph_map['$[]'](charmap['$[]'](code)));
                range_lengths['$<<'](1);
                } else {
                $rb_plus(range_lengths.$push(range_lengths.$pop()), 1)
              };
              last_code = code;
              return (last_glyph = glyph_map['$[]'](charmap['$[]'](code)));}, TMP_1.$$s = self, TMP_1.$$arity = 2, TMP_1));
            subtable = [12, 0, $rb_plus(16, $rb_times(12, range_lengths.$size())), 0, range_lengths.$size()].$pack("nnNNN");
            $send(range_lengths, 'each_with_index', [], (TMP_2 = function(length, i){var self = TMP_2.$$s || this, firstglyph = nil, firstcode = nil;
if (length == null) length = nil;if (i == null) i = nil;
            
              firstglyph = range_firstglyphs['$[]'](i);
              firstcode = range_firstcodes['$[]'](i);
              return subtable['$<<']([firstcode, $rb_minus($rb_plus(firstcode, length), 1), firstglyph].$pack("NNN"));}, TMP_2.$$s = self, TMP_2.$$arity = 2, TMP_2));
            return $hash2(["charmap", "subtable", "max_glyph_id"], {"charmap": new_map, "subtable": subtable, "max_glyph_id": $rb_plus(next_id, 1)});
          }, TMP_Format12_encode_3.$$arity = 1);
          
          Opal.defn(self, '$[]', TMP_Format12_$$_4 = function(code) {
            var $a, self = this;
            if (self.code_map == null) self.code_map = nil;

            return ($truthy($a = self.code_map['$[]'](code)) ? $a : 0)
          }, TMP_Format12_$$_4.$$arity = 1);
          
          Opal.defn(self, '$supported?', TMP_Format12_supported$q_5 = function() {
            var self = this;

            return true
          }, TMP_Format12_supported$q_5.$$arity = 0);
          self.$private();
          
          Opal.defn(self, '$parse_cmap!', TMP_Format12_parse_cmap$B_8 = function() {
            var $a, $b, TMP_6, self = this, fractional_version = nil, groupcount = nil;

            
            $b = self.$read(14, "nx4NN"), $a = Opal.to_ary($b), (fractional_version = ($a[0] == null ? nil : $a[0])), (self.language = ($a[1] == null ? nil : $a[1])), (groupcount = ($a[2] == null ? nil : $a[2])), $b;
            if ($truthy(fractional_version['$!='](0))) {
              self.$raise(Opal.const_get_relative($nesting, 'NotImplementedError'), "" + "cmap version 12." + (fractional_version) + " is not supported")};
            self.code_map = $hash2([], {});
            return $send(Opal.Range.$new(1, groupcount, false), 'each', [], (TMP_6 = function(){var self = TMP_6.$$s || this, $c, $d, TMP_7, startchar = nil, endchar = nil, startglyph = nil;

            
              $d = self.$read(12, "NNN"), $c = Opal.to_ary($d), (startchar = ($c[0] == null ? nil : $c[0])), (endchar = ($c[1] == null ? nil : $c[1])), (startglyph = ($c[2] == null ? nil : $c[2])), $d;
              return $send(Opal.Range.$new(0, $rb_minus(endchar, startchar), false), 'each', [], (TMP_7 = function(offset){var self = TMP_7.$$s || this, $writer = nil;
                if (self.code_map == null) self.code_map = nil;
if (offset == null) offset = nil;
              
                $writer = [$rb_plus(startchar, offset), $rb_plus(startglyph, offset)];
                $send(self.code_map, '[]=', Opal.to_a($writer));
                return $writer[$rb_minus($writer["length"], 1)];}, TMP_7.$$s = self, TMP_7.$$arity = 1, TMP_7));}, TMP_6.$$s = self, TMP_6.$$arity = 0, TMP_6));
          }, TMP_Format12_parse_cmap$B_8.$$arity = 0);
        })($nesting[0], $nesting)
      })($nesting[0], null, $nesting)
    })($nesting[0], null, $nesting)
  })($nesting[0], $nesting)
};

/* Generated by Opal 0.11.0 */
Opal.modules["ttfunk/table/cmap/subtable"] = function(Opal) {
  function $rb_minus(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs - rhs : lhs['$-'](rhs);
  }
  function $rb_plus(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs + rhs : lhs['$+'](rhs);
  }
  var self = Opal.top, $nesting = [], nil = Opal.nil, $breaker = Opal.breaker, $slice = Opal.slice, $module = Opal.module, $klass = Opal.klass, $hash2 = Opal.hash2, $send = Opal.send, $truthy = Opal.truthy;

  Opal.add_stubs(['$include', '$attr_reader', '$freeze', '$===', '$encode', '$raise', '$inspect', '$[]', '$pack', '$[]=', '$-', '$read', '$+', '$parse_from', '$first', '$extend', '$parse_cmap!', '$==', '$platform_id', '$encoding_id', '$!=', '$format', '$private']);
  
  self.$require("ttfunk/table/cmap/subtable"+ '/../' + "../../reader");
  (function($base, $parent_nesting) {
    var $TTFunk, self = $TTFunk = $module($base, 'TTFunk');

    var def = self.$$proto, $nesting = [self].concat($parent_nesting);

    (function($base, $super, $parent_nesting) {
      function $Table(){};
      var self = $Table = $klass($base, $super, 'Table', $Table);

      var def = self.$$proto, $nesting = [self].concat($parent_nesting);

      return (function($base, $super, $parent_nesting) {
        function $Cmap(){};
        var self = $Cmap = $klass($base, $super, 'Cmap', $Cmap);

        var def = self.$$proto, $nesting = [self].concat($parent_nesting);

        return (function($base, $super, $parent_nesting) {
          function $Subtable(){};
          var self = $Subtable = $klass($base, $super, 'Subtable', $Subtable);

          var def = self.$$proto, $nesting = [self].concat($parent_nesting), TMP_Subtable_encode_1, TMP_Subtable_initialize_3, TMP_Subtable_unicode$q_4, TMP_Subtable_supported$q_5, TMP_Subtable_$$_6, TMP_Subtable_parse_cmap$B_7;

          def.offset = def.format = nil;
          
          self.$include(Opal.const_get_relative($nesting, 'Reader'));
          self.$attr_reader("platform_id");
          self.$attr_reader("encoding_id");
          self.$attr_reader("format");
          Opal.const_set($nesting[0], 'ENCODING_MAPPINGS', $hash2(["mac_roman", "unicode", "unicode_ucs4"], {"mac_roman": $hash2(["platform_id", "encoding_id"], {"platform_id": 1, "encoding_id": 0}).$freeze(), "unicode": $hash2(["platform_id", "encoding_id"], {"platform_id": 3, "encoding_id": 1}).$freeze(), "unicode_ucs4": $hash2(["platform_id", "encoding_id"], {"platform_id": 3, "encoding_id": 10}).$freeze()}).$freeze());
          Opal.defs(self, '$encode', TMP_Subtable_encode_1 = function $$encode(charmap, encoding) {
            var self = this, $case = nil, result = nil, mapping = nil, $writer = nil;

            
            $case = encoding;
            if ("mac_roman"['$===']($case)) {result = Opal.const_get_relative($nesting, 'Format00').$encode(charmap)}
            else if ("unicode"['$===']($case)) {result = Opal.const_get_relative($nesting, 'Format04').$encode(charmap)}
            else if ("unicode_ucs4"['$===']($case)) {result = Opal.const_get_relative($nesting, 'Format12').$encode(charmap)}
            else {self.$raise(Opal.const_get_relative($nesting, 'NotImplementedError'), "" + "encoding " + (encoding.$inspect()) + " is not supported")};
            mapping = Opal.const_get_relative($nesting, 'ENCODING_MAPPINGS')['$[]'](encoding);
            
            $writer = ["subtable", [mapping['$[]']("platform_id"), mapping['$[]']("encoding_id"), 12, result['$[]']("subtable")].$pack("nnNA*")];
            $send(result, '[]=', Opal.to_a($writer));
            $writer[$rb_minus($writer["length"], 1)];;
            return result;
          }, TMP_Subtable_encode_1.$$arity = 2);
          
          Opal.defn(self, '$initialize', TMP_Subtable_initialize_3 = function $$initialize(file, table_start) {
            var $a, $b, TMP_2, self = this;

            
            self.file = file;
            $b = self.$read(8, "nnN"), $a = Opal.to_ary($b), (self.platform_id = ($a[0] == null ? nil : $a[0])), (self.encoding_id = ($a[1] == null ? nil : $a[1])), (self.offset = ($a[2] == null ? nil : $a[2])), $b;
            self.offset = $rb_plus(self.offset, table_start);
            return $send(self, 'parse_from', [self.offset], (TMP_2 = function(){var self = TMP_2.$$s || this, $case = nil;
              if (self.format == null) self.format = nil;

            
              self.format = self.$read(2, "n").$first();
              $case = self.format;
              if ((0)['$===']($case)) {self.$extend(Opal.const_get_qualified(Opal.const_get_qualified(Opal.const_get_qualified(Opal.const_get_relative($nesting, 'TTFunk'), 'Table'), 'Cmap'), 'Format00'))}
              else if ((4)['$===']($case)) {self.$extend(Opal.const_get_qualified(Opal.const_get_qualified(Opal.const_get_qualified(Opal.const_get_relative($nesting, 'TTFunk'), 'Table'), 'Cmap'), 'Format04'))}
              else if ((6)['$===']($case)) {self.$extend(Opal.const_get_qualified(Opal.const_get_qualified(Opal.const_get_qualified(Opal.const_get_relative($nesting, 'TTFunk'), 'Table'), 'Cmap'), 'Format06'))}
              else if ((10)['$===']($case)) {self.$extend(Opal.const_get_qualified(Opal.const_get_qualified(Opal.const_get_qualified(Opal.const_get_relative($nesting, 'TTFunk'), 'Table'), 'Cmap'), 'Format10'))}
              else if ((12)['$===']($case)) {self.$extend(Opal.const_get_qualified(Opal.const_get_qualified(Opal.const_get_qualified(Opal.const_get_relative($nesting, 'TTFunk'), 'Table'), 'Cmap'), 'Format12'))};
              return self['$parse_cmap!']();}, TMP_2.$$s = self, TMP_2.$$arity = 0, TMP_2));
          }, TMP_Subtable_initialize_3.$$arity = 2);
          
          Opal.defn(self, '$unicode?', TMP_Subtable_unicode$q_4 = function() {
            var $a, $b, $c, $d, self = this;

            return ($truthy($a = ($truthy($b = (($c = self.$platform_id()['$=='](3)) ? ($truthy($d = self.$encoding_id()['$=='](1)) ? $d : self.$encoding_id()['$=='](10)) : self.$platform_id()['$=='](3))) ? self.$format()['$!='](0) : $b)) ? $a : (($b = self.$platform_id()['$=='](0)) ? self.$format()['$!='](0) : self.$platform_id()['$=='](0)))
          }, TMP_Subtable_unicode$q_4.$$arity = 0);
          
          Opal.defn(self, '$supported?', TMP_Subtable_supported$q_5 = function() {
            var self = this;

            return false
          }, TMP_Subtable_supported$q_5.$$arity = 0);
          
          Opal.defn(self, '$[]', TMP_Subtable_$$_6 = function(_code) {
            var self = this;

            return self.$raise(Opal.const_get_relative($nesting, 'NotImplementedError'), "" + "cmap format " + (self.format) + " is not supported")
          }, TMP_Subtable_$$_6.$$arity = 1);
          self.$private();
          return (Opal.defn(self, '$parse_cmap!', TMP_Subtable_parse_cmap$B_7 = function() {
            var self = this;

            return nil
          }, TMP_Subtable_parse_cmap$B_7.$$arity = 0), nil) && 'parse_cmap!';
        })($nesting[0], null, $nesting)
      })($nesting[0], null, $nesting)
    })($nesting[0], null, $nesting)
  })($nesting[0], $nesting);
  self.$require("ttfunk/table/cmap/subtable"+ '/../' + "format00");
  self.$require("ttfunk/table/cmap/subtable"+ '/../' + "format04");
  self.$require("ttfunk/table/cmap/subtable"+ '/../' + "format06");
  self.$require("ttfunk/table/cmap/subtable"+ '/../' + "format10");
  return self.$require("ttfunk/table/cmap/subtable"+ '/../' + "format12");
};

/* Generated by Opal 0.11.0 */
Opal.modules["ttfunk/table/cmap"] = function(Opal) {
  function $rb_minus(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs - rhs : lhs['$-'](rhs);
  }
  var self = Opal.top, $nesting = [], nil = Opal.nil, $breaker = Opal.breaker, $slice = Opal.slice, $module = Opal.module, $klass = Opal.klass, $send = Opal.send, $truthy = Opal.truthy;

  Opal.add_stubs(['$attr_reader', '$encode', '$pack', '$delete', '$[]=', '$-', '$sort', '$select', '$unicode?', '$supported?', '$<=>', '$format', '$private', '$read', '$times', '$<<', '$new', '$file', '$offset']);
  
  (function($base, $parent_nesting) {
    var $TTFunk, self = $TTFunk = $module($base, 'TTFunk');

    var def = self.$$proto, $nesting = [self].concat($parent_nesting);

    (function($base, $super, $parent_nesting) {
      function $Table(){};
      var self = $Table = $klass($base, $super, 'Table', $Table);

      var def = self.$$proto, $nesting = [self].concat($parent_nesting);

      return (function($base, $super, $parent_nesting) {
        function $Cmap(){};
        var self = $Cmap = $klass($base, $super, 'Cmap', $Cmap);

        var def = self.$$proto, $nesting = [self].concat($parent_nesting), TMP_Cmap_encode_1, TMP_Cmap_unicode_4, TMP_Cmap_parse$B_6;

        def.unicode = def.tables = nil;
        
        self.$attr_reader("version");
        self.$attr_reader("tables");
        Opal.defs(self, '$encode', TMP_Cmap_encode_1 = function $$encode(charmap, encoding) {
          var self = this, result = nil, $writer = nil;

          
          result = Opal.const_get_qualified(Opal.const_get_relative($nesting, 'Cmap'), 'Subtable').$encode(charmap, encoding);
          
          $writer = ["table", [0, 1, result.$delete("subtable")].$pack("nnA*")];
          $send(result, '[]=', Opal.to_a($writer));
          $writer[$rb_minus($writer["length"], 1)];;
          return result;
        }, TMP_Cmap_encode_1.$$arity = 2);
        
        Opal.defn(self, '$unicode', TMP_Cmap_unicode_4 = function $$unicode() {
          var $a, TMP_2, TMP_3, self = this;

          return (self.unicode = ($truthy($a = self.unicode) ? $a : $send($send(self.tables, 'select', [], (TMP_2 = function(table){var self = TMP_2.$$s || this, $b;
if (table == null) table = nil;
          return ($truthy($b = table['$unicode?']()) ? table['$supported?']() : $b)}, TMP_2.$$s = self, TMP_2.$$arity = 1, TMP_2)), 'sort', [], (TMP_3 = function(a, b){var self = TMP_3.$$s || this;
if (a == null) a = nil;if (b == null) b = nil;
          return b.$format()['$<=>'](a.$format())}, TMP_3.$$s = self, TMP_3.$$arity = 2, TMP_3))))
        }, TMP_Cmap_unicode_4.$$arity = 0);
        self.$private();
        return (Opal.defn(self, '$parse!', TMP_Cmap_parse$B_6 = function() {
          var $a, $b, TMP_5, self = this, table_count = nil;

          
          $b = self.$read(4, "nn"), $a = Opal.to_ary($b), (self.version = ($a[0] == null ? nil : $a[0])), (table_count = ($a[1] == null ? nil : $a[1])), $b;
          self.tables = [];
          return $send(table_count, 'times', [], (TMP_5 = function(){var self = TMP_5.$$s || this;
            if (self.tables == null) self.tables = nil;

          return self.tables['$<<'](Opal.const_get_qualified(Opal.const_get_relative($nesting, 'Cmap'), 'Subtable').$new(self.$file(), self.$offset()))}, TMP_5.$$s = self, TMP_5.$$arity = 0, TMP_5));
        }, TMP_Cmap_parse$B_6.$$arity = 0), nil) && 'parse!';
      })($nesting[0], Opal.const_get_relative($nesting, 'Table'), $nesting)
    })($nesting[0], null, $nesting)
  })($nesting[0], $nesting);
  return self.$require("ttfunk/table/cmap"+ '/../' + "cmap/subtable");
};

/* Generated by Opal 0.11.0 */
Opal.modules["ttfunk/table"] = function(Opal) {
  var self = Opal.top, $nesting = [], nil = Opal.nil, $breaker = Opal.breaker, $slice = Opal.slice, $module = Opal.module, $klass = Opal.klass, $truthy = Opal.truthy, $send = Opal.send;

  Opal.add_stubs(['$include', '$attr_reader', '$directory_info', '$tag', '$[]', '$parse_from', '$parse!', '$!', '$nil?', '$exists?', '$offset', '$read', '$io', '$length', '$downcase', '$last', '$split', '$name', '$class', '$private']);
  
  self.$require("ttfunk/table"+ '/../' + "reader");
  return (function($base, $parent_nesting) {
    var $TTFunk, self = $TTFunk = $module($base, 'TTFunk');

    var def = self.$$proto, $nesting = [self].concat($parent_nesting);

    (function($base, $super, $parent_nesting) {
      function $Table(){};
      var self = $Table = $klass($base, $super, 'Table', $Table);

      var def = self.$$proto, $nesting = [self].concat($parent_nesting), TMP_Table_initialize_2, TMP_Table_exists$q_3, TMP_Table_raw_5, TMP_Table_tag_6, TMP_Table_parse$B_7;

      def.offset = nil;
      
      self.$include(Opal.const_get_relative($nesting, 'Reader'));
      self.$attr_reader("file");
      self.$attr_reader("offset");
      self.$attr_reader("length");
      
      Opal.defn(self, '$initialize', TMP_Table_initialize_2 = function $$initialize(file) {
        var TMP_1, self = this, info = nil;

        
        self.file = file;
        info = file.$directory_info(self.$tag());
        if ($truthy(info)) {
          
          self.offset = info['$[]']("offset");
          self.length = info['$[]']("length");
          return $send(self, 'parse_from', [self.offset], (TMP_1 = function(){var self = TMP_1.$$s || this;

          return self['$parse!']()}, TMP_1.$$s = self, TMP_1.$$arity = 0, TMP_1));
          } else {
          return nil
        };
      }, TMP_Table_initialize_2.$$arity = 1);
      
      Opal.defn(self, '$exists?', TMP_Table_exists$q_3 = function() {
        var self = this;

        return self.offset['$nil?']()['$!']()
      }, TMP_Table_exists$q_3.$$arity = 0);
      
      Opal.defn(self, '$raw', TMP_Table_raw_5 = function $$raw() {
        var TMP_4, self = this;

        if ($truthy(self['$exists?']())) {
          return $send(self, 'parse_from', [self.$offset()], (TMP_4 = function(){var self = TMP_4.$$s || this;

          return self.$io().$read(self.$length())}, TMP_4.$$s = self, TMP_4.$$arity = 0, TMP_4))
          } else {
          return nil
        }
      }, TMP_Table_raw_5.$$arity = 0);
      
      Opal.defn(self, '$tag', TMP_Table_tag_6 = function $$tag() {
        var self = this;

        return self.$class().$name().$split(/::/).$last().$downcase()
      }, TMP_Table_tag_6.$$arity = 0);
      self.$private();
      return (Opal.defn(self, '$parse!', TMP_Table_parse$B_7 = function() {
        var self = this;

        return nil
      }, TMP_Table_parse$B_7.$$arity = 0), nil) && 'parse!';
    })($nesting[0], null, $nesting)
  })($nesting[0], $nesting);
};

/* Generated by Opal 0.11.0 */
Opal.modules["ttfunk/table/glyf/compound"] = function(Opal) {
  function $rb_plus(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs + rhs : lhs['$+'](rhs);
  }
  function $rb_minus(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs - rhs : lhs['$-'](rhs);
  }
  var self = Opal.top, $nesting = [], nil = Opal.nil, $breaker = Opal.breaker, $slice = Opal.slice, $module = Opal.module, $klass = Opal.klass, $send = Opal.send, $truthy = Opal.truthy;

  Opal.add_stubs(['$include', '$attr_reader', '$new', '$loop', '$unpack', '$[]', '$<<', '$+', '$!=', '$&', '$dup', '$map', '$glyph_ids', '$each', '$zip', '$pack', '$[]=', '$-']);
  
  self.$require("ttfunk/table/glyf/compound"+ '/../' + "../../reader");
  return (function($base, $parent_nesting) {
    var $TTFunk, self = $TTFunk = $module($base, 'TTFunk');

    var def = self.$$proto, $nesting = [self].concat($parent_nesting);

    (function($base, $super, $parent_nesting) {
      function $Table(){};
      var self = $Table = $klass($base, $super, 'Table', $Table);

      var def = self.$$proto, $nesting = [self].concat($parent_nesting);

      return (function($base, $super, $parent_nesting) {
        function $Glyf(){};
        var self = $Glyf = $klass($base, $super, 'Glyf', $Glyf);

        var def = self.$$proto, $nesting = [self].concat($parent_nesting);

        return (function($base, $super, $parent_nesting) {
          function $Compound(){};
          var self = $Compound = $klass($base, $super, 'Compound', $Compound);

          var def = self.$$proto, $nesting = [self].concat($parent_nesting), TMP_Compound_initialize_2, TMP_Compound_compound$q_3, TMP_Compound_recode_6;

          def.raw = def.glyph_id_offsets = nil;
          
          self.$include(Opal.const_get_relative($nesting, 'Reader'));
          Opal.const_set($nesting[0], 'ARG_1_AND_2_ARE_WORDS', 1);
          Opal.const_set($nesting[0], 'WE_HAVE_A_SCALE', 8);
          Opal.const_set($nesting[0], 'MORE_COMPONENTS', 32);
          Opal.const_set($nesting[0], 'WE_HAVE_AN_X_AND_Y_SCALE', 64);
          Opal.const_set($nesting[0], 'WE_HAVE_A_TWO_BY_TWO', 128);
          Opal.const_set($nesting[0], 'WE_HAVE_INSTRUCTIONS', 256);
          self.$attr_reader("raw");
          self.$attr_reader("x_min", "y_min", "x_max", "y_max");
          self.$attr_reader("glyph_ids");
          Opal.const_set($nesting[0], 'Component', Opal.const_get_relative($nesting, 'Struct').$new("flags", "glyph_index", "arg1", "arg2", "transform"));
          
          Opal.defn(self, '$initialize', TMP_Compound_initialize_2 = function $$initialize(raw, x_min, y_min, x_max, y_max) {
            var TMP_1, self = this, offset = nil;

            
            self.raw = raw;
            self.x_min = x_min;
            self.y_min = y_min;
            self.x_max = x_max;
            self.y_max = y_max;
            self.glyph_ids = [];
            self.glyph_id_offsets = [];
            offset = 10;
            return (function(){var $brk = Opal.new_brk(); try {return $send(self, 'loop', [], (TMP_1 = function(){var self = TMP_1.$$s || this, $a, $b, flags = nil, glyph_id = nil;
              if (self.raw == null) self.raw = nil;
              if (self.glyph_ids == null) self.glyph_ids = nil;
              if (self.glyph_id_offsets == null) self.glyph_id_offsets = nil;

            
              $b = self.raw['$[]'](offset, 4).$unpack("n*"), $a = Opal.to_ary($b), (flags = ($a[0] == null ? nil : $a[0])), (glyph_id = ($a[1] == null ? nil : $a[1])), $b;
              self.glyph_ids['$<<'](glyph_id);
              self.glyph_id_offsets['$<<']($rb_plus(offset, 2));
              if ($truthy(flags['$&'](Opal.const_get_relative($nesting, 'MORE_COMPONENTS'))['$!='](0))) {
                } else {
                
                Opal.brk(nil, $brk)
              };
              offset = $rb_plus(offset, 4);
              offset = $rb_plus(offset, (function() {if ($truthy(flags['$&'](Opal.const_get_relative($nesting, 'ARG_1_AND_2_ARE_WORDS'))['$!='](0))) {
                return 4
                } else {
                return 2
              }; return nil; })());
              if ($truthy(flags['$&'](Opal.const_get_relative($nesting, 'WE_HAVE_A_TWO_BY_TWO'))['$!='](0))) {
                return (offset = $rb_plus(offset, 8))
              } else if ($truthy(flags['$&'](Opal.const_get_relative($nesting, 'WE_HAVE_AN_X_AND_Y_SCALE'))['$!='](0))) {
                return (offset = $rb_plus(offset, 4))
              } else if ($truthy(flags['$&'](Opal.const_get_relative($nesting, 'WE_HAVE_A_SCALE'))['$!='](0))) {
                return (offset = $rb_plus(offset, 2))
                } else {
                return nil
              };}, TMP_1.$$s = self, TMP_1.$$brk = $brk, TMP_1.$$arity = 0, TMP_1))
            } catch (err) { if (err === $brk) { return err.$v } else { throw err } }})();
          }, TMP_Compound_initialize_2.$$arity = 5);
          
          Opal.defn(self, '$compound?', TMP_Compound_compound$q_3 = function() {
            var self = this;

            return true
          }, TMP_Compound_compound$q_3.$$arity = 0);
          return (Opal.defn(self, '$recode', TMP_Compound_recode_6 = function $$recode(mapping) {
            var TMP_4, TMP_5, self = this, result = nil, new_ids = nil;

            
            result = self.raw.$dup();
            new_ids = $send(self.$glyph_ids(), 'map', [], (TMP_4 = function(id){var self = TMP_4.$$s || this;
if (id == null) id = nil;
            return mapping['$[]'](id)}, TMP_4.$$s = self, TMP_4.$$arity = 1, TMP_4));
            $send(new_ids.$zip(self.glyph_id_offsets), 'each', [], (TMP_5 = function(new_id, offset){var self = TMP_5.$$s || this, $writer = nil;
if (new_id == null) new_id = nil;if (offset == null) offset = nil;
            
              $writer = [offset, 2, [new_id].$pack("n")];
              $send(result, '[]=', Opal.to_a($writer));
              return $writer[$rb_minus($writer["length"], 1)];}, TMP_5.$$s = self, TMP_5.$$arity = 2, TMP_5));
            return result;
          }, TMP_Compound_recode_6.$$arity = 1), nil) && 'recode';
        })($nesting[0], null, $nesting)
      })($nesting[0], null, $nesting)
    })($nesting[0], null, $nesting)
  })($nesting[0], $nesting);
};

/* Generated by Opal 0.11.0 */
Opal.modules["ttfunk/table/glyf/simple"] = function(Opal) {
  var self = Opal.top, $nesting = [], nil = Opal.nil, $breaker = Opal.breaker, $slice = Opal.slice, $module = Opal.module, $klass = Opal.klass;

  Opal.add_stubs(['$attr_reader', '$raw']);
  
  self.$require("ttfunk/table/glyf/simple"+ '/../' + "../../reader");
  return (function($base, $parent_nesting) {
    var $TTFunk, self = $TTFunk = $module($base, 'TTFunk');

    var def = self.$$proto, $nesting = [self].concat($parent_nesting);

    (function($base, $super, $parent_nesting) {
      function $Table(){};
      var self = $Table = $klass($base, $super, 'Table', $Table);

      var def = self.$$proto, $nesting = [self].concat($parent_nesting);

      return (function($base, $super, $parent_nesting) {
        function $Glyf(){};
        var self = $Glyf = $klass($base, $super, 'Glyf', $Glyf);

        var def = self.$$proto, $nesting = [self].concat($parent_nesting);

        return (function($base, $super, $parent_nesting) {
          function $Simple(){};
          var self = $Simple = $klass($base, $super, 'Simple', $Simple);

          var def = self.$$proto, $nesting = [self].concat($parent_nesting), TMP_Simple_initialize_1, TMP_Simple_compound$q_2, TMP_Simple_recode_3;

          
          self.$attr_reader("raw");
          self.$attr_reader("number_of_contours");
          self.$attr_reader("x_min", "y_min", "x_max", "y_max");
          
          Opal.defn(self, '$initialize', TMP_Simple_initialize_1 = function $$initialize(raw, number_of_contours, x_min, y_min, x_max, y_max) {
            var self = this;

            
            self.raw = raw;
            self.number_of_contours = number_of_contours;
            self.x_min = x_min;
            self.y_min = y_min;
            self.x_max = x_max;
            return (self.y_max = y_max);
          }, TMP_Simple_initialize_1.$$arity = 6);
          
          Opal.defn(self, '$compound?', TMP_Simple_compound$q_2 = function() {
            var self = this;

            return false
          }, TMP_Simple_compound$q_2.$$arity = 0);
          return (Opal.defn(self, '$recode', TMP_Simple_recode_3 = function $$recode(_mapping) {
            var self = this;

            return self.$raw()
          }, TMP_Simple_recode_3.$$arity = 1), nil) && 'recode';
        })($nesting[0], null, $nesting)
      })($nesting[0], null, $nesting)
    })($nesting[0], null, $nesting)
  })($nesting[0], $nesting);
};

/* Generated by Opal 0.11.0 */
Opal.modules["ttfunk/table/glyf"] = function(Opal) {
  function $rb_minus(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs - rhs : lhs['$-'](rhs);
  }
  function $rb_plus(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs + rhs : lhs['$+'](rhs);
  }
  var self = Opal.top, $nesting = [], nil = Opal.nil, $breaker = Opal.breaker, $slice = Opal.slice, $module = Opal.module, $klass = Opal.klass, $hash2 = Opal.hash2, $send = Opal.send, $truthy = Opal.truthy;

  Opal.add_stubs(['$each', '$sort', '$keys', '$[]', '$<<', '$length', '$recode', '$key?', '$index_of', '$glyph_locations', '$file', '$size_of', '$==', '$[]=', '$-', '$parse_from', '$+', '$offset', '$read', '$io', '$map', '$unpack', '$to_signed', '$new', '$private']);
  
  self.$require("ttfunk/table/glyf"+ '/../' + "../table");
  (function($base, $parent_nesting) {
    var $TTFunk, self = $TTFunk = $module($base, 'TTFunk');

    var def = self.$$proto, $nesting = [self].concat($parent_nesting);

    (function($base, $super, $parent_nesting) {
      function $Table(){};
      var self = $Table = $klass($base, $super, 'Table', $Table);

      var def = self.$$proto, $nesting = [self].concat($parent_nesting);

      return (function($base, $super, $parent_nesting) {
        function $Glyf(){};
        var self = $Glyf = $klass($base, $super, 'Glyf', $Glyf);

        var def = self.$$proto, $nesting = [self].concat($parent_nesting), TMP_Glyf_encode_2, TMP_Glyf_for_5, TMP_Glyf_parse$B_6;

        def.cache = nil;
        
        Opal.defs(self, '$encode', TMP_Glyf_encode_2 = function $$encode(glyphs, new2old, old2new) {
          var TMP_1, self = this, result = nil;

          
          result = $hash2(["table", "offsets"], {"table": "", "offsets": []});
          $send(new2old.$keys().$sort(), 'each', [], (TMP_1 = function(new_id){var self = TMP_1.$$s || this, glyph = nil;
if (new_id == null) new_id = nil;
          
            glyph = glyphs['$[]'](new2old['$[]'](new_id));
            result['$[]']("offsets")['$<<'](result['$[]']("table").$length());
            if ($truthy(glyph)) {
              return result['$[]']("table")['$<<'](glyph.$recode(old2new))
              } else {
              return nil
            };}, TMP_1.$$s = self, TMP_1.$$arity = 1, TMP_1));
          result['$[]']("offsets")['$<<'](result['$[]']("table").$length());
          return result;
        }, TMP_Glyf_encode_2.$$arity = 3);
        
        Opal.defn(self, '$for', TMP_Glyf_for_5 = function(glyph_id) {
          var TMP_3, self = this, index = nil, size = nil, $writer = nil;

          
          if ($truthy(self.cache['$key?'](glyph_id))) {
            return self.cache['$[]'](glyph_id)};
          index = self.$file().$glyph_locations().$index_of(glyph_id);
          size = self.$file().$glyph_locations().$size_of(glyph_id);
          if (size['$=='](0)) {
            
            
            $writer = [glyph_id, nil];
            $send(self.cache, '[]=', Opal.to_a($writer));
            $writer[$rb_minus($writer["length"], 1)];;
            return nil;};
          return $send(self, 'parse_from', [$rb_plus(self.$offset(), index)], (TMP_3 = function(){var self = TMP_3.$$s || this, $a, $b, TMP_4, raw = nil, number_of_contours = nil, x_min = nil, y_min = nil, x_max = nil, y_max = nil;
            if (self.cache == null) self.cache = nil;

          
            raw = self.$io().$read(size);
            $b = $send(raw.$unpack("n5"), 'map', [], (TMP_4 = function(i){var self = TMP_4.$$s || this;
if (i == null) i = nil;
            return self.$to_signed(i)}, TMP_4.$$s = self, TMP_4.$$arity = 1, TMP_4)), $a = Opal.to_ary($b), (number_of_contours = ($a[0] == null ? nil : $a[0])), (x_min = ($a[1] == null ? nil : $a[1])), (y_min = ($a[2] == null ? nil : $a[2])), (x_max = ($a[3] == null ? nil : $a[3])), (y_max = ($a[4] == null ? nil : $a[4])), $b;
            
            $writer = [glyph_id, (function() {if (number_of_contours['$=='](-1)) {
              return Opal.const_get_relative($nesting, 'Compound').$new(raw, x_min, y_min, x_max, y_max)
              } else {
              return Opal.const_get_relative($nesting, 'Simple').$new(raw, number_of_contours, x_min, y_min, x_max, y_max)
            }; return nil; })()];
            $send(self.cache, '[]=', Opal.to_a($writer));
            return $writer[$rb_minus($writer["length"], 1)];;}, TMP_3.$$s = self, TMP_3.$$arity = 0, TMP_3));
        }, TMP_Glyf_for_5.$$arity = 1);
        self.$private();
        return (Opal.defn(self, '$parse!', TMP_Glyf_parse$B_6 = function() {
          var self = this;

          return (self.cache = $hash2([], {}))
        }, TMP_Glyf_parse$B_6.$$arity = 0), nil) && 'parse!';
      })($nesting[0], Opal.const_get_relative($nesting, 'Table'), $nesting)
    })($nesting[0], null, $nesting)
  })($nesting[0], $nesting);
  self.$require("ttfunk/table/glyf"+ '/../' + "glyf/compound");
  return self.$require("ttfunk/table/glyf"+ '/../' + "glyf/simple");
};

/* Generated by Opal 0.11.0 */
Opal.modules["ttfunk/table/head"] = function(Opal) {
  function $rb_minus(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs - rhs : lhs['$-'](rhs);
  }
  var self = Opal.top, $nesting = [], nil = Opal.nil, $breaker = Opal.breaker, $slice = Opal.slice, $module = Opal.module, $klass = Opal.klass, $send = Opal.send;

  Opal.add_stubs(['$attr_reader', '$raw', '$[]=', '$-', '$pack', '$[]', '$private', '$read', '$read_signed']);
  
  self.$require("ttfunk/table/head"+ '/../' + "../table");
  return (function($base, $parent_nesting) {
    var $TTFunk, self = $TTFunk = $module($base, 'TTFunk');

    var def = self.$$proto, $nesting = [self].concat($parent_nesting);

    (function($base, $super, $parent_nesting) {
      function $Table(){};
      var self = $Table = $klass($base, $super, 'Table', $Table);

      var def = self.$$proto, $nesting = [self].concat($parent_nesting);

      return (function($base, $super, $parent_nesting) {
        function $Head(){};
        var self = $Head = $klass($base, $super, 'Head', $Head);

        var def = self.$$proto, $nesting = [self].concat($parent_nesting), TMP_Head_encode_1, TMP_Head_parse$B_2;

        
        self.$attr_reader("version");
        self.$attr_reader("font_revision");
        self.$attr_reader("checksum_adjustment");
        self.$attr_reader("magic_number");
        self.$attr_reader("flags");
        self.$attr_reader("units_per_em");
        self.$attr_reader("created");
        self.$attr_reader("modified");
        self.$attr_reader("x_min");
        self.$attr_reader("y_min");
        self.$attr_reader("x_max");
        self.$attr_reader("y_max");
        self.$attr_reader("mac_style");
        self.$attr_reader("lowest_rec_ppem");
        self.$attr_reader("font_direction_hint");
        self.$attr_reader("index_to_loc_format");
        self.$attr_reader("glyph_data_format");
        Opal.defs(self, '$encode', TMP_Head_encode_1 = function $$encode(head, loca) {
          var self = this, table = nil, $writer = nil;

          
          table = head.$raw();
          
          $writer = [8, 4, "\u0000\u0000\u0000\u0000"];
          $send(table, '[]=', Opal.to_a($writer));
          $writer[$rb_minus($writer["length"], 1)];;
          
          $writer = [-4, 2, [loca['$[]']("type")].$pack("n")];
          $send(table, '[]=', Opal.to_a($writer));
          $writer[$rb_minus($writer["length"], 1)];;
          return table;
        }, TMP_Head_encode_1.$$arity = 2);
        self.$private();
        return (Opal.defn(self, '$parse!', TMP_Head_parse$B_2 = function() {
          var $a, $b, self = this;

          
          $b = self.$read(36, "N4n2q2"), $a = Opal.to_ary($b), (self.version = ($a[0] == null ? nil : $a[0])), (self.font_revision = ($a[1] == null ? nil : $a[1])), (self.check_sum_adjustment = ($a[2] == null ? nil : $a[2])), (self.magic_number = ($a[3] == null ? nil : $a[3])), (self.flags = ($a[4] == null ? nil : $a[4])), (self.units_per_em = ($a[5] == null ? nil : $a[5])), (self.created = ($a[6] == null ? nil : $a[6])), (self.modified = ($a[7] == null ? nil : $a[7])), $b;
          $b = self.$read_signed(4), $a = Opal.to_ary($b), (self.x_min = ($a[0] == null ? nil : $a[0])), (self.y_min = ($a[1] == null ? nil : $a[1])), (self.x_max = ($a[2] == null ? nil : $a[2])), (self.y_max = ($a[3] == null ? nil : $a[3])), $b;
          return $b = self.$read(10, "n*"), $a = Opal.to_ary($b), (self.mac_style = ($a[0] == null ? nil : $a[0])), (self.lowest_rec_ppem = ($a[1] == null ? nil : $a[1])), (self.font_direction_hint = ($a[2] == null ? nil : $a[2])), (self.index_to_loc_format = ($a[3] == null ? nil : $a[3])), (self.glyph_data_format = ($a[4] == null ? nil : $a[4])), $b;
        }, TMP_Head_parse$B_2.$$arity = 0), nil) && 'parse!';
      })($nesting[0], Opal.const_get_qualified(Opal.const_get_relative($nesting, 'TTFunk'), 'Table'), $nesting)
    })($nesting[0], null, $nesting)
  })($nesting[0], $nesting);
};

/* Generated by Opal 0.11.0 */
Opal.modules["ttfunk/table/hhea"] = function(Opal) {
  function $rb_minus(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs - rhs : lhs['$-'](rhs);
  }
  var self = Opal.top, $nesting = [], nil = Opal.nil, $breaker = Opal.breaker, $slice = Opal.slice, $module = Opal.module, $klass = Opal.klass, $send = Opal.send;

  Opal.add_stubs(['$attr_reader', '$raw', '$pack', '$[]', '$[]=', '$-', '$private', '$first', '$read', '$read_signed']);
  
  self.$require("ttfunk/table/hhea"+ '/../' + "../table");
  return (function($base, $parent_nesting) {
    var $TTFunk, self = $TTFunk = $module($base, 'TTFunk');

    var def = self.$$proto, $nesting = [self].concat($parent_nesting);

    (function($base, $super, $parent_nesting) {
      function $Table(){};
      var self = $Table = $klass($base, $super, 'Table', $Table);

      var def = self.$$proto, $nesting = [self].concat($parent_nesting);

      return (function($base, $super, $parent_nesting) {
        function $Hhea(){};
        var self = $Hhea = $klass($base, $super, 'Hhea', $Hhea);

        var def = self.$$proto, $nesting = [self].concat($parent_nesting), TMP_Hhea_encode_1, TMP_Hhea_parse$B_2;

        
        self.$attr_reader("version");
        self.$attr_reader("ascent");
        self.$attr_reader("descent");
        self.$attr_reader("line_gap");
        self.$attr_reader("advance_width_max");
        self.$attr_reader("min_left_side_bearing");
        self.$attr_reader("min_right_side_bearing");
        self.$attr_reader("x_max_extent");
        self.$attr_reader("carot_slope_rise");
        self.$attr_reader("carot_slope_run");
        self.$attr_reader("metric_data_format");
        self.$attr_reader("number_of_metrics");
        Opal.defs(self, '$encode', TMP_Hhea_encode_1 = function $$encode(hhea, hmtx) {
          var self = this, raw = nil, $writer = nil;

          
          raw = hhea.$raw();
          
          $writer = [-2, 2, [hmtx['$[]']("number_of_metrics")].$pack("n")];
          $send(raw, '[]=', Opal.to_a($writer));
          $writer[$rb_minus($writer["length"], 1)];;
          return raw;
        }, TMP_Hhea_encode_1.$$arity = 2);
        self.$private();
        return (Opal.defn(self, '$parse!', TMP_Hhea_parse$B_2 = function() {
          var $a, $b, self = this, _reserved = nil;

          
          self.version = self.$read(4, "N").$first();
          $b = self.$read_signed(3), $a = Opal.to_ary($b), (self.ascent = ($a[0] == null ? nil : $a[0])), (self.descent = ($a[1] == null ? nil : $a[1])), (self.line_gap = ($a[2] == null ? nil : $a[2])), $b;
          self.advance_width_max = self.$read(2, "n").$first();
          $b = self.$read_signed(11), $a = Opal.to_ary($b), (self.min_left_side_bearing = ($a[0] == null ? nil : $a[0])), (self.min_right_side_bearing = ($a[1] == null ? nil : $a[1])), (self.x_max_extent = ($a[2] == null ? nil : $a[2])), (self.carot_slope_rise = ($a[3] == null ? nil : $a[3])), (self.carot_slope_run = ($a[4] == null ? nil : $a[4])), (self.caret_offset = ($a[5] == null ? nil : $a[5])), (_reserved = ($a[6] == null ? nil : $a[6])), (_reserved = ($a[7] == null ? nil : $a[7])), (_reserved = ($a[8] == null ? nil : $a[8])), (_reserved = ($a[9] == null ? nil : $a[9])), (self.metric_data_format = ($a[10] == null ? nil : $a[10])), $b;
          return (self.number_of_metrics = self.$read(2, "n").$first());
        }, TMP_Hhea_parse$B_2.$$arity = 0), nil) && 'parse!';
      })($nesting[0], Opal.const_get_relative($nesting, 'Table'), $nesting)
    })($nesting[0], null, $nesting)
  })($nesting[0], $nesting);
};

/* Generated by Opal 0.11.0 */
Opal.modules["ttfunk/table/hmtx"] = function(Opal) {
  function $rb_minus(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs - rhs : lhs['$-'](rhs);
  }
  function $rb_plus(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs + rhs : lhs['$+'](rhs);
  }
  function $rb_times(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs * rhs : lhs['$*'](rhs);
  }
  var self = Opal.top, $nesting = [], nil = Opal.nil, $breaker = Opal.breaker, $slice = Opal.slice, $module = Opal.module, $klass = Opal.klass, $send = Opal.send, $hash2 = Opal.hash2, $truthy = Opal.truthy;

  Opal.add_stubs(['$attr_reader', '$map', '$sort', '$keys', '$for', '$[]', '$advance_width', '$left_side_bearing', '$length', '$pack', '$flatten', '$new', '$last', '$-', '$private', '$times', '$number_of_metrics', '$horizontal_header', '$file', '$first', '$read', '$read_signed', '$push', '$num_glyphs', '$maximum_profile', '$to_proc', '$+', '$*']);
  
  self.$require("ttfunk/table/hmtx"+ '/../' + "../table");
  return (function($base, $parent_nesting) {
    var $TTFunk, self = $TTFunk = $module($base, 'TTFunk');

    var def = self.$$proto, $nesting = [self].concat($parent_nesting);

    (function($base, $super, $parent_nesting) {
      function $Table(){};
      var self = $Table = $klass($base, $super, 'Table', $Table);

      var def = self.$$proto, $nesting = [self].concat($parent_nesting);

      return (function($base, $super, $parent_nesting) {
        function $Hmtx(){};
        var self = $Hmtx = $klass($base, $super, 'Hmtx', $Hmtx);

        var def = self.$$proto, $nesting = [self].concat($parent_nesting), TMP_Hmtx_encode_2, TMP_Hmtx_for_3, TMP_Hmtx_parse$B_5;

        def.metrics = def.left_side_bearings = def.widths = nil;
        
        self.$attr_reader("metrics");
        self.$attr_reader("left_side_bearings");
        self.$attr_reader("widths");
        Opal.defs(self, '$encode', TMP_Hmtx_encode_2 = function $$encode(hmtx, mapping) {
          var TMP_1, self = this, metrics = nil;

          
          metrics = $send(mapping.$keys().$sort(), 'map', [], (TMP_1 = function(new_id){var self = TMP_1.$$s || this, metric = nil;
if (new_id == null) new_id = nil;
          
            metric = hmtx.$for(mapping['$[]'](new_id));
            return [metric.$advance_width(), metric.$left_side_bearing()];}, TMP_1.$$s = self, TMP_1.$$arity = 1, TMP_1));
          return $hash2(["number_of_metrics", "table"], {"number_of_metrics": metrics.$length(), "table": metrics.$flatten().$pack("n*")});
        }, TMP_Hmtx_encode_2.$$arity = 2);
        Opal.const_set($nesting[0], 'HorizontalMetric', Opal.const_get_relative($nesting, 'Struct').$new("advance_width", "left_side_bearing"));
        
        Opal.defn(self, '$for', TMP_Hmtx_for_3 = function(glyph_id) {
          var $a, self = this;

          return ($truthy($a = self.metrics['$[]'](glyph_id)) ? $a : Opal.const_get_relative($nesting, 'HorizontalMetric').$new(self.metrics.$last().$advance_width(), self.left_side_bearings['$[]']($rb_minus(glyph_id, self.metrics.$length()))))
        }, TMP_Hmtx_for_3.$$arity = 1);
        self.$private();
        return (Opal.defn(self, '$parse!', TMP_Hmtx_parse$B_5 = function() {
          var TMP_4, self = this, lsb_count = nil;

          
          self.metrics = [];
          $send(self.$file().$horizontal_header().$number_of_metrics(), 'times', [], (TMP_4 = function(){var self = TMP_4.$$s || this, advance = nil, lsb = nil;
            if (self.metrics == null) self.metrics = nil;

          
            advance = self.$read(2, "n").$first();
            lsb = self.$read_signed(1).$first();
            return self.metrics.$push(Opal.const_get_relative($nesting, 'HorizontalMetric').$new(advance, lsb));}, TMP_4.$$s = self, TMP_4.$$arity = 0, TMP_4));
          lsb_count = $rb_minus(self.$file().$maximum_profile().$num_glyphs(), self.$file().$horizontal_header().$number_of_metrics());
          self.left_side_bearings = self.$read_signed(lsb_count);
          self.widths = $send(self.metrics, 'map', [], "advance_width".$to_proc());
          return (self.widths = $rb_plus(self.widths, $rb_times([self.widths.$last()], self.left_side_bearings.$length())));
        }, TMP_Hmtx_parse$B_5.$$arity = 0), nil) && 'parse!';
      })($nesting[0], Opal.const_get_relative($nesting, 'Table'), $nesting)
    })($nesting[0], null, $nesting)
  })($nesting[0], $nesting);
};

/* Generated by Opal 0.11.0 */
Opal.modules["ttfunk/table/kern/format0"] = function(Opal) {
  function $rb_gt(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs > rhs : lhs['$>'](rhs);
  }
  function $rb_plus(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs + rhs : lhs['$+'](rhs);
  }
  function $rb_times(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs * rhs : lhs['$*'](rhs);
  }
  function $rb_minus(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs - rhs : lhs['$-'](rhs);
  }
  function $rb_divide(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs / rhs : lhs['$/'](rhs);
  }
  var self = Opal.top, $nesting = [], nil = Opal.nil, $breaker = Opal.breaker, $slice = Opal.slice, $module = Opal.module, $klass = Opal.klass, $hash2 = Opal.hash2, $send = Opal.send, $truthy = Opal.truthy;

  Opal.add_stubs(['$include', '$attr_reader', '$unpack', '$delete', '$times', '$>', '$+', '$*', '$length', '$[]', '$to_signed', '$[]=', '$-', '$!', '$vertical?', '$each', '$pairs', '$<<', '$empty?', '$**', '$to_i', '$/', '$log', '$pack', '$flatten', '$attributes']);
  
  self.$require("ttfunk/table/kern/format0"+ '/../' + "../../reader");
  return (function($base, $parent_nesting) {
    var $TTFunk, self = $TTFunk = $module($base, 'TTFunk');

    var def = self.$$proto, $nesting = [self].concat($parent_nesting);

    (function($base, $super, $parent_nesting) {
      function $Table(){};
      var self = $Table = $klass($base, $super, 'Table', $Table);

      var def = self.$$proto, $nesting = [self].concat($parent_nesting);

      return (function($base, $super, $parent_nesting) {
        function $Kern(){};
        var self = $Kern = $klass($base, $super, 'Kern', $Kern);

        var def = self.$$proto, $nesting = [self].concat($parent_nesting);

        return (function($base, $super, $parent_nesting) {
          function $Format0(){};
          var self = $Format0 = $klass($base, $super, 'Format0', $Format0);

          var def = self.$$proto, $nesting = [self].concat($parent_nesting), TMP_Format0_initialize_2, TMP_Format0_vertical$q_3, TMP_Format0_horizontal$q_4, TMP_Format0_cross_stream$q_5, TMP_Format0_recode_7;

          def.attributes = nil;
          
          self.$include(Opal.const_get_relative($nesting, 'Reader'));
          self.$attr_reader("attributes");
          self.$attr_reader("pairs");
          
          Opal.defn(self, '$initialize', TMP_Format0_initialize_2 = function $$initialize(attributes) {
            var $a, $b, TMP_1, self = this, num_pairs = nil, pairs = nil;

            if (attributes == null) {
              attributes = $hash2([], {});
            }
            
            self.attributes = attributes;
            $b = attributes.$delete("data").$unpack("nx6n*"), $a = Opal.to_ary($b), (num_pairs = ($a[0] == null ? nil : $a[0])), (pairs = $slice.call($a, 1)), $b;
            self.pairs = $hash2([], {});
            return (function(){var $brk = Opal.new_brk(); try {return $send(num_pairs, 'times', [], (TMP_1 = function(i){var self = TMP_1.$$s || this, left = nil, right = nil, value = nil, $writer = nil;
              if (self.pairs == null) self.pairs = nil;
if (i == null) i = nil;
            
              if ($truthy($rb_gt($rb_plus($rb_times(i, 3), 2), pairs.$length()))) {
                
                Opal.brk(nil, $brk)};
              left = pairs['$[]']($rb_times(i, 3));
              right = pairs['$[]']($rb_plus($rb_times(i, 3), 1));
              value = self.$to_signed(pairs['$[]']($rb_plus($rb_times(i, 3), 2)));
              
              $writer = [[left, right], value];
              $send(self.pairs, '[]=', Opal.to_a($writer));
              return $writer[$rb_minus($writer["length"], 1)];;}, TMP_1.$$s = self, TMP_1.$$brk = $brk, TMP_1.$$arity = 1, TMP_1))
            } catch (err) { if (err === $brk) { return err.$v } else { throw err } }})();
          }, TMP_Format0_initialize_2.$$arity = -1);
          
          Opal.defn(self, '$vertical?', TMP_Format0_vertical$q_3 = function() {
            var self = this;

            return self.attributes['$[]']("vertical")
          }, TMP_Format0_vertical$q_3.$$arity = 0);
          
          Opal.defn(self, '$horizontal?', TMP_Format0_horizontal$q_4 = function() {
            var self = this;

            return self['$vertical?']()['$!']()
          }, TMP_Format0_horizontal$q_4.$$arity = 0);
          
          Opal.defn(self, '$cross_stream?', TMP_Format0_cross_stream$q_5 = function() {
            var self = this;

            return self.attributes['$[]']("cross")
          }, TMP_Format0_cross_stream$q_5.$$arity = 0);
          return (Opal.defn(self, '$recode', TMP_Format0_recode_7 = function $$recode(mapping) {
            var TMP_6, self = this, subset = nil, num_pairs = nil, search_range = nil, entry_selector = nil, range_shift = nil;

            
            subset = [];
            $send(self.$pairs(), 'each', [], (TMP_6 = function($a, value){var self = TMP_6.$$s || this, $a_args, left, right, $b;

              if ($a == null) {
                $a = nil;
              }
              $a = Opal.to_ary($a);
              $a_args = Opal.slice.call($a, 0, $a.length);
              left = $a_args.splice(0,1)[0];
              if (left == null) {
                left = nil;
              }
              right = $a_args.splice(0,1)[0];
              if (right == null) {
                right = nil;
              }if (value == null) value = nil;
            if ($truthy(($truthy($b = mapping['$[]'](left)) ? mapping['$[]'](right) : $b))) {
                return subset['$<<']([mapping['$[]'](left), mapping['$[]'](right), value])
                } else {
                return nil
              }}, TMP_6.$$s = self, TMP_6.$$arity = 2, TMP_6.$$has_top_level_mlhs_arg = true, TMP_6));
            if ($truthy(subset['$empty?']())) {
              return nil};
            num_pairs = subset.$length();
            search_range = $rb_times(2, (2)['$**']($rb_divide(Opal.const_get_relative($nesting, 'Math').$log(num_pairs), Opal.const_get_relative($nesting, 'Math').$log(2)).$to_i()));
            entry_selector = $rb_divide(Opal.const_get_relative($nesting, 'Math').$log($rb_divide(search_range, 2)), Opal.const_get_relative($nesting, 'Math').$log(2)).$to_i();
            range_shift = $rb_minus($rb_times(2, num_pairs), search_range);
            return [self.$attributes()['$[]']("version"), $rb_plus($rb_times(num_pairs, 6), 14), self.$attributes()['$[]']("coverage"), num_pairs, search_range, entry_selector, range_shift, subset].$flatten().$pack("n*");
          }, TMP_Format0_recode_7.$$arity = 1), nil) && 'recode';
        })($nesting[0], null, $nesting)
      })($nesting[0], null, $nesting)
    })($nesting[0], null, $nesting)
  })($nesting[0], $nesting);
};

/* Generated by Opal 0.11.0 */
Opal.modules["ttfunk/table/kern"] = function(Opal) {
  function $rb_plus(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs + rhs : lhs['$+'](rhs);
  }
  function $rb_minus(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs - rhs : lhs['$-'](rhs);
  }
  var self = Opal.top, $nesting = [], nil = Opal.nil, $breaker = Opal.breaker, $slice = Opal.slice, $module = Opal.module, $klass = Opal.klass, $truthy = Opal.truthy, $send = Opal.send, $hash2 = Opal.hash2, $range = Opal.range;

  Opal.add_stubs(['$attr_reader', '$exists?', '$any?', '$tables', '$compact', '$map', '$recode', '$empty?', '$pack', '$length', '$join', '$private', '$read', '$==', '$+', '$<<', '$first', '$parse_version_1_tables', '$parse_version_0_tables', '$>>', '$add_table', '$[]', '$raw', '$&', '$!=', '$times', '$io', '$-', '$new']);
  
  self.$require("ttfunk/table/kern"+ '/../' + "../table");
  (function($base, $parent_nesting) {
    var $TTFunk, self = $TTFunk = $module($base, 'TTFunk');

    var def = self.$$proto, $nesting = [self].concat($parent_nesting);

    (function($base, $super, $parent_nesting) {
      function $Table(){};
      var self = $Table = $klass($base, $super, 'Table', $Table);

      var def = self.$$proto, $nesting = [self].concat($parent_nesting);

      return (function($base, $super, $parent_nesting) {
        function $Kern(){};
        var self = $Kern = $klass($base, $super, 'Kern', $Kern);

        var def = self.$$proto, $nesting = [self].concat($parent_nesting), TMP_Kern_encode_2, TMP_Kern_parse$B_3, TMP_Kern_parse_version_0_tables_4, TMP_Kern_parse_version_1_tables_6, TMP_Kern_add_table_7;

        def.version = def.tables = nil;
        
        self.$attr_reader("version");
        self.$attr_reader("tables");
        Opal.defs(self, '$encode', TMP_Kern_encode_2 = function $$encode(kerning, mapping) {
          var $a, TMP_1, self = this, tables = nil;

          
          if ($truthy(($truthy($a = kerning['$exists?']()) ? kerning.$tables()['$any?']() : $a))) {
            } else {
            return nil
          };
          tables = $send(kerning.$tables(), 'map', [], (TMP_1 = function(table){var self = TMP_1.$$s || this;
if (table == null) table = nil;
          return table.$recode(mapping)}, TMP_1.$$s = self, TMP_1.$$arity = 1, TMP_1)).$compact();
          if ($truthy(tables['$empty?']())) {
            return nil};
          return [0, tables.$length(), tables.$join()].$pack("nnA*");
        }, TMP_Kern_encode_2.$$arity = 2);
        self.$private();
        
        Opal.defn(self, '$parse!', TMP_Kern_parse$B_3 = function() {
          var $a, $b, self = this, num_tables = nil;

          
          $b = self.$read(4, "n*"), $a = Opal.to_ary($b), (self.version = ($a[0] == null ? nil : $a[0])), (num_tables = ($a[1] == null ? nil : $a[1])), $b;
          self.tables = [];
          if (self.version['$=='](1)) {
            
            self.version = $rb_plus(self.version['$<<'](16), num_tables);
            num_tables = self.$read(4, "N").$first();
            return self.$parse_version_1_tables(num_tables);
            } else {
            return self.$parse_version_0_tables(num_tables)
          };
        }, TMP_Kern_parse$B_3.$$arity = 0);
        
        Opal.defn(self, '$parse_version_0_tables', TMP_Kern_parse_version_0_tables_4 = function $$parse_version_0_tables(_num_tables) {
          var $a, $b, self = this, version = nil, length = nil, coverage = nil, format = nil;

          
          $b = self.$read(6, "n*"), $a = Opal.to_ary($b), (version = ($a[0] == null ? nil : $a[0])), (length = ($a[1] == null ? nil : $a[1])), (coverage = ($a[2] == null ? nil : $a[2])), $b;
          format = coverage['$>>'](8);
          return self.$add_table(format, $hash2(["version", "length", "coverage", "data", "vertical", "minimum", "cross", "override"], {"version": version, "length": length, "coverage": coverage, "data": self.$raw()['$[]']($range(10, -1, false)), "vertical": coverage['$&'](1)['$=='](0), "minimum": coverage['$&'](2)['$!='](0), "cross": coverage['$&'](4)['$!='](0), "override": coverage['$&'](8)['$!='](0)}));
        }, TMP_Kern_parse_version_0_tables_4.$$arity = 1);
        
        Opal.defn(self, '$parse_version_1_tables', TMP_Kern_parse_version_1_tables_6 = function $$parse_version_1_tables(num_tables) {
          var TMP_5, self = this;

          return $send(num_tables, 'times', [], (TMP_5 = function(){var self = TMP_5.$$s || this, $a, $b, length = nil, coverage = nil, tuple_index = nil, format = nil;

          
            $b = self.$read(8, "Nnn"), $a = Opal.to_ary($b), (length = ($a[0] == null ? nil : $a[0])), (coverage = ($a[1] == null ? nil : $a[1])), (tuple_index = ($a[2] == null ? nil : $a[2])), $b;
            format = coverage['$&'](255);
            return self.$add_table(format, $hash2(["length", "coverage", "tuple_index", "data", "vertical", "cross", "variation"], {"length": length, "coverage": coverage, "tuple_index": tuple_index, "data": self.$io().$read($rb_minus(length, 8)), "vertical": coverage['$&'](32768)['$!='](0), "cross": coverage['$&'](16384)['$!='](0), "variation": coverage['$&'](8192)['$!='](0)}));}, TMP_5.$$s = self, TMP_5.$$arity = 0, TMP_5))
        }, TMP_Kern_parse_version_1_tables_6.$$arity = 1);
        return (Opal.defn(self, '$add_table', TMP_Kern_add_table_7 = function $$add_table(format, attributes) {
          var self = this;

          if (attributes == null) {
            attributes = $hash2([], {});
          }
          if (format['$=='](0)) {
            return self.tables['$<<'](Opal.const_get_qualified(Opal.const_get_relative($nesting, 'Kern'), 'Format0').$new(attributes))
            } else {
            return nil
          }
        }, TMP_Kern_add_table_7.$$arity = -2), nil) && 'add_table';
      })($nesting[0], Opal.const_get_relative($nesting, 'Table'), $nesting)
    })($nesting[0], null, $nesting)
  })($nesting[0], $nesting);
  return self.$require("ttfunk/table/kern"+ '/../' + "kern/format0");
};

/* Generated by Opal 0.11.0 */
Opal.modules["ttfunk/table/loca"] = function(Opal) {
  function $rb_divide(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs / rhs : lhs['$/'](rhs);
  }
  function $rb_times(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs * rhs : lhs['$*'](rhs);
  }
  function $rb_gt(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs > rhs : lhs['$>'](rhs);
  }
  function $rb_minus(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs - rhs : lhs['$-'](rhs);
  }
  function $rb_plus(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs + rhs : lhs['$+'](rhs);
  }
  var self = Opal.top, $nesting = [], nil = Opal.nil, $breaker = Opal.breaker, $slice = Opal.slice, $module = Opal.module, $klass = Opal.klass, $send = Opal.send, $truthy = Opal.truthy, $hash2 = Opal.hash2;

  Opal.add_stubs(['$attr_reader', '$any?', '$/', '$!=', '$*', '$>', '$pack', '$map', '$[]', '$-', '$+', '$private', '$==', '$index_to_loc_format', '$header', '$file', '$read', '$length', '$map!']);
  
  self.$require("ttfunk/table/loca"+ '/../' + "../table");
  return (function($base, $parent_nesting) {
    var $TTFunk, self = $TTFunk = $module($base, 'TTFunk');

    var def = self.$$proto, $nesting = [self].concat($parent_nesting);

    (function($base, $super, $parent_nesting) {
      function $Table(){};
      var self = $Table = $klass($base, $super, 'Table', $Table);

      var def = self.$$proto, $nesting = [self].concat($parent_nesting);

      return (function($base, $super, $parent_nesting) {
        function $Loca(){};
        var self = $Loca = $klass($base, $super, 'Loca', $Loca);

        var def = self.$$proto, $nesting = [self].concat($parent_nesting), TMP_Loca_encode_3, TMP_Loca_index_of_4, TMP_Loca_size_of_5, TMP_Loca_parse$B_7;

        def.offsets = nil;
        
        self.$attr_reader("offsets");
        Opal.defs(self, '$encode', TMP_Loca_encode_3 = function $$encode(offsets) {
          var TMP_1, TMP_2, self = this, long_offsets = nil;

          
          long_offsets = $send(offsets, 'any?', [], (TMP_1 = function(offset){var self = TMP_1.$$s || this, $a, short_offset = nil;
if (offset == null) offset = nil;
          
            short_offset = $rb_divide(offset, 2);
            return ($truthy($a = $rb_times(short_offset, 2)['$!='](offset)) ? $a : $rb_gt(short_offset, 65535));}, TMP_1.$$s = self, TMP_1.$$arity = 1, TMP_1));
          if ($truthy(long_offsets)) {
            return $hash2(["type", "table"], {"type": 1, "table": offsets.$pack("N*")})
            } else {
            return $hash2(["type", "table"], {"type": 0, "table": $send(offsets, 'map', [], (TMP_2 = function(o){var self = TMP_2.$$s || this;
if (o == null) o = nil;
            return $rb_divide(o, 2)}, TMP_2.$$s = self, TMP_2.$$arity = 1, TMP_2)).$pack("n*")})
          };
        }, TMP_Loca_encode_3.$$arity = 1);
        
        Opal.defn(self, '$index_of', TMP_Loca_index_of_4 = function $$index_of(glyph_id) {
          var self = this;

          return self.offsets['$[]'](glyph_id)
        }, TMP_Loca_index_of_4.$$arity = 1);
        
        Opal.defn(self, '$size_of', TMP_Loca_size_of_5 = function $$size_of(glyph_id) {
          var self = this;

          return $rb_minus(self.offsets['$[]']($rb_plus(glyph_id, 1)), self.offsets['$[]'](glyph_id))
        }, TMP_Loca_size_of_5.$$arity = 1);
        self.$private();
        return (Opal.defn(self, '$parse!', TMP_Loca_parse$B_7 = function() {
          var TMP_6, self = this, type = nil;

          
          type = (function() {if (self.$file().$header().$index_to_loc_format()['$=='](0)) {
            return "n"
            } else {
            return "N"
          }; return nil; })();
          self.offsets = self.$read(self.$length(), "" + (type) + "*");
          if (self.$file().$header().$index_to_loc_format()['$=='](0)) {
            return $send(self.offsets, 'map!', [], (TMP_6 = function(v){var self = TMP_6.$$s || this;
if (v == null) v = nil;
            return $rb_times(v, 2)}, TMP_6.$$s = self, TMP_6.$$arity = 1, TMP_6))
            } else {
            return nil
          };
        }, TMP_Loca_parse$B_7.$$arity = 0), nil) && 'parse!';
      })($nesting[0], Opal.const_get_relative($nesting, 'Table'), $nesting)
    })($nesting[0], null, $nesting)
  })($nesting[0], $nesting);
};

/* Generated by Opal 0.11.0 */
Opal.modules["ttfunk/table/maxp"] = function(Opal) {
  function $rb_minus(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs - rhs : lhs['$-'](rhs);
  }
  var self = Opal.top, $nesting = [], nil = Opal.nil, $breaker = Opal.breaker, $slice = Opal.slice, $module = Opal.module, $klass = Opal.klass, $send = Opal.send;

  Opal.add_stubs(['$attr_reader', '$length', '$raw', '$pack', '$[]=', '$-', '$private', '$read']);
  
  self.$require("ttfunk/table/maxp"+ '/../' + "../table");
  return (function($base, $parent_nesting) {
    var $TTFunk, self = $TTFunk = $module($base, 'TTFunk');

    var def = self.$$proto, $nesting = [self].concat($parent_nesting);

    (function($base, $super, $parent_nesting) {
      function $Table(){};
      var self = $Table = $klass($base, $super, 'Table', $Table);

      var def = self.$$proto, $nesting = [self].concat($parent_nesting);

      return (function($base, $super, $parent_nesting) {
        function $Maxp(){};
        var self = $Maxp = $klass($base, $super, 'Maxp', $Maxp);

        var def = self.$$proto, $nesting = [self].concat($parent_nesting), TMP_Maxp_encode_1, TMP_Maxp_parse$B_2;

        
        self.$attr_reader("version");
        self.$attr_reader("num_glyphs");
        self.$attr_reader("max_points");
        self.$attr_reader("max_contours");
        self.$attr_reader("max_component_points");
        self.$attr_reader("max_component_contours");
        self.$attr_reader("max_zones");
        self.$attr_reader("max_twilight_points");
        self.$attr_reader("max_storage");
        self.$attr_reader("max_function_defs");
        self.$attr_reader("max_instruction_defs");
        self.$attr_reader("max_stack_elements");
        self.$attr_reader("max_size_of_instructions");
        self.$attr_reader("max_component_elements");
        self.$attr_reader("max_component_depth");
        Opal.defs(self, '$encode', TMP_Maxp_encode_1 = function $$encode(maxp, mapping) {
          var self = this, num_glyphs = nil, raw = nil, $writer = nil;

          
          num_glyphs = mapping.$length();
          raw = maxp.$raw();
          
          $writer = [4, 2, [num_glyphs].$pack("n")];
          $send(raw, '[]=', Opal.to_a($writer));
          $writer[$rb_minus($writer["length"], 1)];;
          return raw;
        }, TMP_Maxp_encode_1.$$arity = 2);
        self.$private();
        return (Opal.defn(self, '$parse!', TMP_Maxp_parse$B_2 = function() {
          var $a, $b, self = this;

          return $b = self.$read(self.$length(), "Nn*"), $a = Opal.to_ary($b), (self.version = ($a[0] == null ? nil : $a[0])), (self.num_glyphs = ($a[1] == null ? nil : $a[1])), (self.max_points = ($a[2] == null ? nil : $a[2])), (self.max_contours = ($a[3] == null ? nil : $a[3])), (self.max_component_points = ($a[4] == null ? nil : $a[4])), (self.max_component_contours = ($a[5] == null ? nil : $a[5])), (self.max_zones = ($a[6] == null ? nil : $a[6])), (self.max_twilight_points = ($a[7] == null ? nil : $a[7])), (self.max_storage = ($a[8] == null ? nil : $a[8])), (self.max_function_defs = ($a[9] == null ? nil : $a[9])), (self.max_instruction_defs = ($a[10] == null ? nil : $a[10])), (self.max_stack_elements = ($a[11] == null ? nil : $a[11])), (self.max_size_of_instructions = ($a[12] == null ? nil : $a[12])), (self.max_component_elements = ($a[13] == null ? nil : $a[13])), (self.max_component_depth = ($a[14] == null ? nil : $a[14])), $b
        }, TMP_Maxp_parse$B_2.$$arity = 0), nil) && 'parse!';
      })($nesting[0], Opal.const_get_relative($nesting, 'Table'), $nesting)
    })($nesting[0], null, $nesting)
  })($nesting[0], $nesting);
};

/* Generated by Opal 0.11.0 */
Opal.modules["digest/sha1"] = function(Opal) {
  var self = Opal.top, $nesting = [], nil = Opal.nil, $breaker = Opal.breaker, $slice = Opal.slice, $module = Opal.module;

  return (function($base, $parent_nesting) {
    var $Digest, self = $Digest = $module($base, 'Digest');

    var def = self.$$proto, $nesting = [self].concat($parent_nesting);

    (function($base, $parent_nesting) {
      var $SHA1, self = $SHA1 = $module($base, 'SHA1');

      var def = self.$$proto, $nesting = [self].concat($parent_nesting);

      nil
    })($nesting[0], $nesting)
  })($nesting[0], $nesting)
};

/* Generated by Opal 0.11.0 */
Opal.modules["ttfunk/table/name"] = function(Opal) {
  function $rb_minus(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs - rhs : lhs['$-'](rhs);
  }
  function $rb_plus(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs + rhs : lhs['$+'](rhs);
  }
  function $rb_times(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs * rhs : lhs['$*'](rhs);
  }
  var self = Opal.top, $nesting = [], nil = Opal.nil, $breaker = Opal.breaker, $slice = Opal.slice, $module = Opal.module, $klass = Opal.klass, $send = Opal.send, $truthy = Opal.truthy, $hash2 = Opal.hash2;

  Opal.add_stubs(['$require', '$attr_reader', '$gsub', '$empty?', '$[]', '$hexdigest', '$new', '$postscript_name', '$dup', '$strings', '$[]=', '$-', '$inject', '$+', '$length', '$pack', '$*', '$each', '$<<', '$platform_id', '$encoding_id', '$language_id', '$first', '$font_family', '$private', '$read', '$times', '$offset', '$pos=', '$io', '$strip_extended']);
  
  self.$require("ttfunk/table/name"+ '/../' + "../table");
  self.$require("digest/sha1");
  return (function($base, $parent_nesting) {
    var $TTFunk, self = $TTFunk = $module($base, 'TTFunk');

    var def = self.$$proto, $nesting = [self].concat($parent_nesting);

    (function($base, $super, $parent_nesting) {
      function $Table(){};
      var self = $Table = $klass($base, $super, 'Table', $Table);

      var def = self.$$proto, $nesting = [self].concat($parent_nesting);

      return (function($base, $super, $parent_nesting) {
        function $Name(){};
        var self = $Name = $klass($base, $super, 'Name', $Name);

        var def = self.$$proto, $nesting = [self].concat($parent_nesting), TMP_Name_encode_6, TMP_Name_postscript_name_7, TMP_Name_parse$B_11;

        def.postscript_name = def.strings = nil;
        
        (function($base, $super, $parent_nesting) {
          function $String(){};
          var self = $String = $klass($base, $super, 'String', $String);

          var def = self.$$proto, $nesting = [self].concat($parent_nesting), TMP_String_initialize_1, TMP_String_strip_extended_2;

          
          self.$attr_reader("platform_id");
          self.$attr_reader("encoding_id");
          self.$attr_reader("language_id");
          
          Opal.defn(self, '$initialize', TMP_String_initialize_1 = function $$initialize(text, platform_id, encoding_id, language_id) {
            var self = this, $iter = TMP_String_initialize_1.$$p, $yield = $iter || nil;

            if ($iter) TMP_String_initialize_1.$$p = null;
            
            $send(self, Opal.find_super_dispatcher(self, 'initialize', TMP_String_initialize_1, false), [text], null);
            self.platform_id = platform_id;
            self.encoding_id = encoding_id;
            return (self.language_id = language_id);
          }, TMP_String_initialize_1.$$arity = 4);
          return (Opal.defn(self, '$strip_extended', TMP_String_strip_extended_2 = function $$strip_extended() {
            var self = this, stripped = nil;

            
            stripped = self.$gsub(/[\x00-\x19]/, "");
            if ($truthy(stripped['$empty?']())) {
              stripped = "[not-postscript]"};
            return stripped;
          }, TMP_String_strip_extended_2.$$arity = 0), nil) && 'strip_extended';
        })($nesting[0], Opal.const_get_qualified('::', 'String'), $nesting);
        self.$attr_reader("strings");
        self.$attr_reader("copyright");
        self.$attr_reader("font_family");
        self.$attr_reader("font_subfamily");
        self.$attr_reader("unique_subfamily");
        self.$attr_reader("font_name");
        self.$attr_reader("version");
        self.$attr_reader("trademark");
        self.$attr_reader("manufacturer");
        self.$attr_reader("designer");
        self.$attr_reader("description");
        self.$attr_reader("vendor_url");
        self.$attr_reader("designer_url");
        self.$attr_reader("license");
        self.$attr_reader("license_url");
        self.$attr_reader("preferred_family");
        self.$attr_reader("preferred_subfamily");
        self.$attr_reader("compatible_full");
        self.$attr_reader("sample_text");
        Opal.defs(self, '$encode', TMP_Name_encode_6 = function $$encode(names, key) {
          var TMP_3, TMP_4, self = this, tag = nil, postscript_name = nil, strings = nil, $writer = nil, str_count = nil, table = nil, strtable = nil;

          if (key == null) {
            key = "";
          }
          
          tag = Opal.const_get_qualified(Opal.const_get_relative($nesting, 'Digest'), 'SHA1').$hexdigest(key)['$[]'](0, 6);
          postscript_name = Opal.const_get_qualified(Opal.const_get_relative($nesting, 'Name'), 'String').$new("" + (tag) + "+" + (names.$postscript_name()), 1, 0, 0);
          strings = names.$strings().$dup();
          
          $writer = [6, [postscript_name]];
          $send(strings, '[]=', Opal.to_a($writer));
          $writer[$rb_minus($writer["length"], 1)];;
          str_count = $send(strings, 'inject', [0], (TMP_3 = function(sum, $a){var self = TMP_3.$$s || this, $a_args, _, list;

            if ($a == null) {
              $a = nil;
            }
            $a = Opal.to_ary($a);
            $a_args = Opal.slice.call($a, 0, $a.length);
            _ = $a_args.splice(0,1)[0];
            if (_ == null) {
              _ = nil;
            }
            list = $a_args.splice(0,1)[0];
            if (list == null) {
              list = nil;
            }if (sum == null) sum = nil;
          return $rb_plus(sum, list.$length())}, TMP_3.$$s = self, TMP_3.$$arity = 2, TMP_3.$$has_top_level_mlhs_arg = true, TMP_3));
          table = [0, str_count, $rb_plus(6, $rb_times(12, str_count))].$pack("n*");
          strtable = "";
          $send(strings, 'each', [], (TMP_4 = function(id, list){var self = TMP_4.$$s || this, TMP_5;
if (id == null) id = nil;if (list == null) list = nil;
          return $send(list, 'each', [], (TMP_5 = function(string){var self = TMP_5.$$s || this;
if (string == null) string = nil;
            
              table['$<<']([string.$platform_id(), string.$encoding_id(), string.$language_id(), id, string.$length(), strtable.$length()].$pack("n*"));
              return strtable['$<<'](string);}, TMP_5.$$s = self, TMP_5.$$arity = 1, TMP_5))}, TMP_4.$$s = self, TMP_4.$$arity = 2, TMP_4));
          return table['$<<'](strtable);
        }, TMP_Name_encode_6.$$arity = -2);
        
        Opal.defn(self, '$postscript_name', TMP_Name_postscript_name_7 = function $$postscript_name() {
          var $a, self = this;

          
          if ($truthy(self.postscript_name)) {
            return self.postscript_name};
          return ($truthy($a = self.$font_family().$first()) ? $a : "unnamed");
        }, TMP_Name_postscript_name_7.$$arity = 0);
        self.$private();
        return (Opal.defn(self, '$parse!', TMP_Name_parse$B_11 = function() {
          var $a, $b, TMP_8, TMP_9, TMP_10, self = this, count = nil, string_offset = nil, entries = nil;

          
          $b = self.$read(6, "x2n*"), $a = Opal.to_ary($b), (count = ($a[0] == null ? nil : $a[0])), (string_offset = ($a[1] == null ? nil : $a[1])), $b;
          entries = [];
          $send(count, 'times', [], (TMP_8 = function(){var self = TMP_8.$$s || this, $c, $d, platform = nil, encoding = nil, language = nil, id = nil, length = nil, start_offset = nil;

          
            $d = self.$read(12, "n*"), $c = Opal.to_ary($d), (platform = ($c[0] == null ? nil : $c[0])), (encoding = ($c[1] == null ? nil : $c[1])), (language = ($c[2] == null ? nil : $c[2])), (id = ($c[3] == null ? nil : $c[3])), (length = ($c[4] == null ? nil : $c[4])), (start_offset = ($c[5] == null ? nil : $c[5])), $d;
            return entries['$<<']($hash2(["platform_id", "encoding_id", "language_id", "name_id", "length", "offset"], {"platform_id": platform, "encoding_id": encoding, "language_id": language, "name_id": id, "length": length, "offset": $rb_plus($rb_plus(self.$offset(), string_offset), start_offset)}));}, TMP_8.$$s = self, TMP_8.$$arity = 0, TMP_8));
          self.strings = $send(Opal.const_get_relative($nesting, 'Hash'), 'new', [], (TMP_9 = function(h, k){var self = TMP_9.$$s || this, $writer = nil;
if (h == null) h = nil;if (k == null) k = nil;
          
            $writer = [k, []];
            $send(h, '[]=', Opal.to_a($writer));
            return $writer[$rb_minus($writer["length"], 1)];}, TMP_9.$$s = self, TMP_9.$$arity = 2, TMP_9));
          $send(count, 'times', [], (TMP_10 = function(i){var self = TMP_10.$$s || this, $writer = nil, text = nil;
            if (self.strings == null) self.strings = nil;
if (i == null) i = nil;
          
            
            $writer = [entries['$[]'](i)['$[]']("offset")];
            $send(self.$io(), 'pos=', Opal.to_a($writer));
            $writer[$rb_minus($writer["length"], 1)];;
            text = self.$io().$read(entries['$[]'](i)['$[]']("length"));
            return self.strings['$[]'](entries['$[]'](i)['$[]']("name_id"))['$<<'](Opal.const_get_qualified(Opal.const_get_relative($nesting, 'Name'), 'String').$new(text, entries['$[]'](i)['$[]']("platform_id"), entries['$[]'](i)['$[]']("encoding_id"), entries['$[]'](i)['$[]']("language_id")));}, TMP_10.$$s = self, TMP_10.$$arity = 1, TMP_10));
          self.copyright = self.strings['$[]'](0);
          self.font_family = self.strings['$[]'](1);
          self.font_subfamily = self.strings['$[]'](2);
          self.unique_subfamily = self.strings['$[]'](3);
          self.font_name = self.strings['$[]'](4);
          self.version = self.strings['$[]'](5);
          self.postscript_name = self.strings['$[]'](6).$first().$strip_extended();
          self.trademark = self.strings['$[]'](7);
          self.manufacturer = self.strings['$[]'](8);
          self.designer = self.strings['$[]'](9);
          self.description = self.strings['$[]'](10);
          self.vendor_url = self.strings['$[]'](11);
          self.designer_url = self.strings['$[]'](12);
          self.license = self.strings['$[]'](13);
          self.license_url = self.strings['$[]'](14);
          self.preferred_family = self.strings['$[]'](16);
          self.preferred_subfamily = self.strings['$[]'](17);
          self.compatible_full = self.strings['$[]'](18);
          return (self.sample_text = self.strings['$[]'](19));
        }, TMP_Name_parse$B_11.$$arity = 0), nil) && 'parse!';
      })($nesting[0], Opal.const_get_relative($nesting, 'Table'), $nesting)
    })($nesting[0], null, $nesting)
  })($nesting[0], $nesting);
};

/* Generated by Opal 0.11.0 */
Opal.modules["ttfunk/table/os2"] = function(Opal) {
  function $rb_gt(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs > rhs : lhs['$>'](rhs);
  }
  var self = Opal.top, $nesting = [], nil = Opal.nil, $breaker = Opal.breaker, $slice = Opal.slice, $module = Opal.module, $klass = Opal.klass, $truthy = Opal.truthy;

  Opal.add_stubs(['$attr_reader', '$private', '$first', '$read', '$read_signed', '$io', '$>']);
  
  self.$require("ttfunk/table/os2"+ '/../' + "../table");
  return (function($base, $parent_nesting) {
    var $TTFunk, self = $TTFunk = $module($base, 'TTFunk');

    var def = self.$$proto, $nesting = [self].concat($parent_nesting);

    (function($base, $super, $parent_nesting) {
      function $Table(){};
      var self = $Table = $klass($base, $super, 'Table', $Table);

      var def = self.$$proto, $nesting = [self].concat($parent_nesting);

      return (function($base, $super, $parent_nesting) {
        function $OS2(){};
        var self = $OS2 = $klass($base, $super, 'OS2', $OS2);

        var def = self.$$proto, $nesting = [self].concat($parent_nesting), TMP_OS2_tag_1, TMP_OS2_parse$B_2;

        def.version = nil;
        
        self.$attr_reader("version");
        self.$attr_reader("ave_char_width");
        self.$attr_reader("weight_class");
        self.$attr_reader("width_class");
        self.$attr_reader("type");
        self.$attr_reader("y_subscript_x_size");
        self.$attr_reader("y_subscript_y_size");
        self.$attr_reader("y_subscript_x_offset");
        self.$attr_reader("y_subscript_y_offset");
        self.$attr_reader("y_superscript_x_size");
        self.$attr_reader("y_superscript_y_size");
        self.$attr_reader("y_superscript_x_offset");
        self.$attr_reader("y_superscript_y_offset");
        self.$attr_reader("y_strikeout_size");
        self.$attr_reader("y_strikeout_position");
        self.$attr_reader("family_class");
        self.$attr_reader("panose");
        self.$attr_reader("char_range");
        self.$attr_reader("vendor_id");
        self.$attr_reader("selection");
        self.$attr_reader("first_char_index");
        self.$attr_reader("last_char_index");
        self.$attr_reader("ascent");
        self.$attr_reader("descent");
        self.$attr_reader("line_gap");
        self.$attr_reader("win_ascent");
        self.$attr_reader("win_descent");
        self.$attr_reader("code_page_range");
        self.$attr_reader("x_height");
        self.$attr_reader("cap_height");
        self.$attr_reader("default_char");
        self.$attr_reader("break_char");
        self.$attr_reader("max_context");
        
        Opal.defn(self, '$tag', TMP_OS2_tag_1 = function $$tag() {
          var self = this;

          return "OS/2"
        }, TMP_OS2_tag_1.$$arity = 0);
        self.$private();
        return (Opal.defn(self, '$parse!', TMP_OS2_parse$B_2 = function() {
          var $a, $b, self = this;

          
          self.version = self.$read(2, "n").$first();
          self.ave_char_width = self.$read_signed(1);
          $b = self.$read(4, "nn"), $a = Opal.to_ary($b), (self.weight_class = ($a[0] == null ? nil : $a[0])), (self.width_class = ($a[1] == null ? nil : $a[1])), $b;
          $b = self.$read_signed(12), $a = Opal.to_ary($b), (self.type = ($a[0] == null ? nil : $a[0])), (self.y_subscript_x_size = ($a[1] == null ? nil : $a[1])), (self.y_subscript_y_size = ($a[2] == null ? nil : $a[2])), (self.y_subscript_x_offset = ($a[3] == null ? nil : $a[3])), (self.y_subscript_y_offset = ($a[4] == null ? nil : $a[4])), (self.y_superscript_x_size = ($a[5] == null ? nil : $a[5])), (self.y_superscript_y_size = ($a[6] == null ? nil : $a[6])), (self.y_superscript_x_offset = ($a[7] == null ? nil : $a[7])), (self.y_superscript_y_offset = ($a[8] == null ? nil : $a[8])), (self.y_strikeout_size = ($a[9] == null ? nil : $a[9])), (self.y_strikeout_position = ($a[10] == null ? nil : $a[10])), (self.family_class = ($a[11] == null ? nil : $a[11])), $b;
          self.panose = self.$io().$read(10);
          self.char_range = self.$io().$read(16);
          self.vendor_id = self.$io().$read(4);
          $b = self.$read(6, "n*"), $a = Opal.to_ary($b), (self.selection = ($a[0] == null ? nil : $a[0])), (self.first_char_index = ($a[1] == null ? nil : $a[1])), (self.last_char_index = ($a[2] == null ? nil : $a[2])), $b;
          if ($truthy($rb_gt(self.version, 0))) {
            
            $b = self.$read_signed(3), $a = Opal.to_ary($b), (self.ascent = ($a[0] == null ? nil : $a[0])), (self.descent = ($a[1] == null ? nil : $a[1])), (self.line_gap = ($a[2] == null ? nil : $a[2])), $b;
            $b = self.$read(4, "nn"), $a = Opal.to_ary($b), (self.win_ascent = ($a[0] == null ? nil : $a[0])), (self.win_descent = ($a[1] == null ? nil : $a[1])), $b;
            self.code_page_range = self.$io().$read(8);
            if ($truthy($rb_gt(self.version, 1))) {
              
              $b = self.$read_signed(2), $a = Opal.to_ary($b), (self.x_height = ($a[0] == null ? nil : $a[0])), (self.cap_height = ($a[1] == null ? nil : $a[1])), $b;
              return $b = self.$read(6, "nnn"), $a = Opal.to_ary($b), (self.default_char = ($a[0] == null ? nil : $a[0])), (self.break_char = ($a[1] == null ? nil : $a[1])), (self.max_context = ($a[2] == null ? nil : $a[2])), $b;
              } else {
              return nil
            };
            } else {
            return nil
          };
        }, TMP_OS2_parse$B_2.$$arity = 0), nil) && 'parse!';
      })($nesting[0], Opal.const_get_relative($nesting, 'Table'), $nesting)
    })($nesting[0], null, $nesting)
  })($nesting[0], $nesting);
};

/* Generated by Opal 0.11.0 */
Opal.modules["ttfunk/table/post/format10"] = function(Opal) {
  var self = Opal.top, $nesting = [], nil = Opal.nil, $breaker = Opal.breaker, $slice = Opal.slice, $module = Opal.module, $klass = Opal.klass, $truthy = Opal.truthy;

  Opal.add_stubs(['$freeze', '$[]', '$private']);
  return (function($base, $parent_nesting) {
    var $TTFunk, self = $TTFunk = $module($base, 'TTFunk');

    var def = self.$$proto, $nesting = [self].concat($parent_nesting);

    (function($base, $super, $parent_nesting) {
      function $Table(){};
      var self = $Table = $klass($base, $super, 'Table', $Table);

      var def = self.$$proto, $nesting = [self].concat($parent_nesting);

      return (function($base, $super, $parent_nesting) {
        function $Post(){};
        var self = $Post = $klass($base, $super, 'Post', $Post);

        var def = self.$$proto, $nesting = [self].concat($parent_nesting);

        return (function($base, $parent_nesting) {
          var $Format10, self = $Format10 = $module($base, 'Format10');

          var def = self.$$proto, $nesting = [self].concat($parent_nesting), TMP_Format10_glyph_for_1, TMP_Format10_parse_format$B_2;

          
          Opal.const_set($nesting[0], 'POSTSCRIPT_GLYPHS', [".notdef", ".null", "nonmarkingreturn", "space", "exclam", "quotedbl", "numbersign", "dollar", "percent", "ampersand", "quotesingle", "parenleft", "parenright", "asterisk", "plus", "comma", "hyphen", "period", "slash", "zero", "one", "two", "three", "four", "five", "six", "seven", "eight", "nine", "colon", "semicolon", "less", "equal", "greater", "question", "at", "A", "B", "C", "D", "E", "F", "G", "H", "I", "J", "K", "L", "M", "N", "O", "P", "Q", "R", "S", "T", "U", "V", "W", "X", "Y", "Z", "bracketleft", "backslash", "bracketright", "asciicircum", "underscore", "grave", "a", "b", "c", "d", "e", "f", "g", "h", "i", "j", "k", "l", "m", "n", "o", "p", "q", "r", "s", "t", "u", "v", "w", "x", "y", "z", "braceleft", "bar", "braceright", "asciitilde", "Adieresis", "Aring", "Ccedilla", "Eacute", "Ntilde", "Odieresis", "Udieresis", "aacute", "agrave", "acircumflex", "adieresis", "atilde", "aring", "ccedilla", "eacute", "egrave", "ecircumflex", "edieresis", "iacute", "igrave", "icircumflex", "idieresis", "ntilde", "oacute", "ograve", "ocircumflex", "odieresis", "otilde", "uacute", "ugrave", "ucircumflex", "udieresis", "dagger", "degree", "cent", "sterling", "section", "bullet", "paragraph", "germandbls", "registered", "copyright", "trademark", "acute", "dieresis", "notequal", "AE", "Oslash", "infinity", "plusminus", "lessequal", "greaterequal", "yen", "mu", "partialdiff", "summation", "product", "pi", "integral", "ordfeminine", "ordmasculine", "Omega", "ae", "oslash", "questiondown", "exclamdown", "logicalnot", "radical", "florin", "approxequal", "Delta", "guillemotleft", "guillemotright", "ellipsis", "nonbreakingspace", "Agrave", "Atilde", "Otilde", "OE", "oe", "endash", "emdash", "quotedblleft", "quotedblright", "quoteleft", "quoteright", "divide", "lozenge", "ydieresis", "Ydieresis", "fraction", "currency", "guilsinglleft", "guilsinglright", "fi", "fl", "daggerdbl", "periodcentered", "quotesinglbase", "quotedblbase", "perthousand", "Acircumflex", "Ecircumflex", "Aacute", "Edieresis", "Egrave", "Iacute", "Icircumflex", "Idieresis", "Igrave", "Oacute", "Ocircumflex", "apple", "Ograve", "Uacute", "Ucircumflex", "Ugrave", "dotlessi", "circumflex", "tilde", "macron", "breve", "dotaccent", "ring", "cedilla", "hungarumlaut", "ogonek", "caron", "Lslash", "lslash", "Scaron", "scaron", "Zcaron", "zcaron", "brokenbar", "Eth", "eth", "Yacute", "yacute", "Thorn", "thorn", "minus", "multiply", "onesuperior", "twosuperior", "threesuperior", "onehalf", "onequarter", "threequarters", "franc", "Gbreve", "gbreve", "Idotaccent", "Scedilla", "scedilla", "Cacute", "cacute", "Ccaron", "ccaron", "dcroat"].$freeze());
          
          Opal.defn(self, '$glyph_for', TMP_Format10_glyph_for_1 = function $$glyph_for(code) {
            var $a, self = this;

            return ($truthy($a = Opal.const_get_relative($nesting, 'POSTSCRIPT_GLYPHS')['$[]'](code)) ? $a : ".notdef")
          }, TMP_Format10_glyph_for_1.$$arity = 1);
          self.$private();
          
          Opal.defn(self, '$parse_format!', TMP_Format10_parse_format$B_2 = function() {
            var self = this;

            return nil
          }, TMP_Format10_parse_format$B_2.$$arity = 0);
        })($nesting[0], $nesting)
      })($nesting[0], null, $nesting)
    })($nesting[0], null, $nesting)
  })($nesting[0], $nesting)
};

/* Generated by Opal 0.11.0 */
Opal.modules["ttfunk/table/post/format20"] = function(Opal) {
  function $rb_le(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs <= rhs : lhs['$<='](rhs);
  }
  function $rb_minus(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs - rhs : lhs['$-'](rhs);
  }
  function $rb_times(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs * rhs : lhs['$*'](rhs);
  }
  function $rb_plus(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs + rhs : lhs['$+'](rhs);
  }
  var self = Opal.top, $nesting = [], nil = Opal.nil, $breaker = Opal.breaker, $slice = Opal.slice, $module = Opal.module, $klass = Opal.klass, $truthy = Opal.truthy;

  Opal.add_stubs(['$require', '$include', '$[]', '$<=', '$-', '$private', '$first', '$read', '$*', '$new', '$io', '$+', '$offset', '$length', '$pos', '$eof?', '$unpack', '$<<']);
  
  self.$require("ttfunk/table/post/format20"+ '/../' + "format10");
  self.$require("stringio");
  return (function($base, $parent_nesting) {
    var $TTFunk, self = $TTFunk = $module($base, 'TTFunk');

    var def = self.$$proto, $nesting = [self].concat($parent_nesting);

    (function($base, $super, $parent_nesting) {
      function $Table(){};
      var self = $Table = $klass($base, $super, 'Table', $Table);

      var def = self.$$proto, $nesting = [self].concat($parent_nesting);

      return (function($base, $super, $parent_nesting) {
        function $Post(){};
        var self = $Post = $klass($base, $super, 'Post', $Post);

        var def = self.$$proto, $nesting = [self].concat($parent_nesting);

        return (function($base, $parent_nesting) {
          var $Format20, self = $Format20 = $module($base, 'Format20');

          var def = self.$$proto, $nesting = [self].concat($parent_nesting), TMP_Format20_glyph_for_1, TMP_Format20_parse_format$B_2;

          
          self.$include(Opal.const_get_relative($nesting, 'Format10'));
          
          Opal.defn(self, '$glyph_for', TMP_Format20_glyph_for_1 = function $$glyph_for(code) {
            var $a, self = this, index = nil;
            if (self.glyph_name_index == null) self.glyph_name_index = nil;
            if (self.names == null) self.names = nil;

            
            index = self.glyph_name_index['$[]'](code);
            if ($truthy($rb_le(index, 257))) {
              return Opal.const_get_relative($nesting, 'POSTSCRIPT_GLYPHS')['$[]'](index)
              } else {
              return ($truthy($a = self.names['$[]']($rb_minus(index, 258))) ? $a : ".notdef")
            };
          }, TMP_Format20_glyph_for_1.$$arity = 1);
          self.$private();
          
          Opal.defn(self, '$parse_format!', TMP_Format20_parse_format$B_2 = function() {
            var $a, self = this, number_of_glyphs = nil, strings = nil, length = nil;
            if (self.names == null) self.names = nil;

            
            number_of_glyphs = self.$read(2, "n").$first();
            self.glyph_name_index = self.$read($rb_times(number_of_glyphs, 2), "n*");
            self.names = [];
            strings = Opal.const_get_relative($nesting, 'StringIO').$new(self.$io().$read($rb_minus($rb_plus(self.$offset(), self.$length()), self.$io().$pos())));
            while (!($truthy(strings['$eof?']()))) {
              
              length = strings.$read(1).$unpack("C").$first();
              self.names['$<<'](strings.$read(length));
            };
          }, TMP_Format20_parse_format$B_2.$$arity = 0);
        })($nesting[0], $nesting)
      })($nesting[0], null, $nesting)
    })($nesting[0], null, $nesting)
  })($nesting[0], $nesting);
};

/* Generated by Opal 0.11.0 */
Opal.modules["ttfunk/table/post/format30"] = function(Opal) {
  var self = Opal.top, $nesting = [], nil = Opal.nil, $breaker = Opal.breaker, $slice = Opal.slice, $module = Opal.module, $klass = Opal.klass;

  Opal.add_stubs(['$private']);
  return (function($base, $parent_nesting) {
    var $TTFunk, self = $TTFunk = $module($base, 'TTFunk');

    var def = self.$$proto, $nesting = [self].concat($parent_nesting);

    (function($base, $super, $parent_nesting) {
      function $Table(){};
      var self = $Table = $klass($base, $super, 'Table', $Table);

      var def = self.$$proto, $nesting = [self].concat($parent_nesting);

      return (function($base, $super, $parent_nesting) {
        function $Post(){};
        var self = $Post = $klass($base, $super, 'Post', $Post);

        var def = self.$$proto, $nesting = [self].concat($parent_nesting);

        return (function($base, $parent_nesting) {
          var $Format30, self = $Format30 = $module($base, 'Format30');

          var def = self.$$proto, $nesting = [self].concat($parent_nesting), TMP_Format30_glyph_for_1, TMP_Format30_parse_format$B_2;

          
          
          Opal.defn(self, '$glyph_for', TMP_Format30_glyph_for_1 = function $$glyph_for(_code) {
            var self = this;

            return ".notdef"
          }, TMP_Format30_glyph_for_1.$$arity = 1);
          self.$private();
          
          Opal.defn(self, '$parse_format!', TMP_Format30_parse_format$B_2 = function() {
            var self = this;

            return nil
          }, TMP_Format30_parse_format$B_2.$$arity = 0);
        })($nesting[0], $nesting)
      })($nesting[0], null, $nesting)
    })($nesting[0], null, $nesting)
  })($nesting[0], $nesting)
};

/* Generated by Opal 0.11.0 */
Opal.modules["ttfunk/table/post/format40"] = function(Opal) {
  function $rb_times(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs * rhs : lhs['$*'](rhs);
  }
  var self = Opal.top, $nesting = [], nil = Opal.nil, $breaker = Opal.breaker, $slice = Opal.slice, $module = Opal.module, $klass = Opal.klass, $truthy = Opal.truthy;

  Opal.add_stubs(['$[]', '$private', '$read', '$*', '$num_glyphs', '$maximum_profile', '$file']);
  return (function($base, $parent_nesting) {
    var $TTFunk, self = $TTFunk = $module($base, 'TTFunk');

    var def = self.$$proto, $nesting = [self].concat($parent_nesting);

    (function($base, $super, $parent_nesting) {
      function $Table(){};
      var self = $Table = $klass($base, $super, 'Table', $Table);

      var def = self.$$proto, $nesting = [self].concat($parent_nesting);

      return (function($base, $super, $parent_nesting) {
        function $Post(){};
        var self = $Post = $klass($base, $super, 'Post', $Post);

        var def = self.$$proto, $nesting = [self].concat($parent_nesting);

        return (function($base, $parent_nesting) {
          var $Format40, self = $Format40 = $module($base, 'Format40');

          var def = self.$$proto, $nesting = [self].concat($parent_nesting), TMP_Format40_glyph_for_1, TMP_Format40_parse_format$B_2;

          
          
          Opal.defn(self, '$glyph_for', TMP_Format40_glyph_for_1 = function $$glyph_for(code) {
            var $a, self = this;
            if (self.map == null) self.map = nil;

            return ($truthy($a = self.map['$[]'](code)) ? $a : 65535)
          }, TMP_Format40_glyph_for_1.$$arity = 1);
          self.$private();
          
          Opal.defn(self, '$parse_format!', TMP_Format40_parse_format$B_2 = function() {
            var self = this;

            return (self.map = self.$read($rb_times(self.$file().$maximum_profile().$num_glyphs(), 2), "N*"))
          }, TMP_Format40_parse_format$B_2.$$arity = 0);
        })($nesting[0], $nesting)
      })($nesting[0], null, $nesting)
    })($nesting[0], null, $nesting)
  })($nesting[0], $nesting)
};

/* Generated by Opal 0.11.0 */
Opal.modules["ttfunk/table/post"] = function(Opal) {
  function $rb_minus(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs - rhs : lhs['$-'](rhs);
  }
  function $rb_plus(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs + rhs : lhs['$+'](rhs);
  }
  var self = Opal.top, $nesting = [], nil = Opal.nil, $breaker = Opal.breaker, $slice = Opal.slice, $module = Opal.module, $klass = Opal.klass, $truthy = Opal.truthy, $send = Opal.send;

  Opal.add_stubs(['$attr_reader', '$exists?', '$recode', '$!=', '$==', '$format', '$raw', '$[]', '$pack', '$[]=', '$-', '$each', '$sort', '$keys', '$glyph_for', '$index', '$<<', '$+', '$length', '$private', '$read', '$===', '$extend', '$raise', '$parse_format!', '$warn']);
  
  self.$require("ttfunk/table/post"+ '/../' + "../table");
  (function($base, $parent_nesting) {
    var $TTFunk, self = $TTFunk = $module($base, 'TTFunk');

    var def = self.$$proto, $nesting = [self].concat($parent_nesting);

    (function($base, $super, $parent_nesting) {
      function $Table(){};
      var self = $Table = $klass($base, $super, 'Table', $Table);

      var def = self.$$proto, $nesting = [self].concat($parent_nesting);

      return (function($base, $super, $parent_nesting) {
        function $Post(){};
        var self = $Post = $klass($base, $super, 'Post', $Post);

        var def = self.$$proto, $nesting = [self].concat($parent_nesting), TMP_Post_encode_1, TMP_Post_fixed_pitch$q_2, TMP_Post_glyph_for_3, TMP_Post_recode_6, TMP_Post_parse$B_7, TMP_Post_parse_format$B_8;

        def.fixed_pitch = def.format = nil;
        
        self.$attr_reader("format");
        self.$attr_reader("italic_angle");
        self.$attr_reader("underline_position");
        self.$attr_reader("underline_thickness");
        self.$attr_reader("fixed_pitch");
        self.$attr_reader("min_mem_type42");
        self.$attr_reader("max_mem_type42");
        self.$attr_reader("min_mem_type1");
        self.$attr_reader("max_mem_type1");
        self.$attr_reader("subtable");
        Opal.defs(self, '$encode', TMP_Post_encode_1 = function $$encode(post, mapping) {
          var self = this;

          
          if ($truthy(post['$exists?']())) {
            } else {
            return nil
          };
          return post.$recode(mapping);
        }, TMP_Post_encode_1.$$arity = 2);
        
        Opal.defn(self, '$fixed_pitch?', TMP_Post_fixed_pitch$q_2 = function() {
          var self = this;

          return self.fixed_pitch['$!='](0)
        }, TMP_Post_fixed_pitch$q_2.$$arity = 0);
        
        Opal.defn(self, '$glyph_for', TMP_Post_glyph_for_3 = function $$glyph_for(_code) {
          var self = this;

          return ".notdef"
        }, TMP_Post_glyph_for_3.$$arity = 1);
        
        Opal.defn(self, '$recode', TMP_Post_recode_6 = function $$recode(mapping) {
          var TMP_4, TMP_5, self = this, table = nil, $writer = nil, index = nil, strings = nil;

          
          if (self.$format()['$=='](196608)) {
            return self.$raw()};
          table = self.$raw()['$[]'](0, 32);
          
          $writer = [0, 4, [131072].$pack("N")];
          $send(table, '[]=', Opal.to_a($writer));
          $writer[$rb_minus($writer["length"], 1)];;
          index = [];
          strings = [];
          $send(mapping.$keys().$sort(), 'each', [], (TMP_4 = function(new_id){var self = TMP_4.$$s || this, post_glyph = nil, position = nil;
if (new_id == null) new_id = nil;
          
            post_glyph = self.$glyph_for(mapping['$[]'](new_id));
            position = Opal.const_get_qualified(Opal.const_get_relative($nesting, 'Format10'), 'POSTSCRIPT_GLYPHS').$index(post_glyph);
            if ($truthy(position)) {
              return index['$<<'](position)
              } else {
              
              index['$<<']($rb_plus(257, strings.$length()));
              return strings['$<<'](post_glyph);
            };}, TMP_4.$$s = self, TMP_4.$$arity = 1, TMP_4));
          table['$<<']([mapping.$length()].concat(Opal.to_a(index)).$pack("n*"));
          $send(strings, 'each', [], (TMP_5 = function(string){var self = TMP_5.$$s || this;
if (string == null) string = nil;
          return table['$<<']([string.$length(), string].$pack("CA*"))}, TMP_5.$$s = self, TMP_5.$$arity = 1, TMP_5));
          return table;
        }, TMP_Post_recode_6.$$arity = 1);
        self.$private();
        
        Opal.defn(self, '$parse!', TMP_Post_parse$B_7 = function() {
          var $a, $b, self = this, $case = nil;

          
          $b = self.$read(32, "N2n2N*"), $a = Opal.to_ary($b), (self.format = ($a[0] == null ? nil : $a[0])), (self.italic_angle = ($a[1] == null ? nil : $a[1])), (self.underline_position = ($a[2] == null ? nil : $a[2])), (self.underline_thickness = ($a[3] == null ? nil : $a[3])), (self.fixed_pitch = ($a[4] == null ? nil : $a[4])), (self.min_mem_type42 = ($a[5] == null ? nil : $a[5])), (self.max_mem_type42 = ($a[6] == null ? nil : $a[6])), (self.min_mem_type1 = ($a[7] == null ? nil : $a[7])), (self.max_mem_type1 = ($a[8] == null ? nil : $a[8])), $b;
          self.subtable = (function() {$case = self.format;
          if ((65536)['$===']($case)) {return self.$extend(Opal.const_get_qualified(Opal.const_get_relative($nesting, 'Post'), 'Format10'))}
          else if ((131072)['$===']($case)) {return self.$extend(Opal.const_get_qualified(Opal.const_get_relative($nesting, 'Post'), 'Format20'))}
          else if ((151552)['$===']($case)) {return self.$raise(Opal.const_get_relative($nesting, 'NotImplementedError'), "Post format 2.5 is not supported by TTFunk")}
          else if ((196608)['$===']($case)) {return self.$extend(Opal.const_get_qualified(Opal.const_get_relative($nesting, 'Post'), 'Format30'))}
          else if ((262144)['$===']($case)) {return self.$extend(Opal.const_get_qualified(Opal.const_get_relative($nesting, 'Post'), 'Format40'))}
          else { return nil }})();
          return self['$parse_format!']();
        }, TMP_Post_parse$B_7.$$arity = 0);
        return (Opal.defn(self, '$parse_format!', TMP_Post_parse_format$B_8 = function() {
          var self = this;

          return self.$warn(self.$format("postscript table format 0x%08X is not supported", self.format))
        }, TMP_Post_parse_format$B_8.$$arity = 0), nil) && 'parse_format!';
      })($nesting[0], Opal.const_get_relative($nesting, 'Table'), $nesting)
    })($nesting[0], null, $nesting)
  })($nesting[0], $nesting);
  self.$require("ttfunk/table/post"+ '/../' + "post/format10");
  self.$require("ttfunk/table/post"+ '/../' + "post/format20");
  self.$require("ttfunk/table/post"+ '/../' + "post/format30");
  return self.$require("ttfunk/table/post"+ '/../' + "post/format40");
};

/* Generated by Opal 0.11.0 */
Opal.modules["ttfunk/table/sbix"] = function(Opal) {
  function $rb_plus(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs + rhs : lhs['$+'](rhs);
  }
  function $rb_minus(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs - rhs : lhs['$-'](rhs);
  }
  function $rb_gt(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs > rhs : lhs['$>'](rhs);
  }
  var self = Opal.top, $nesting = [], nil = Opal.nil, $breaker = Opal.breaker, $slice = Opal.slice, $module = Opal.module, $klass = Opal.klass, $truthy = Opal.truthy, $send = Opal.send, $hash2 = Opal.hash2;

  Opal.add_stubs(['$attr_reader', '$new', '$[]', '$strikes', '$nil?', '$+', '$-', '$>', '$parse_from', '$offset', '$read', '$io', '$compact', '$map', '$each_index', '$bitmap_data_for', '$private', '$num_strikes', '$first', '$num_glyphs', '$maximum_profile', '$file']);
  
  self.$require("ttfunk/table/sbix"+ '/../' + "../table");
  return (function($base, $parent_nesting) {
    var $TTFunk, self = $TTFunk = $module($base, 'TTFunk');

    var def = self.$$proto, $nesting = [self].concat($parent_nesting);

    (function($base, $super, $parent_nesting) {
      function $Table(){};
      var self = $Table = $klass($base, $super, 'Table', $Table);

      var def = self.$$proto, $nesting = [self].concat($parent_nesting);

      return (function($base, $super, $parent_nesting) {
        function $Sbix(){};
        var self = $Sbix = $klass($base, $super, 'Sbix', $Sbix);

        var def = self.$$proto, $nesting = [self].concat($parent_nesting), TMP_Sbix_bitmap_data_for_2, TMP_Sbix_all_bitmap_data_for_4, TMP_Sbix_parse$B_9;

        
        self.$attr_reader("version");
        self.$attr_reader("flags");
        self.$attr_reader("num_strikes");
        self.$attr_reader("strikes");
        Opal.const_set($nesting[0], 'BitmapData', Opal.const_get_relative($nesting, 'Struct').$new("x", "y", "type", "data", "ppem", "resolution"));
        
        Opal.defn(self, '$bitmap_data_for', TMP_Sbix_bitmap_data_for_2 = function $$bitmap_data_for(glyph_id, strike_index) {
          var $a, TMP_1, self = this, strike = nil, glyph_offset = nil, next_glyph_offset = nil, bytes = nil;

          
          strike = self.$strikes()['$[]'](strike_index);
          if ($truthy(strike['$nil?']())) {
            return nil};
          glyph_offset = strike['$[]']("glyph_data_offset")['$[]'](glyph_id);
          next_glyph_offset = strike['$[]']("glyph_data_offset")['$[]']($rb_plus(glyph_id, 1));
          if ($truthy(($truthy($a = glyph_offset) ? next_glyph_offset : $a))) {
            
            bytes = $rb_minus(next_glyph_offset, glyph_offset);
            if ($truthy($rb_gt(bytes, 0))) {
              return $send(self, 'parse_from', [$rb_plus($rb_plus(self.$offset(), strike['$[]']("offset")), glyph_offset)], (TMP_1 = function(){var self = TMP_1.$$s || this, $b, $c, x = nil, y = nil, type = nil, data = nil;

              
                $c = self.$read(8, "s2A4"), $b = Opal.to_ary($c), (x = ($b[0] == null ? nil : $b[0])), (y = ($b[1] == null ? nil : $b[1])), (type = ($b[2] == null ? nil : $b[2])), $c;
                data = Opal.const_get_relative($nesting, 'StringIO').$new(self.$io().$read($rb_minus(bytes, 8)));
                return Opal.const_get_relative($nesting, 'BitmapData').$new(x, y, type, data, strike['$[]']("ppem"), strike['$[]']("resolution"));}, TMP_1.$$s = self, TMP_1.$$arity = 0, TMP_1))
              } else {
              return nil
            };
            } else {
            return nil
          };
        }, TMP_Sbix_bitmap_data_for_2.$$arity = 2);
        
        Opal.defn(self, '$all_bitmap_data_for', TMP_Sbix_all_bitmap_data_for_4 = function $$all_bitmap_data_for(glyph_id) {
          var TMP_3, self = this;

          return $send(self.$strikes().$each_index(), 'map', [], (TMP_3 = function(strike_index){var self = TMP_3.$$s || this;
if (strike_index == null) strike_index = nil;
          return self.$bitmap_data_for(glyph_id, strike_index)}, TMP_3.$$s = self, TMP_3.$$arity = 1, TMP_3)).$compact()
        }, TMP_Sbix_all_bitmap_data_for_4.$$arity = 1);
        self.$private();
        return (Opal.defn(self, '$parse!', TMP_Sbix_parse$B_9 = function() {
          var $a, $b, TMP_5, TMP_6, self = this, strike_offsets = nil;

          
          $b = self.$read(8, "n2N"), $a = Opal.to_ary($b), (self.version = ($a[0] == null ? nil : $a[0])), (self.flags = ($a[1] == null ? nil : $a[1])), (self.num_strikes = ($a[2] == null ? nil : $a[2])), $b;
          strike_offsets = $send(Opal.const_get_relative($nesting, 'Array'), 'new', [self.$num_strikes()], (TMP_5 = function(){var self = TMP_5.$$s || this;

          return self.$read(4, "N").$first()}, TMP_5.$$s = self, TMP_5.$$arity = 0, TMP_5));
          return (self.strikes = $send(strike_offsets, 'map', [], (TMP_6 = function(strike_offset){var self = TMP_6.$$s || this, TMP_7;
if (strike_offset == null) strike_offset = nil;
          return $send(self, 'parse_from', [$rb_plus(self.$offset(), strike_offset)], (TMP_7 = function(){var self = TMP_7.$$s || this, $c, $d, TMP_8, ppem = nil, resolution = nil, data_offsets = nil;

            
              $d = self.$read(4, "n2"), $c = Opal.to_ary($d), (ppem = ($c[0] == null ? nil : $c[0])), (resolution = ($c[1] == null ? nil : $c[1])), $d;
              data_offsets = $send(Opal.const_get_relative($nesting, 'Array'), 'new', [$rb_plus(self.$file().$maximum_profile().$num_glyphs(), 1)], (TMP_8 = function(){var self = TMP_8.$$s || this;

              return self.$read(4, "N").$first()}, TMP_8.$$s = self, TMP_8.$$arity = 0, TMP_8));
              return $hash2(["ppem", "resolution", "offset", "glyph_data_offset"], {"ppem": ppem, "resolution": resolution, "offset": strike_offset, "glyph_data_offset": data_offsets});}, TMP_7.$$s = self, TMP_7.$$arity = 0, TMP_7))}, TMP_6.$$s = self, TMP_6.$$arity = 1, TMP_6)));
        }, TMP_Sbix_parse$B_9.$$arity = 0), nil) && 'parse!';
      })($nesting[0], Opal.const_get_relative($nesting, 'Table'), $nesting)
    })($nesting[0], null, $nesting)
  })($nesting[0], $nesting);
};

/* Generated by Opal 0.11.0 */
Opal.modules["ttfunk"] = function(Opal) {
  var self = Opal.top, $nesting = [], nil = Opal.nil, $breaker = Opal.breaker, $slice = Opal.slice, $module = Opal.module, $klass = Opal.klass, $send = Opal.send, $truthy = Opal.truthy;

  Opal.add_stubs(['$require', '$attr_reader', '$new', '$read', '$verify_and_open', '$open', '$[]', '$respond_to?', '$rewind', '$binmode', '$file?', '$raise', '$exists?', '$os2', '$ascent', '$nonzero?', '$horizontal_header', '$descent', '$line_gap', '$x_min', '$header', '$y_min', '$x_max', '$y_max', '$tables', '$directory', '$to_s']);
  
  self.$require("stringio");
  self.$require("pathname");
  self.$require("ttfunk"+ '/../' + "ttfunk/directory");
  self.$require("ttfunk"+ '/../' + "ttfunk/resource_file");
  self.$require("ttfunk"+ '/../' + "ttfunk/collection");
  (function($base, $parent_nesting) {
    var $TTFunk, self = $TTFunk = $module($base, 'TTFunk');

    var def = self.$$proto, $nesting = [self].concat($parent_nesting);

    (function($base, $super, $parent_nesting) {
      function $File(){};
      var self = $File = $klass($base, $super, 'File', $File);

      var def = self.$$proto, $nesting = [self].concat($parent_nesting), TMP_File_open_1, TMP_File_from_dfont_3, TMP_File_from_ttc_5, TMP_File_verify_and_open_6, TMP_File_initialize_7, TMP_File_ascent_8, TMP_File_descent_9, TMP_File_line_gap_10, TMP_File_bbox_11, TMP_File_directory_info_12, TMP_File_header_13, TMP_File_cmap_14, TMP_File_horizontal_header_15, TMP_File_horizontal_metrics_16, TMP_File_maximum_profile_17, TMP_File_kerning_18, TMP_File_name_19, TMP_File_os2_20, TMP_File_postscript_21, TMP_File_glyph_locations_22, TMP_File_glyph_outlines_23, TMP_File_sbix_24;

      def.contents = def.ascent = def.descent = def.line_gap = def.header = def.cmap = def.horizontal_header = def.horizontal_metrics = def.maximum_profile = def.kerning = def.name = def.os2 = def.postscript = def.glyph_locations = def.glyph_outlines = def.sbix = nil;
      
      self.$attr_reader("contents");
      self.$attr_reader("directory");
      Opal.defs(self, '$open', TMP_File_open_1 = function $$open(io_or_path) {
        var self = this;

        return self.$new(self.$verify_and_open(io_or_path).$read())
      }, TMP_File_open_1.$$arity = 1);
      Opal.defs(self, '$from_dfont', TMP_File_from_dfont_3 = function $$from_dfont(file, which) {
        var TMP_2, self = this;

        if (which == null) {
          which = 0;
        }
        return self.$new($send(Opal.const_get_relative($nesting, 'ResourceFile'), 'open', [file], (TMP_2 = function(dfont){var self = TMP_2.$$s || this;
if (dfont == null) dfont = nil;
        return dfont['$[]']("sfnt", which)}, TMP_2.$$s = self, TMP_2.$$arity = 1, TMP_2)))
      }, TMP_File_from_dfont_3.$$arity = -2);
      Opal.defs(self, '$from_ttc', TMP_File_from_ttc_5 = function $$from_ttc(file, which) {
        var TMP_4, self = this;

        if (which == null) {
          which = 0;
        }
        return $send(Opal.const_get_relative($nesting, 'Collection'), 'open', [file], (TMP_4 = function(ttc){var self = TMP_4.$$s || this;
if (ttc == null) ttc = nil;
        return ttc['$[]'](which)}, TMP_4.$$s = self, TMP_4.$$arity = 1, TMP_4))
      }, TMP_File_from_ttc_5.$$arity = -2);
      Opal.defs(self, '$verify_and_open', TMP_File_verify_and_open_6 = function $$verify_and_open(io_or_path) {
        var self = this, io = nil;

        
        if ($truthy(io_or_path['$respond_to?']("rewind"))) {
          
          io = io_or_path;
          io.$rewind();
          if ($truthy(io['$respond_to?']("binmode"))) {
            io.$binmode()};
          return io;};
        io_or_path = Opal.const_get_relative($nesting, 'Pathname').$new(io_or_path);
        if ($truthy(io_or_path['$file?']())) {
          } else {
          self.$raise(Opal.const_get_relative($nesting, 'ArgumentError'), "" + (io_or_path) + " not found")
        };
        io = io_or_path.$open("rb");
        return io;
      }, TMP_File_verify_and_open_6.$$arity = 1);
      
      Opal.defn(self, '$initialize', TMP_File_initialize_7 = function $$initialize(contents, offset) {
        var self = this;

        if (offset == null) {
          offset = 0;
        }
        
        self.contents = Opal.const_get_relative($nesting, 'StringIO').$new(contents);
        return (self.directory = Opal.const_get_relative($nesting, 'Directory').$new(self.contents, offset));
      }, TMP_File_initialize_7.$$arity = -2);
      
      Opal.defn(self, '$ascent', TMP_File_ascent_8 = function $$ascent() {
        var $a, $b, $c, $d, self = this;

        return (self.ascent = ($truthy($a = self.ascent) ? $a : ($truthy($b = ($truthy($c = ($truthy($d = self.$os2()['$exists?']()) ? self.$os2().$ascent() : $d)) ? self.$os2().$ascent()['$nonzero?']() : $c)) ? $b : self.$horizontal_header().$ascent())))
      }, TMP_File_ascent_8.$$arity = 0);
      
      Opal.defn(self, '$descent', TMP_File_descent_9 = function $$descent() {
        var $a, $b, $c, $d, self = this;

        return (self.descent = ($truthy($a = self.descent) ? $a : ($truthy($b = ($truthy($c = ($truthy($d = self.$os2()['$exists?']()) ? self.$os2().$descent() : $d)) ? self.$os2().$descent()['$nonzero?']() : $c)) ? $b : self.$horizontal_header().$descent())))
      }, TMP_File_descent_9.$$arity = 0);
      
      Opal.defn(self, '$line_gap', TMP_File_line_gap_10 = function $$line_gap() {
        var $a, $b, $c, $d, self = this;

        return (self.line_gap = ($truthy($a = self.line_gap) ? $a : ($truthy($b = ($truthy($c = ($truthy($d = self.$os2()['$exists?']()) ? self.$os2().$line_gap() : $d)) ? self.$os2().$line_gap()['$nonzero?']() : $c)) ? $b : self.$horizontal_header().$line_gap())))
      }, TMP_File_line_gap_10.$$arity = 0);
      
      Opal.defn(self, '$bbox', TMP_File_bbox_11 = function $$bbox() {
        var self = this;

        return [self.$header().$x_min(), self.$header().$y_min(), self.$header().$x_max(), self.$header().$y_max()]
      }, TMP_File_bbox_11.$$arity = 0);
      
      Opal.defn(self, '$directory_info', TMP_File_directory_info_12 = function $$directory_info(tag) {
        var self = this;

        return self.$directory().$tables()['$[]'](tag.$to_s())
      }, TMP_File_directory_info_12.$$arity = 1);
      
      Opal.defn(self, '$header', TMP_File_header_13 = function $$header() {
        var $a, self = this;

        return (self.header = ($truthy($a = self.header) ? $a : Opal.const_get_qualified(Opal.const_get_qualified(Opal.const_get_relative($nesting, 'TTFunk'), 'Table'), 'Head').$new(self)))
      }, TMP_File_header_13.$$arity = 0);
      
      Opal.defn(self, '$cmap', TMP_File_cmap_14 = function $$cmap() {
        var $a, self = this;

        return (self.cmap = ($truthy($a = self.cmap) ? $a : Opal.const_get_qualified(Opal.const_get_qualified(Opal.const_get_relative($nesting, 'TTFunk'), 'Table'), 'Cmap').$new(self)))
      }, TMP_File_cmap_14.$$arity = 0);
      
      Opal.defn(self, '$horizontal_header', TMP_File_horizontal_header_15 = function $$horizontal_header() {
        var $a, self = this;

        return (self.horizontal_header = ($truthy($a = self.horizontal_header) ? $a : Opal.const_get_qualified(Opal.const_get_qualified(Opal.const_get_relative($nesting, 'TTFunk'), 'Table'), 'Hhea').$new(self)))
      }, TMP_File_horizontal_header_15.$$arity = 0);
      
      Opal.defn(self, '$horizontal_metrics', TMP_File_horizontal_metrics_16 = function $$horizontal_metrics() {
        var $a, self = this;

        return (self.horizontal_metrics = ($truthy($a = self.horizontal_metrics) ? $a : Opal.const_get_qualified(Opal.const_get_qualified(Opal.const_get_relative($nesting, 'TTFunk'), 'Table'), 'Hmtx').$new(self)))
      }, TMP_File_horizontal_metrics_16.$$arity = 0);
      
      Opal.defn(self, '$maximum_profile', TMP_File_maximum_profile_17 = function $$maximum_profile() {
        var $a, self = this;

        return (self.maximum_profile = ($truthy($a = self.maximum_profile) ? $a : Opal.const_get_qualified(Opal.const_get_qualified(Opal.const_get_relative($nesting, 'TTFunk'), 'Table'), 'Maxp').$new(self)))
      }, TMP_File_maximum_profile_17.$$arity = 0);
      
      Opal.defn(self, '$kerning', TMP_File_kerning_18 = function $$kerning() {
        var $a, self = this;

        return (self.kerning = ($truthy($a = self.kerning) ? $a : Opal.const_get_qualified(Opal.const_get_qualified(Opal.const_get_relative($nesting, 'TTFunk'), 'Table'), 'Kern').$new(self)))
      }, TMP_File_kerning_18.$$arity = 0);
      
      Opal.defn(self, '$name', TMP_File_name_19 = function $$name() {
        var $a, self = this;

        return (self.name = ($truthy($a = self.name) ? $a : Opal.const_get_qualified(Opal.const_get_qualified(Opal.const_get_relative($nesting, 'TTFunk'), 'Table'), 'Name').$new(self)))
      }, TMP_File_name_19.$$arity = 0);
      
      Opal.defn(self, '$os2', TMP_File_os2_20 = function $$os2() {
        var $a, self = this;

        return (self.os2 = ($truthy($a = self.os2) ? $a : Opal.const_get_qualified(Opal.const_get_qualified(Opal.const_get_relative($nesting, 'TTFunk'), 'Table'), 'OS2').$new(self)))
      }, TMP_File_os2_20.$$arity = 0);
      
      Opal.defn(self, '$postscript', TMP_File_postscript_21 = function $$postscript() {
        var $a, self = this;

        return (self.postscript = ($truthy($a = self.postscript) ? $a : Opal.const_get_qualified(Opal.const_get_qualified(Opal.const_get_relative($nesting, 'TTFunk'), 'Table'), 'Post').$new(self)))
      }, TMP_File_postscript_21.$$arity = 0);
      
      Opal.defn(self, '$glyph_locations', TMP_File_glyph_locations_22 = function $$glyph_locations() {
        var $a, self = this;

        return (self.glyph_locations = ($truthy($a = self.glyph_locations) ? $a : Opal.const_get_qualified(Opal.const_get_qualified(Opal.const_get_relative($nesting, 'TTFunk'), 'Table'), 'Loca').$new(self)))
      }, TMP_File_glyph_locations_22.$$arity = 0);
      
      Opal.defn(self, '$glyph_outlines', TMP_File_glyph_outlines_23 = function $$glyph_outlines() {
        var $a, self = this;

        return (self.glyph_outlines = ($truthy($a = self.glyph_outlines) ? $a : Opal.const_get_qualified(Opal.const_get_qualified(Opal.const_get_relative($nesting, 'TTFunk'), 'Table'), 'Glyf').$new(self)))
      }, TMP_File_glyph_outlines_23.$$arity = 0);
      return (Opal.defn(self, '$sbix', TMP_File_sbix_24 = function $$sbix() {
        var $a, self = this;

        return (self.sbix = ($truthy($a = self.sbix) ? $a : Opal.const_get_qualified(Opal.const_get_qualified(Opal.const_get_relative($nesting, 'TTFunk'), 'Table'), 'Sbix').$new(self)))
      }, TMP_File_sbix_24.$$arity = 0), nil) && 'sbix';
    })($nesting[0], null, $nesting)
  })($nesting[0], $nesting);
  self.$require("ttfunk"+ '/../' + "ttfunk/table/cmap");
  self.$require("ttfunk"+ '/../' + "ttfunk/table/glyf");
  self.$require("ttfunk"+ '/../' + "ttfunk/table/head");
  self.$require("ttfunk"+ '/../' + "ttfunk/table/hhea");
  self.$require("ttfunk"+ '/../' + "ttfunk/table/hmtx");
  self.$require("ttfunk"+ '/../' + "ttfunk/table/kern");
  self.$require("ttfunk"+ '/../' + "ttfunk/table/loca");
  self.$require("ttfunk"+ '/../' + "ttfunk/table/maxp");
  self.$require("ttfunk"+ '/../' + "ttfunk/table/name");
  self.$require("ttfunk"+ '/../' + "ttfunk/table/os2");
  self.$require("ttfunk"+ '/../' + "ttfunk/table/post");
  return self.$require("ttfunk"+ '/../' + "ttfunk/table/sbix");
};

/* Generated by Opal 0.11.0 */
Opal.modules["pdf/core/pdf_object"] = function(Opal) {
  function $rb_plus(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs + rhs : lhs['$+'](rhs);
  }
  function $rb_lt(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs < rhs : lhs['$<'](rhs);
  }
  function $rb_gt(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs > rhs : lhs['$>'](rhs);
  }
  var self = Opal.top, $nesting = [], nil = Opal.nil, $breaker = Opal.breaker, $slice = Opal.slice, $module = Opal.module, $send = Opal.send, $truthy = Opal.truthy;

  Opal.add_stubs(['$module_function', '$round', '$to_f', '$join', '$map', '$real', '$encode', '$force_encoding', '$first', '$unpack', '$===', '$is_a?', '$String', '$<<', '$pdf_object', '$gsub', '$+', '$chop', '$strftime', '$utf8_to_utf16', '$string_to_hex', '$to_s', '$<', '$>', '$include?', '$upcase', '$pack', '$each', '$raise', '$to_sym', '$to_hash', '$name', '$value', '$inspect']);
  return (function($base, $parent_nesting) {
    var $PDF, self = $PDF = $module($base, 'PDF');

    var def = self.$$proto, $nesting = [self].concat($parent_nesting);

    (function($base, $parent_nesting) {
      var $Core, self = $Core = $module($base, 'Core');

      var def = self.$$proto, $nesting = [self].concat($parent_nesting), TMP_Core_real_1, TMP_Core_real_params_3, TMP_Core_utf8_to_utf16_4, TMP_Core_string_to_hex_5, TMP_Core_pdf_object_11;

      
      self.$module_function();
      
      Opal.defn(self, '$real', TMP_Core_real_1 = function $$real(num) {
        var self = this;

        return num.$to_f().$round(4)
      }, TMP_Core_real_1.$$arity = 1);
      
      Opal.defn(self, '$real_params', TMP_Core_real_params_3 = function $$real_params(array) {
        var TMP_2, self = this;

        return $send(array, 'map', [], (TMP_2 = function(e){var self = TMP_2.$$s || this;
if (e == null) e = nil;
        return self.$real(e)}, TMP_2.$$s = self, TMP_2.$$arity = 1, TMP_2)).$join(" ")
      }, TMP_Core_real_params_3.$$arity = 1);
      
      Opal.defn(self, '$utf8_to_utf16', TMP_Core_utf8_to_utf16_4 = function $$utf8_to_utf16(str) {
        var self = this;

        return str.$encode(Opal.const_get_qualified(Opal.const_get_qualified('::', 'Encoding'), 'UTF_16BE'))
      }, TMP_Core_utf8_to_utf16_4.$$arity = 1);
      
      Opal.defn(self, '$string_to_hex', TMP_Core_string_to_hex_5 = function $$string_to_hex(str) {
        var self = this;

        return str.$unpack("H*").$first().$force_encoding(Opal.const_get_qualified(Opal.const_get_qualified('::', 'Encoding'), 'US_ASCII'))
      }, TMP_Core_string_to_hex_5.$$arity = 1);
      
      Opal.defn(self, '$pdf_object', TMP_Core_pdf_object_11 = function $$pdf_object(obj, in_content_stream) {
        var TMP_6, TMP_7, TMP_8, TMP_9, TMP_10, self = this, $case = nil, output = nil;

        if (in_content_stream == null) {
          in_content_stream = false;
        }
        return (function() {$case = obj;
        if (Opal.const_get_relative($nesting, 'NilClass')['$===']($case)) {return "null"}
        else if (Opal.const_get_relative($nesting, 'TrueClass')['$===']($case)) {return "true"}
        else if (Opal.const_get_relative($nesting, 'FalseClass')['$===']($case)) {return "false"}
        else if (Opal.const_get_relative($nesting, 'Numeric')['$===']($case)) {
        if ($truthy(obj['$is_a?'](Opal.const_get_relative($nesting, 'Integer')))) {
          } else {
          obj = self.$real(obj)
        };
        return self.$String(obj);}
        else if (Opal.const_get_relative($nesting, 'Array')['$===']($case)) {return "["['$<<']($send(obj, 'map', [], (TMP_6 = function(e){var self = TMP_6.$$s || this;
if (e == null) e = nil;
        return self.$pdf_object(e, in_content_stream)}, TMP_6.$$s = self, TMP_6.$$arity = 1, TMP_6)).$join(" "))['$<<']("]")}
        else if (Opal.const_get_qualified(Opal.const_get_qualified(Opal.const_get_relative($nesting, 'PDF'), 'Core'), 'LiteralString')['$===']($case)) {
        obj = $send(obj, 'gsub', [/[\\\n\r\t\b\f\(\)]/], (TMP_7 = function(m){var self = TMP_7.$$s || this;
if (m == null) m = nil;
        return "" + "\\" + (m)}, TMP_7.$$s = self, TMP_7.$$arity = 1, TMP_7));
        return "" + "(" + (obj) + ")";}
        else if (Opal.const_get_relative($nesting, 'Time')['$===']($case)) {
        obj = $rb_plus(obj.$strftime("D:%Y%m%d%H%M%S%z").$chop().$chop(), "'00'");
        obj = $send(obj, 'gsub', [/[\\\n\r\t\b\f\(\)]/], (TMP_8 = function(m){var self = TMP_8.$$s || this;
if (m == null) m = nil;
        return "" + "\\" + (m)}, TMP_8.$$s = self, TMP_8.$$arity = 1, TMP_8));
        return "" + "(" + (obj) + ")";}
        else if (Opal.const_get_qualified(Opal.const_get_qualified(Opal.const_get_relative($nesting, 'PDF'), 'Core'), 'ByteString')['$===']($case)) {return "<"['$<<'](obj.$unpack("H*").$first())['$<<'](">")}
        else if (Opal.const_get_relative($nesting, 'String')['$===']($case)) {
        if ($truthy(in_content_stream)) {
          } else {
          obj = self.$utf8_to_utf16(obj)
        };
        return "<"['$<<'](self.$string_to_hex(obj))['$<<'](">");}
        else if (Opal.const_get_relative($nesting, 'Symbol')['$===']($case)) {return $rb_plus("/", $send(obj.$to_s().$unpack("C*"), 'map', [], (TMP_9 = function(n){var self = TMP_9.$$s || this, $a, $b;
if (n == null) n = nil;
        if ($truthy(($truthy($a = ($truthy($b = $rb_lt(n, 33)) ? $b : $rb_gt(n, 126))) ? $a : [35, 40, 41, 47, 60, 62]['$include?'](n)))) {
            return $rb_plus("#", n.$to_s(16).$upcase())
            } else {
            return [n].$pack("C*")
          }}, TMP_9.$$s = self, TMP_9.$$arity = 1, TMP_9)).$join())}
        else if (Opal.const_get_qualified('::', 'Hash')['$===']($case)) {
        output = "<< ";
        $send(obj, 'each', [], (TMP_10 = function(k, v){var self = TMP_10.$$s || this, $a;
if (k == null) k = nil;if (v == null) v = nil;
        
          if ($truthy(($truthy($a = k['$is_a?'](Opal.const_get_relative($nesting, 'String'))) ? $a : k['$is_a?'](Opal.const_get_relative($nesting, 'Symbol'))))) {
            } else {
            self.$raise(Opal.const_get_qualified(Opal.const_get_qualified(Opal.const_get_qualified(Opal.const_get_relative($nesting, 'PDF'), 'Core'), 'Errors'), 'FailedObjectConversion'), "A PDF Dictionary must be keyed by names")
          };
          return output['$<<'](self.$pdf_object(k.$to_sym(), in_content_stream))['$<<'](" ")['$<<'](self.$pdf_object(v, in_content_stream))['$<<']("\n");}, TMP_10.$$s = self, TMP_10.$$arity = 2, TMP_10));
        return output['$<<'](">>");}
        else if (Opal.const_get_qualified(Opal.const_get_qualified(Opal.const_get_relative($nesting, 'PDF'), 'Core'), 'Reference')['$===']($case)) {return obj.$to_s()}
        else if (Opal.const_get_qualified(Opal.const_get_qualified(Opal.const_get_qualified(Opal.const_get_relative($nesting, 'PDF'), 'Core'), 'NameTree'), 'Node')['$===']($case)) {return self.$pdf_object(obj.$to_hash())}
        else if (Opal.const_get_qualified(Opal.const_get_qualified(Opal.const_get_qualified(Opal.const_get_relative($nesting, 'PDF'), 'Core'), 'NameTree'), 'Value')['$===']($case)) {return $rb_plus($rb_plus(self.$pdf_object(obj.$name()), " "), self.$pdf_object(obj.$value()))}
        else if (Opal.const_get_qualified(Opal.const_get_qualified(Opal.const_get_relative($nesting, 'PDF'), 'Core'), 'OutlineRoot')['$===']($case) || Opal.const_get_qualified(Opal.const_get_qualified(Opal.const_get_relative($nesting, 'PDF'), 'Core'), 'OutlineItem')['$===']($case)) {return self.$pdf_object(obj.$to_hash())}
        else {return self.$raise(Opal.const_get_qualified(Opal.const_get_qualified(Opal.const_get_qualified(Opal.const_get_relative($nesting, 'PDF'), 'Core'), 'Errors'), 'FailedObjectConversion'), "" + "This object cannot be serialized to PDF (" + (obj.$inspect()) + ")")}})()
      }, TMP_Core_pdf_object_11.$$arity = -2);
    })($nesting[0], $nesting)
  })($nesting[0], $nesting)
};

/* Generated by Opal 0.11.0 */
Opal.modules["pdf/core/annotations"] = function(Opal) {
  function $rb_minus(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs - rhs : lhs['$-'](rhs);
  }
  var self = Opal.top, $nesting = [], nil = Opal.nil, $breaker = Opal.breaker, $slice = Opal.slice, $module = Opal.module, $truthy = Opal.truthy, $send = Opal.send, $hash2 = Opal.hash2;

  Opal.add_stubs(['$data', '$dictionary', '$page', '$state', '$[]', '$[]=', '$-', '$sanitize_annotation_hash', '$<<', '$ref!', '$merge', '$annotate', '$private', '$is_a?', '$new']);
  return (function($base, $parent_nesting) {
    var $PDF, self = $PDF = $module($base, 'PDF');

    var def = self.$$proto, $nesting = [self].concat($parent_nesting);

    (function($base, $parent_nesting) {
      var $Core, self = $Core = $module($base, 'Core');

      var def = self.$$proto, $nesting = [self].concat($parent_nesting);

      (function($base, $parent_nesting) {
        var $Annotations, self = $Annotations = $module($base, 'Annotations');

        var def = self.$$proto, $nesting = [self].concat($parent_nesting), TMP_Annotations_annotate_1, TMP_Annotations_text_annotation_2, TMP_Annotations_link_annotation_3, TMP_Annotations_sanitize_annotation_hash_4;

        
        
        Opal.defn(self, '$annotate', TMP_Annotations_annotate_1 = function $$annotate(options) {
          var $a, self = this, $logical_op_recvr_tmp_1 = nil, $writer = nil;

          
          
          $logical_op_recvr_tmp_1 = self.$state().$page().$dictionary().$data();
          ($truthy($a = $logical_op_recvr_tmp_1['$[]']("Annots")) ? $a : (($writer = ["Annots", []]), $send($logical_op_recvr_tmp_1, '[]=', Opal.to_a($writer)), $writer[$rb_minus($writer["length"], 1)]));;
          options = self.$sanitize_annotation_hash(options);
          self.$state().$page().$dictionary().$data()['$[]']("Annots")['$<<'](self['$ref!'](options));
          return options;
        }, TMP_Annotations_annotate_1.$$arity = 1);
        
        Opal.defn(self, '$text_annotation', TMP_Annotations_text_annotation_2 = function $$text_annotation(rect, contents, options) {
          var self = this;

          if (options == null) {
            options = $hash2([], {});
          }
          
          options = options.$merge($hash2(["Subtype", "Rect", "Contents"], {"Subtype": "Text", "Rect": rect, "Contents": contents}));
          return self.$annotate(options);
        }, TMP_Annotations_text_annotation_2.$$arity = -3);
        
        Opal.defn(self, '$link_annotation', TMP_Annotations_link_annotation_3 = function $$link_annotation(rect, options) {
          var self = this;

          if (options == null) {
            options = $hash2([], {});
          }
          
          options = options.$merge($hash2(["Subtype", "Rect"], {"Subtype": "Link", "Rect": rect}));
          return self.$annotate(options);
        }, TMP_Annotations_link_annotation_3.$$arity = -2);
        self.$private();
        
        Opal.defn(self, '$sanitize_annotation_hash', TMP_Annotations_sanitize_annotation_hash_4 = function $$sanitize_annotation_hash(options) {
          var self = this, $writer = nil;

          
          options = options.$merge($hash2(["Type"], {"Type": "Annot"}));
          if ($truthy(options['$[]']("Dest")['$is_a?'](Opal.const_get_relative($nesting, 'String')))) {
            
            $writer = ["Dest", Opal.const_get_qualified(Opal.const_get_qualified(Opal.const_get_relative($nesting, 'PDF'), 'Core'), 'LiteralString').$new(options['$[]']("Dest"))];
            $send(options, '[]=', Opal.to_a($writer));
            $writer[$rb_minus($writer["length"], 1)];};
          return options;
        }, TMP_Annotations_sanitize_annotation_hash_4.$$arity = 1);
      })($nesting[0], $nesting)
    })($nesting[0], $nesting)
  })($nesting[0], $nesting)
};

/* Generated by Opal 0.11.0 */
Opal.modules["pdf/core/byte_string"] = function(Opal) {
  var self = Opal.top, $nesting = [], nil = Opal.nil, $breaker = Opal.breaker, $slice = Opal.slice, $module = Opal.module, $klass = Opal.klass;

  return (function($base, $parent_nesting) {
    var $PDF, self = $PDF = $module($base, 'PDF');

    var def = self.$$proto, $nesting = [self].concat($parent_nesting);

    (function($base, $parent_nesting) {
      var $Core, self = $Core = $module($base, 'Core');

      var def = self.$$proto, $nesting = [self].concat($parent_nesting);

      (function($base, $super, $parent_nesting) {
        function $ByteString(){};
        var self = $ByteString = $klass($base, $super, 'ByteString', $ByteString);

        var def = self.$$proto, $nesting = [self].concat($parent_nesting);

        return nil
      })($nesting[0], Opal.const_get_relative($nesting, 'String'), $nesting)
    })($nesting[0], $nesting)
  })($nesting[0], $nesting)
};

/* Generated by Opal 0.11.0 */
Opal.modules["pdf/core/destinations"] = function(Opal) {
  function $rb_minus(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs - rhs : lhs['$-'](rhs);
  }
  var self = Opal.top, $nesting = [], nil = Opal.nil, $breaker = Opal.breaker, $slice = Opal.slice, $module = Opal.module, $truthy = Opal.truthy, $send = Opal.send;

  Opal.add_stubs(['$data', '$names', '$[]', '$ref!', '$new', '$[]=', '$-', '$is_a?', '$add', '$dests', '$dictionary', '$page']);
  return (function($base, $parent_nesting) {
    var $PDF, self = $PDF = $module($base, 'PDF');

    var def = self.$$proto, $nesting = [self].concat($parent_nesting);

    (function($base, $parent_nesting) {
      var $Core, self = $Core = $module($base, 'Core');

      var def = self.$$proto, $nesting = [self].concat($parent_nesting);

      (function($base, $parent_nesting) {
        var $Destinations, self = $Destinations = $module($base, 'Destinations');

        var def = self.$$proto, $nesting = [self].concat($parent_nesting), TMP_Destinations_dests_1, TMP_Destinations_add_dest_2, TMP_Destinations_dest_xyz_3, TMP_Destinations_dest_fit_4, TMP_Destinations_dest_fit_horizontally_5, TMP_Destinations_dest_fit_vertically_6, TMP_Destinations_dest_fit_rect_7, TMP_Destinations_dest_fit_bounds_8, TMP_Destinations_dest_fit_bounds_horizontally_9, TMP_Destinations_dest_fit_bounds_vertically_10;

        
        Opal.const_set($nesting[0], 'NAME_TREE_CHILDREN_LIMIT', 20);
        
        Opal.defn(self, '$dests', TMP_Destinations_dests_1 = function $$dests() {
          var $a, self = this, $logical_op_recvr_tmp_2 = nil, $writer = nil;

          
          $logical_op_recvr_tmp_2 = self.$names().$data();
          return ($truthy($a = $logical_op_recvr_tmp_2['$[]']("Dests")) ? $a : (($writer = ["Dests", self['$ref!'](Opal.const_get_qualified(Opal.const_get_qualified(Opal.const_get_qualified(Opal.const_get_relative($nesting, 'PDF'), 'Core'), 'NameTree'), 'Node').$new(self, Opal.const_get_relative($nesting, 'NAME_TREE_CHILDREN_LIMIT')))]), $send($logical_op_recvr_tmp_2, '[]=', Opal.to_a($writer)), $writer[$rb_minus($writer["length"], 1)]));
        }, TMP_Destinations_dests_1.$$arity = 0);
        
        Opal.defn(self, '$add_dest', TMP_Destinations_add_dest_2 = function $$add_dest(name, reference) {
          var self = this;

          
          if ($truthy(reference['$is_a?'](Opal.const_get_qualified(Opal.const_get_qualified(Opal.const_get_relative($nesting, 'PDF'), 'Core'), 'Reference')))) {
            } else {
            reference = self['$ref!'](reference)
          };
          return self.$dests().$data().$add(name, reference);
        }, TMP_Destinations_add_dest_2.$$arity = 2);
        
        Opal.defn(self, '$dest_xyz', TMP_Destinations_dest_xyz_3 = function $$dest_xyz(left, top, zoom, dest_page) {
          var self = this;

          if (zoom == null) {
            zoom = nil;
          }
          if (dest_page == null) {
            dest_page = self.$page();
          }
          return [dest_page.$dictionary(), "XYZ", left, top, zoom]
        }, TMP_Destinations_dest_xyz_3.$$arity = -3);
        
        Opal.defn(self, '$dest_fit', TMP_Destinations_dest_fit_4 = function $$dest_fit(dest_page) {
          var self = this;

          if (dest_page == null) {
            dest_page = self.$page();
          }
          return [dest_page.$dictionary(), "Fit"]
        }, TMP_Destinations_dest_fit_4.$$arity = -1);
        
        Opal.defn(self, '$dest_fit_horizontally', TMP_Destinations_dest_fit_horizontally_5 = function $$dest_fit_horizontally(top, dest_page) {
          var self = this;

          if (dest_page == null) {
            dest_page = self.$page();
          }
          return [dest_page.$dictionary(), "FitH", top]
        }, TMP_Destinations_dest_fit_horizontally_5.$$arity = -2);
        
        Opal.defn(self, '$dest_fit_vertically', TMP_Destinations_dest_fit_vertically_6 = function $$dest_fit_vertically(left, dest_page) {
          var self = this;

          if (dest_page == null) {
            dest_page = self.$page();
          }
          return [dest_page.$dictionary(), "FitV", left]
        }, TMP_Destinations_dest_fit_vertically_6.$$arity = -2);
        
        Opal.defn(self, '$dest_fit_rect', TMP_Destinations_dest_fit_rect_7 = function $$dest_fit_rect(left, bottom, right, top, dest_page) {
          var self = this;

          if (dest_page == null) {
            dest_page = self.$page();
          }
          return [dest_page.$dictionary(), "FitR", left, bottom, right, top]
        }, TMP_Destinations_dest_fit_rect_7.$$arity = -5);
        
        Opal.defn(self, '$dest_fit_bounds', TMP_Destinations_dest_fit_bounds_8 = function $$dest_fit_bounds(dest_page) {
          var self = this;

          if (dest_page == null) {
            dest_page = self.$page();
          }
          return [dest_page.$dictionary(), "FitB"]
        }, TMP_Destinations_dest_fit_bounds_8.$$arity = -1);
        
        Opal.defn(self, '$dest_fit_bounds_horizontally', TMP_Destinations_dest_fit_bounds_horizontally_9 = function $$dest_fit_bounds_horizontally(top, dest_page) {
          var self = this;

          if (dest_page == null) {
            dest_page = self.$page();
          }
          return [dest_page.$dictionary(), "FitBH", top]
        }, TMP_Destinations_dest_fit_bounds_horizontally_9.$$arity = -2);
        
        Opal.defn(self, '$dest_fit_bounds_vertically', TMP_Destinations_dest_fit_bounds_vertically_10 = function $$dest_fit_bounds_vertically(left, dest_page) {
          var self = this;

          if (dest_page == null) {
            dest_page = self.$page();
          }
          return [dest_page.$dictionary(), "FitBV", left]
        }, TMP_Destinations_dest_fit_bounds_vertically_10.$$arity = -2);
      })($nesting[0], $nesting)
    })($nesting[0], $nesting)
  })($nesting[0], $nesting)
};

/* Generated by Opal 0.11.0 */
Opal.modules["zlib"] = function(Opal) {
  var self = Opal.top, $nesting = [], nil = Opal.nil, $breaker = Opal.breaker, $slice = Opal.slice, $module = Opal.module;

  return (function($base, $parent_nesting) {
    var $Zlib, self = $Zlib = $module($base, 'Zlib');

    var def = self.$$proto, $nesting = [self].concat($parent_nesting);

    nil
  })($nesting[0], $nesting)
};

/* Generated by Opal 0.11.0 */
Opal.modules["pdf/core/filters"] = function(Opal) {
  var self = Opal.top, $nesting = [], nil = Opal.nil, $breaker = Opal.breaker, $slice = Opal.slice, $module = Opal.module;

  Opal.add_stubs(['$require', '$deflate', '$inflate']);
  
  self.$require("zlib");
  return (function($base, $parent_nesting) {
    var $PDF, self = $PDF = $module($base, 'PDF');

    var def = self.$$proto, $nesting = [self].concat($parent_nesting);

    (function($base, $parent_nesting) {
      var $Core, self = $Core = $module($base, 'Core');

      var def = self.$$proto, $nesting = [self].concat($parent_nesting);

      (function($base, $parent_nesting) {
        var $Filters, self = $Filters = $module($base, 'Filters');

        var def = self.$$proto, $nesting = [self].concat($parent_nesting);

        
        (function($base, $parent_nesting) {
          var $FlateDecode, self = $FlateDecode = $module($base, 'FlateDecode');

          var def = self.$$proto, $nesting = [self].concat($parent_nesting), TMP_FlateDecode_encode_1, TMP_FlateDecode_decode_2;

          
          Opal.defs(self, '$encode', TMP_FlateDecode_encode_1 = function $$encode(stream, _params) {
            var self = this;

            if (_params == null) {
              _params = nil;
            }
            return Opal.const_get_qualified(Opal.const_get_relative($nesting, 'Zlib'), 'Deflate').$deflate(stream)
          }, TMP_FlateDecode_encode_1.$$arity = -2);
          Opal.defs(self, '$decode', TMP_FlateDecode_decode_2 = function $$decode(stream, _params) {
            var self = this;

            if (_params == null) {
              _params = nil;
            }
            return Opal.const_get_qualified(Opal.const_get_relative($nesting, 'Zlib'), 'Inflate').$inflate(stream)
          }, TMP_FlateDecode_decode_2.$$arity = -2);
        })($nesting[0], $nesting);
        (function($base, $parent_nesting) {
          var $DCTDecode, self = $DCTDecode = $module($base, 'DCTDecode');

          var def = self.$$proto, $nesting = [self].concat($parent_nesting), TMP_DCTDecode_encode_3, TMP_DCTDecode_decode_4;

          
          Opal.defs(self, '$encode', TMP_DCTDecode_encode_3 = function $$encode(stream, _params) {
            var self = this;

            if (_params == null) {
              _params = nil;
            }
            return stream
          }, TMP_DCTDecode_encode_3.$$arity = -2);
          Opal.defs(self, '$decode', TMP_DCTDecode_decode_4 = function $$decode(stream, _params) {
            var self = this;

            if (_params == null) {
              _params = nil;
            }
            return stream
          }, TMP_DCTDecode_decode_4.$$arity = -2);
        })($nesting[0], $nesting);
      })($nesting[0], $nesting)
    })($nesting[0], $nesting)
  })($nesting[0], $nesting);
};

/* Generated by Opal 0.11.0 */
Opal.modules["pdf/core/stream"] = function(Opal) {
  function $rb_minus(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs - rhs : lhs['$-'](rhs);
  }
  var self = Opal.top, $nesting = [], nil = Opal.nil, $breaker = Opal.breaker, $slice = Opal.slice, $module = Opal.module, $klass = Opal.klass, $truthy = Opal.truthy, $send = Opal.send, $hash2 = Opal.hash2;

  Opal.add_stubs(['$attr_reader', '$new', '$<<', '$include?', '$names', '$nil?', '$dup', '$each', '$const_get', '$encode', '$length', '$filtered_stream', '$decode_params', '$any?', '$[]=', '$-', '$!', '$name', '$class', '$format', '$object_id', '$inspect']);
  return (function($base, $parent_nesting) {
    var $PDF, self = $PDF = $module($base, 'PDF');

    var def = self.$$proto, $nesting = [self].concat($parent_nesting);

    (function($base, $parent_nesting) {
      var $Core, self = $Core = $module($base, 'Core');

      var def = self.$$proto, $nesting = [self].concat($parent_nesting);

      (function($base, $super, $parent_nesting) {
        function $Stream(){};
        var self = $Stream = $klass($base, $super, 'Stream', $Stream);

        var def = self.$$proto, $nesting = [self].concat($parent_nesting), TMP_Stream_initialize_1, TMP_Stream_$lt$lt_2, TMP_Stream_compress$B_3, TMP_Stream_compressed$q_4, TMP_Stream_empty$q_5, TMP_Stream_filtered_stream_7, TMP_Stream_length_8, TMP_Stream_object_9, TMP_Stream_data_11, TMP_Stream_inspect_12;

        def.stream = def.filters = def.filtered_stream = nil;
        
        self.$attr_reader("filters");
        
        Opal.defn(self, '$initialize', TMP_Stream_initialize_1 = function $$initialize(io) {
          var self = this;

          if (io == null) {
            io = nil;
          }
          
          self.filtered_stream = "";
          self.stream = io;
          return (self.filters = Opal.const_get_relative($nesting, 'FilterList').$new());
        }, TMP_Stream_initialize_1.$$arity = -1);
        
        Opal.defn(self, '$<<', TMP_Stream_$lt$lt_2 = function(io) {
          var $a, self = this;

          
          (self.stream = ($truthy($a = self.stream) ? $a : ""))['$<<'](io);
          self.filtered_stream = nil;
          return self;
        }, TMP_Stream_$lt$lt_2.$$arity = 1);
        
        Opal.defn(self, '$compress!', TMP_Stream_compress$B_3 = function() {
          var self = this;

          if ($truthy(self.filters.$names()['$include?']("FlateDecode"))) {
            return nil
            } else {
            
            self.filtered_stream = nil;
            return self.filters['$<<']("FlateDecode");
          }
        }, TMP_Stream_compress$B_3.$$arity = 0);
        
        Opal.defn(self, '$compressed?', TMP_Stream_compressed$q_4 = function() {
          var self = this;

          return self.filters.$names()['$include?']("FlateDecode")
        }, TMP_Stream_compressed$q_4.$$arity = 0);
        
        Opal.defn(self, '$empty?', TMP_Stream_empty$q_5 = function() {
          var self = this;

          return self.stream['$nil?']()
        }, TMP_Stream_empty$q_5.$$arity = 0);
        
        Opal.defn(self, '$filtered_stream', TMP_Stream_filtered_stream_7 = function $$filtered_stream() {
          var TMP_6, self = this;

          if ($truthy(self.stream)) {
            
            if ($truthy(self.filtered_stream['$nil?']())) {
              
              self.filtered_stream = self.stream.$dup();
              $send(self.filters, 'each', [], (TMP_6 = function($a){var self = TMP_6.$$s || this, $a_args, filter_name, params, filter = nil;
                if (self.filtered_stream == null) self.filtered_stream = nil;

                if ($a == null) {
                  $a = nil;
                }
                $a = Opal.to_ary($a);
                $a_args = Opal.slice.call($a, 0, $a.length);
                filter_name = $a_args.splice(0,1)[0];
                if (filter_name == null) {
                  filter_name = nil;
                }
                params = $a_args.splice(0,1)[0];
                if (params == null) {
                  params = nil;
                }
              
                filter = Opal.const_get_qualified(Opal.const_get_qualified(Opal.const_get_relative($nesting, 'PDF'), 'Core'), 'Filters').$const_get(filter_name);
                if ($truthy(filter)) {
                  return (self.filtered_stream = filter.$encode(self.filtered_stream, params))
                  } else {
                  return nil
                };}, TMP_6.$$s = self, TMP_6.$$arity = 1, TMP_6.$$has_top_level_mlhs_arg = true, TMP_6));};
            return self.filtered_stream;
            } else {
            return nil
          }
        }, TMP_Stream_filtered_stream_7.$$arity = 0);
        
        Opal.defn(self, '$length', TMP_Stream_length_8 = function $$length() {
          var self = this;

          return self.stream.$length()
        }, TMP_Stream_length_8.$$arity = 0);
        
        Opal.defn(self, '$object', TMP_Stream_object_9 = function $$object() {
          var self = this;

          if ($truthy(self.$filtered_stream())) {
            return "" + "stream\n" + (self.$filtered_stream()) + "\nendstream\n"
            } else {
            return ""
          }
        }, TMP_Stream_object_9.$$arity = 0);
        
        Opal.defn(self, '$data', TMP_Stream_data_11 = function $$data() {
          var TMP_10, self = this, filter_names = nil, filter_params = nil, d = nil, $writer = nil;

          if ($truthy(self.stream)) {
            
            filter_names = self.filters.$names();
            filter_params = self.filters.$decode_params();
            d = $hash2(["Length"], {"Length": self.$filtered_stream().$length()});
            if ($truthy(filter_names['$any?']())) {
              
              $writer = ["Filter", filter_names];
              $send(d, '[]=', Opal.to_a($writer));
              $writer[$rb_minus($writer["length"], 1)];};
            if ($truthy($send(filter_params, 'any?', [], (TMP_10 = function(f){var self = TMP_10.$$s || this;
if (f == null) f = nil;
            return f['$nil?']()['$!']()}, TMP_10.$$s = self, TMP_10.$$arity = 1, TMP_10)))) {
              
              $writer = ["DecodeParms", filter_params];
              $send(d, '[]=', Opal.to_a($writer));
              $writer[$rb_minus($writer["length"], 1)];};
            return d;
            } else {
            return $hash2([], {})
          }
        }, TMP_Stream_data_11.$$arity = 0);
        return (Opal.defn(self, '$inspect', TMP_Stream_inspect_12 = function $$inspect() {
          var self = this;

          return "" + ("" + "#<" + (self.$class().$name()) + ":0x" + (self.$format("%014x", self.$object_id())) + " ") + ("" + "@stream=" + (self.stream.$inspect()) + ", @filters=" + (self.filters.$inspect()) + ">")
        }, TMP_Stream_inspect_12.$$arity = 0), nil) && 'inspect';
      })($nesting[0], null, $nesting)
    })($nesting[0], $nesting)
  })($nesting[0], $nesting)
};

/* Generated by Opal 0.11.0 */
Opal.modules["pdf/core/utils"] = function(Opal) {
  var self = Opal.top, $nesting = [], nil = Opal.nil, $breaker = Opal.breaker, $slice = Opal.slice, $module = Opal.module;

  Opal.add_stubs(['$load', '$dump', '$module_function']);
  return (function($base, $parent_nesting) {
    var $PDF, self = $PDF = $module($base, 'PDF');

    var def = self.$$proto, $nesting = [self].concat($parent_nesting);

    (function($base, $parent_nesting) {
      var $Core, self = $Core = $module($base, 'Core');

      var def = self.$$proto, $nesting = [self].concat($parent_nesting);

      (function($base, $parent_nesting) {
        var $Utils, self = $Utils = $module($base, 'Utils');

        var def = self.$$proto, $nesting = [self].concat($parent_nesting), TMP_Utils_deep_clone_1;

        
        
        Opal.defn(self, '$deep_clone', TMP_Utils_deep_clone_1 = function $$deep_clone(object) {
          var self = this;

          return Opal.const_get_relative($nesting, 'Marshal').$load(Opal.const_get_relative($nesting, 'Marshal').$dump(object))
        }, TMP_Utils_deep_clone_1.$$arity = 1);
        self.$module_function("deep_clone");
      })($nesting[0], $nesting)
    })($nesting[0], $nesting)
  })($nesting[0], $nesting)
};

/* Generated by Opal 0.11.0 */
Opal.modules["pdf/core/reference"] = function(Opal) {
  function $rb_minus(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs - rhs : lhs['$-'](rhs);
  }
  var self = Opal.top, $nesting = [], nil = Opal.nil, $breaker = Opal.breaker, $slice = Opal.slice, $module = Opal.module, $klass = Opal.klass, $truthy = Opal.truthy, $send = Opal.send;

  Opal.add_stubs(['$require', '$attr_accessor', '$new', '$gen', '$empty?', '$<<', '$pdf_object', '$data', '$merge', '$object', '$is_a?', '$raise', '$dup', '$===', '$each', '$-', '$keys', '$deep_clone', '$[]', '$[]=', '$deep_copy', '$data=', '$stream', '$stream=']);
  
  self.$require("pdf/core/utils");
  return (function($base, $parent_nesting) {
    var $PDF, self = $PDF = $module($base, 'PDF');

    var def = self.$$proto, $nesting = [self].concat($parent_nesting);

    (function($base, $parent_nesting) {
      var $Core, self = $Core = $module($base, 'Core');

      var def = self.$$proto, $nesting = [self].concat($parent_nesting);

      (function($base, $super, $parent_nesting) {
        function $Reference(){};
        var self = $Reference = $klass($base, $super, 'Reference', $Reference);

        var def = self.$$proto, $nesting = [self].concat($parent_nesting), TMP_Reference_initialize_1, TMP_Reference_object_2, TMP_Reference_$lt$lt_3, TMP_Reference_to_s_4, TMP_Reference_deep_copy_6, TMP_Reference_replace_7;

        def.identifier = def.stream = def.data = nil;
        
        self.$attr_accessor("gen", "data", "offset", "stream", "identifier");
        
        Opal.defn(self, '$initialize', TMP_Reference_initialize_1 = function $$initialize(id, data) {
          var self = this;

          
          self.identifier = id;
          self.gen = 0;
          self.data = data;
          return (self.stream = Opal.const_get_relative($nesting, 'Stream').$new());
        }, TMP_Reference_initialize_1.$$arity = 2);
        
        Opal.defn(self, '$object', TMP_Reference_object_2 = function $$object() {
          var self = this, output = nil;

          
          output = "" + (self.identifier) + " " + (self.$gen()) + " obj\n";
          if ($truthy(self.stream['$empty?']())) {
            output['$<<'](Opal.const_get_qualified(Opal.const_get_relative($nesting, 'PDF'), 'Core').$pdf_object(self.$data()))['$<<']("\n")
            } else {
            output['$<<'](Opal.const_get_qualified(Opal.const_get_relative($nesting, 'PDF'), 'Core').$pdf_object(self.$data().$merge(self.stream.$data())))['$<<']("\n")['$<<'](self.stream.$object())
          };
          return output['$<<']("endobj\n");
        }, TMP_Reference_object_2.$$arity = 0);
        
        Opal.defn(self, '$<<', TMP_Reference_$lt$lt_3 = function(io) {
          var $a, self = this;

          
          if ($truthy(self.data['$is_a?'](Opal.const_get_qualified('::', 'Hash')))) {
            } else {
            self.$raise("Cannot attach stream to non-dictionary object")
          };
          return (self.stream = ($truthy($a = self.stream) ? $a : Opal.const_get_relative($nesting, 'Stream').$new()))['$<<'](io);
        }, TMP_Reference_$lt$lt_3.$$arity = 1);
        
        Opal.defn(self, '$to_s', TMP_Reference_to_s_4 = function $$to_s() {
          var self = this;

          return "" + (self.identifier) + " " + (self.$gen()) + " R"
        }, TMP_Reference_to_s_4.$$arity = 0);
        
        Opal.defn(self, '$deep_copy', TMP_Reference_deep_copy_6 = function $$deep_copy(share) {
          var TMP_5, self = this, r = nil, $case = nil, $writer = nil;

          if (share == null) {
            share = [];
          }
          
          r = self.$dup();
          $case = r.$data();
          if (Opal.const_get_qualified('::', 'Hash')['$===']($case)) {$send($rb_minus(r.$data().$keys(), share), 'each', [], (TMP_5 = function(k){var self = TMP_5.$$s || this, $writer = nil;
if (k == null) k = nil;
          
            $writer = [k, Opal.const_get_relative($nesting, 'Utils').$deep_clone(r.$data()['$[]'](k))];
            $send(r.$data(), '[]=', Opal.to_a($writer));
            return $writer[$rb_minus($writer["length"], 1)];}, TMP_5.$$s = self, TMP_5.$$arity = 1, TMP_5))}
          else if (Opal.const_get_qualified(Opal.const_get_qualified(Opal.const_get_qualified(Opal.const_get_relative($nesting, 'PDF'), 'Core'), 'NameTree'), 'Node')['$===']($case)) {
          $writer = [r.$data().$deep_copy()];
          $send(r, 'data=', Opal.to_a($writer));
          $writer[$rb_minus($writer["length"], 1)];}
          else {
          $writer = [Opal.const_get_relative($nesting, 'Utils').$deep_clone(r.$data())];
          $send(r, 'data=', Opal.to_a($writer));
          $writer[$rb_minus($writer["length"], 1)];};
          
          $writer = [Opal.const_get_relative($nesting, 'Utils').$deep_clone(r.$stream())];
          $send(r, 'stream=', Opal.to_a($writer));
          $writer[$rb_minus($writer["length"], 1)];;
          return r;
        }, TMP_Reference_deep_copy_6.$$arity = -1);
        return (Opal.defn(self, '$replace', TMP_Reference_replace_7 = function $$replace(other_ref) {
          var self = this;

          
          self.data = other_ref.$data();
          return (self.stream = other_ref.$stream());
        }, TMP_Reference_replace_7.$$arity = 1), nil) && 'replace';
      })($nesting[0], null, $nesting)
    })($nesting[0], $nesting)
  })($nesting[0], $nesting);
};

/* Generated by Opal 0.11.0 */
Opal.modules["pdf/core/literal_string"] = function(Opal) {
  var self = Opal.top, $nesting = [], nil = Opal.nil, $breaker = Opal.breaker, $slice = Opal.slice, $module = Opal.module, $klass = Opal.klass;

  return (function($base, $parent_nesting) {
    var $PDF, self = $PDF = $module($base, 'PDF');

    var def = self.$$proto, $nesting = [self].concat($parent_nesting);

    (function($base, $parent_nesting) {
      var $Core, self = $Core = $module($base, 'Core');

      var def = self.$$proto, $nesting = [self].concat($parent_nesting);

      (function($base, $super, $parent_nesting) {
        function $LiteralString(){};
        var self = $LiteralString = $klass($base, $super, 'LiteralString', $LiteralString);

        var def = self.$$proto, $nesting = [self].concat($parent_nesting);

        return nil
      })($nesting[0], Opal.const_get_relative($nesting, 'String'), $nesting)
    })($nesting[0], $nesting)
  })($nesting[0], $nesting)
};

/* Generated by Opal 0.11.0 */
Opal.modules["pdf/core/filter_list"] = function(Opal) {
  var self = Opal.top, $nesting = [], nil = Opal.nil, $breaker = Opal.breaker, $slice = Opal.slice, $module = Opal.module, $klass = Opal.klass, $send = Opal.send;

  Opal.add_stubs(['$===', '$<<', '$each', '$raise', '$inspect', '$map']);
  return (function($base, $parent_nesting) {
    var $PDF, self = $PDF = $module($base, 'PDF');

    var def = self.$$proto, $nesting = [self].concat($parent_nesting);

    (function($base, $parent_nesting) {
      var $Core, self = $Core = $module($base, 'Core');

      var def = self.$$proto, $nesting = [self].concat($parent_nesting);

      (function($base, $super, $parent_nesting) {
        function $FilterList(){};
        var self = $FilterList = $klass($base, $super, 'FilterList', $FilterList);

        var def = self.$$proto, $nesting = [self].concat($parent_nesting), TMP_FilterList_initialize_1, TMP_FilterList_$lt$lt_3, TMP_FilterList_normalized_4, TMP_FilterList_names_6, TMP_FilterList_decode_params_8, TMP_FilterList_inspect_9, TMP_FilterList_each_11;

        def.list = nil;
        
        
        Opal.defn(self, '$initialize', TMP_FilterList_initialize_1 = function $$initialize() {
          var self = this;

          return (self.list = [])
        }, TMP_FilterList_initialize_1.$$arity = 0);
        
        Opal.defn(self, '$<<', TMP_FilterList_$lt$lt_3 = function(filter) {
          var TMP_2, self = this, $case = nil;

          
          $case = filter;
          if (Opal.const_get_relative($nesting, 'Symbol')['$===']($case)) {self.list['$<<']([filter, nil])}
          else if (Opal.const_get_qualified('::', 'Hash')['$===']($case)) {$send(filter, 'each', [], (TMP_2 = function(name, params){var self = TMP_2.$$s || this;
            if (self.list == null) self.list = nil;
if (name == null) name = nil;if (params == null) params = nil;
          return self.list['$<<']([name, params])}, TMP_2.$$s = self, TMP_2.$$arity = 2, TMP_2))}
          else {self.$raise("" + "Can not interpret input as filter: " + (filter.$inspect()))};
          return self;
        }, TMP_FilterList_$lt$lt_3.$$arity = 1);
        
        Opal.defn(self, '$normalized', TMP_FilterList_normalized_4 = function $$normalized() {
          var self = this;

          return self.list
        }, TMP_FilterList_normalized_4.$$arity = 0);
        Opal.alias(self, "to_a", "normalized");
        
        Opal.defn(self, '$names', TMP_FilterList_names_6 = function $$names() {
          var TMP_5, self = this;

          return $send(self.list, 'map', [], (TMP_5 = function($a){var self = TMP_5.$$s || this, $a_args, name, _;

            if ($a == null) {
              $a = nil;
            }
            $a = Opal.to_ary($a);
            $a_args = Opal.slice.call($a, 0, $a.length);
            name = $a_args.splice(0,1)[0];
            if (name == null) {
              name = nil;
            }
            _ = $a_args.splice(0,1)[0];
            if (_ == null) {
              _ = nil;
            }
          return name}, TMP_5.$$s = self, TMP_5.$$arity = 1, TMP_5.$$has_top_level_mlhs_arg = true, TMP_5))
        }, TMP_FilterList_names_6.$$arity = 0);
        
        Opal.defn(self, '$decode_params', TMP_FilterList_decode_params_8 = function $$decode_params() {
          var TMP_7, self = this;

          return $send(self.list, 'map', [], (TMP_7 = function($a){var self = TMP_7.$$s || this, $a_args, _, params;

            if ($a == null) {
              $a = nil;
            }
            $a = Opal.to_ary($a);
            $a_args = Opal.slice.call($a, 0, $a.length);
            _ = $a_args.splice(0,1)[0];
            if (_ == null) {
              _ = nil;
            }
            params = $a_args.splice(0,1)[0];
            if (params == null) {
              params = nil;
            }
          return params}, TMP_7.$$s = self, TMP_7.$$arity = 1, TMP_7.$$has_top_level_mlhs_arg = true, TMP_7))
        }, TMP_FilterList_decode_params_8.$$arity = 0);
        
        Opal.defn(self, '$inspect', TMP_FilterList_inspect_9 = function $$inspect() {
          var self = this;

          return self.list.$inspect()
        }, TMP_FilterList_inspect_9.$$arity = 0);
        return (Opal.defn(self, '$each', TMP_FilterList_each_11 = function $$each() {
          var TMP_10, self = this, $iter = TMP_FilterList_each_11.$$p, $yield = $iter || nil;

          if ($iter) TMP_FilterList_each_11.$$p = null;
          return $send(self.list, 'each', [], (TMP_10 = function(filter){var self = TMP_10.$$s || this;
if (filter == null) filter = nil;
          return Opal.yield1($yield, filter);}, TMP_10.$$s = self, TMP_10.$$arity = 1, TMP_10))
        }, TMP_FilterList_each_11.$$arity = 0), nil) && 'each';
      })($nesting[0], null, $nesting)
    })($nesting[0], $nesting)
  })($nesting[0], $nesting)
};

/* Generated by Opal 0.11.0 */
Opal.modules["pdf/core/graphics_state"] = function(Opal) {
  function $rb_minus(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs - rhs : lhs['$-'](rhs);
  }
  var self = Opal.top, $nesting = [], nil = Opal.nil, $breaker = Opal.breaker, $slice = Opal.slice, $module = Opal.module, $klass = Opal.klass, $send = Opal.send, $truthy = Opal.truthy, $hash2 = Opal.hash2;

  Opal.add_stubs(['$attr_accessor', '$new', '$stack=', '$-', '$push', '$stack', '$current_state', '$empty?', '$raise', '$pop', '$last', '$!', '$initialize_copy', '$[]', '$is_a?', '$real_params', '$real', '$private', '$dup', '$color_space', '$fill_color', '$stroke_color', '$dash', '$cap_style', '$join_style', '$line_width']);
  return (function($base, $parent_nesting) {
    var $PDF, self = $PDF = $module($base, 'PDF');

    var def = self.$$proto, $nesting = [self].concat($parent_nesting);

    (function($base, $parent_nesting) {
      var $Core, self = $Core = $module($base, 'Core');

      var def = self.$$proto, $nesting = [self].concat($parent_nesting);

      
      (function($base, $super, $parent_nesting) {
        function $GraphicStateStack(){};
        var self = $GraphicStateStack = $klass($base, $super, 'GraphicStateStack', $GraphicStateStack);

        var def = self.$$proto, $nesting = [self].concat($parent_nesting), TMP_GraphicStateStack_initialize_1, TMP_GraphicStateStack_save_graphic_state_2, TMP_GraphicStateStack_restore_graphic_state_3, TMP_GraphicStateStack_current_state_4, TMP_GraphicStateStack_present$q_5, TMP_GraphicStateStack_empty$q_6;

        
        self.$attr_accessor("stack");
        
        Opal.defn(self, '$initialize', TMP_GraphicStateStack_initialize_1 = function $$initialize(previous_state) {
          var self = this, $writer = nil;

          if (previous_state == null) {
            previous_state = nil;
          }
          
          $writer = [[Opal.const_get_relative($nesting, 'GraphicState').$new(previous_state)]];
          $send(self, 'stack=', Opal.to_a($writer));
          return $writer[$rb_minus($writer["length"], 1)];
        }, TMP_GraphicStateStack_initialize_1.$$arity = -1);
        
        Opal.defn(self, '$save_graphic_state', TMP_GraphicStateStack_save_graphic_state_2 = function $$save_graphic_state(graphic_state) {
          var $a, self = this;

          if (graphic_state == null) {
            graphic_state = nil;
          }
          return self.$stack().$push(Opal.const_get_relative($nesting, 'GraphicState').$new(($truthy($a = graphic_state) ? $a : self.$current_state())))
        }, TMP_GraphicStateStack_save_graphic_state_2.$$arity = -1);
        
        Opal.defn(self, '$restore_graphic_state', TMP_GraphicStateStack_restore_graphic_state_3 = function $$restore_graphic_state() {
          var self = this;

          
          if ($truthy(self.$stack()['$empty?']())) {
            self.$raise(Opal.const_get_qualified(Opal.const_get_qualified(Opal.const_get_qualified(Opal.const_get_relative($nesting, 'PDF'), 'Core'), 'Errors'), 'EmptyGraphicStateStack'), "\n You have reached the end of the graphic state stack")};
          return self.$stack().$pop();
        }, TMP_GraphicStateStack_restore_graphic_state_3.$$arity = 0);
        
        Opal.defn(self, '$current_state', TMP_GraphicStateStack_current_state_4 = function $$current_state() {
          var self = this;

          return self.$stack().$last()
        }, TMP_GraphicStateStack_current_state_4.$$arity = 0);
        
        Opal.defn(self, '$present?', TMP_GraphicStateStack_present$q_5 = function() {
          var self = this;

          return self.$stack()['$empty?']()['$!']()
        }, TMP_GraphicStateStack_present$q_5.$$arity = 0);
        return (Opal.defn(self, '$empty?', TMP_GraphicStateStack_empty$q_6 = function() {
          var self = this;

          return self.$stack()['$empty?']()
        }, TMP_GraphicStateStack_empty$q_6.$$arity = 0), nil) && 'empty?';
      })($nesting[0], null, $nesting);
      (function($base, $super, $parent_nesting) {
        function $GraphicState(){};
        var self = $GraphicState = $klass($base, $super, 'GraphicState', $GraphicState);

        var def = self.$$proto, $nesting = [self].concat($parent_nesting), TMP_GraphicState_initialize_7, TMP_GraphicState_dash_setting_8, TMP_GraphicState_initialize_copy_9;

        def.dash = nil;
        
        self.$attr_accessor("color_space", "dash", "cap_style", "join_style", "line_width", "fill_color", "stroke_color");
        
        Opal.defn(self, '$initialize', TMP_GraphicState_initialize_7 = function $$initialize(previous_state) {
          var self = this;

          if (previous_state == null) {
            previous_state = nil;
          }
          if ($truthy(previous_state)) {
            return self.$initialize_copy(previous_state)
            } else {
            
            self.color_space = $hash2([], {});
            self.fill_color = "000000";
            self.stroke_color = "000000";
            self.dash = $hash2(["dash", "space", "phase"], {"dash": nil, "space": nil, "phase": 0});
            self.cap_style = "butt";
            self.join_style = "miter";
            return (self.line_width = 1);
          }
        }, TMP_GraphicState_initialize_7.$$arity = -1);
        
        Opal.defn(self, '$dash_setting', TMP_GraphicState_dash_setting_8 = function $$dash_setting() {
          var self = this, array = nil;

          
          if ($truthy(self.dash['$[]']("dash"))) {
            } else {
            return "[] 0 d"
          };
          array = (function() {if ($truthy(self.dash['$[]']("dash")['$is_a?'](Opal.const_get_relative($nesting, 'Array')))) {
            return self.dash['$[]']("dash")
            } else {
            return [self.dash['$[]']("dash"), self.dash['$[]']("space")]
          }; return nil; })();
          return "" + ("" + "[" + (Opal.const_get_qualified(Opal.const_get_relative($nesting, 'PDF'), 'Core').$real_params(array)) + "] ") + ("" + (Opal.const_get_qualified(Opal.const_get_relative($nesting, 'PDF'), 'Core').$real(self.dash['$[]']("phase"))) + " d");
        }, TMP_GraphicState_dash_setting_8.$$arity = 0);
        self.$private();
        return (Opal.defn(self, '$initialize_copy', TMP_GraphicState_initialize_copy_9 = function $$initialize_copy(other) {
          var self = this;

          
          self.color_space = other.$color_space().$dup();
          self.fill_color = other.$fill_color().$dup();
          self.stroke_color = other.$stroke_color().$dup();
          self.dash = other.$dash().$dup();
          self.cap_style = other.$cap_style();
          self.join_style = other.$join_style();
          return (self.line_width = other.$line_width());
        }, TMP_GraphicState_initialize_copy_9.$$arity = 1), nil) && 'initialize_copy';
      })($nesting[0], null, $nesting);
    })($nesting[0], $nesting)
  })($nesting[0], $nesting)
};

/* Generated by Opal 0.11.0 */
Opal.modules["pdf/core/page"] = function(Opal) {
  function $rb_minus(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs - rhs : lhs['$-'](rhs);
  }
  function $rb_gt(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs > rhs : lhs['$>'](rhs);
  }
  function $rb_plus(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs + rhs : lhs['$+'](rhs);
  }
  var self = Opal.top, $nesting = [], nil = Opal.nil, $breaker = Opal.breaker, $slice = Opal.slice, $module = Opal.module, $klass = Opal.klass, $hash2 = Opal.hash2, $truthy = Opal.truthy, $send = Opal.send;

  Opal.add_stubs(['$attr_accessor', '$attr_writer', '$freeze', '$[]', '$new', '$ref', '$<<', '$content', '$pages', '$store', '$state', '$dimensions', '$crop_box', '$bleed_box', '$trim_box', '$art_box', '$[]=', '$resources', '$-', '$current_state', '$stack', '$data', '$dictionary', '$>', '$!', '$nil?', '$size', '$save_graphics_state', '$document', '$send', '$==', '$restore_graphics_state', '$deref', '$is_a?', '$each', '$compression_enabled?', '$compress!', '$stream', '$+', '$layout', '$===', '$reverse', '$raise', '$art_indents', '$bleeds', '$crops', '$trims', '$private', '$key?', '$inherited_dictionary_value']);
  
  self.$require("pdf/core/page"+ '/../' + "graphics_state");
  return (function($base, $parent_nesting) {
    var $PDF, self = $PDF = $module($base, 'PDF');

    var def = self.$$proto, $nesting = [self].concat($parent_nesting);

    (function($base, $parent_nesting) {
      var $Core, self = $Core = $module($base, 'Core');

      var def = self.$$proto, $nesting = [self].concat($parent_nesting);

      (function($base, $super, $parent_nesting) {
        function $Page(){};
        var self = $Page = $klass($base, $super, 'Page', $Page);

        var def = self.$$proto, $nesting = [self].concat($parent_nesting), TMP_Page_initialize_1, TMP_Page_graphic_state_2, TMP_Page_layout_3, TMP_Page_size_4, TMP_Page_in_stamp_stream$q_5, TMP_Page_stamp_stream_6, TMP_Page_content_7, TMP_Page_dictionary_8, TMP_Page_resources_9, TMP_Page_fonts_10, TMP_Page_xobjects_11, TMP_Page_ext_gstates_12, TMP_Page_finalize_14, TMP_Page_dimensions_15, TMP_Page_art_box_16, TMP_Page_bleed_box_17, TMP_Page_crop_box_18, TMP_Page_trim_box_19, TMP_Page_inherited_dictionary_value_20;

        def.layout = def.size = def.stamp_stream = def.stamp_dictionary = def.content = def.dictionary = nil;
        
        self.$attr_accessor("art_indents", "bleeds", "crops", "document", "margins", "stack", "trims");
        self.$attr_writer("content", "dictionary");
        Opal.const_set($nesting[0], 'ZERO_INDENTS', $hash2(["left", "bottom", "right", "top"], {"left": 0, "bottom": 0, "right": 0, "top": 0}).$freeze());
        
        Opal.defn(self, '$initialize', TMP_Page_initialize_1 = function $$initialize(document, options) {
          var $a, self = this, $writer = nil;

          if (options == null) {
            options = $hash2([], {});
          }
          
          self.document = document;
          self.margins = ($truthy($a = options['$[]']("margins")) ? $a : $hash2(["left", "right", "top", "bottom"], {"left": 36, "right": 36, "top": 36, "bottom": 36}));
          self.crops = ($truthy($a = options['$[]']("crops")) ? $a : Opal.const_get_relative($nesting, 'ZERO_INDENTS'));
          self.bleeds = ($truthy($a = options['$[]']("bleeds")) ? $a : Opal.const_get_relative($nesting, 'ZERO_INDENTS'));
          self.trims = ($truthy($a = options['$[]']("trims")) ? $a : Opal.const_get_relative($nesting, 'ZERO_INDENTS'));
          self.art_indents = ($truthy($a = options['$[]']("art_indents")) ? $a : Opal.const_get_relative($nesting, 'ZERO_INDENTS'));
          self.stack = Opal.const_get_relative($nesting, 'GraphicStateStack').$new(options['$[]']("graphic_state"));
          self.size = ($truthy($a = options['$[]']("size")) ? $a : "LETTER");
          self.layout = ($truthy($a = options['$[]']("layout")) ? $a : "portrait");
          self.stamp_stream = nil;
          self.stamp_dictionary = nil;
          self.content = document.$ref($hash2([], {}));
          self.$content()['$<<']("q")['$<<']("\n");
          self.dictionary = document.$ref($hash2(["Type", "Parent", "MediaBox", "CropBox", "BleedBox", "TrimBox", "ArtBox", "Contents"], {"Type": "Page", "Parent": document.$state().$store().$pages(), "MediaBox": self.$dimensions(), "CropBox": self.$crop_box(), "BleedBox": self.$bleed_box(), "TrimBox": self.$trim_box(), "ArtBox": self.$art_box(), "Contents": self.$content()}));
          
          $writer = ["ProcSet", ["PDF", "Text", "ImageB", "ImageC", "ImageI"]];
          $send(self.$resources(), '[]=', Opal.to_a($writer));
          return $writer[$rb_minus($writer["length"], 1)];;
        }, TMP_Page_initialize_1.$$arity = -2);
        
        Opal.defn(self, '$graphic_state', TMP_Page_graphic_state_2 = function $$graphic_state() {
          var self = this;

          return self.$stack().$current_state()
        }, TMP_Page_graphic_state_2.$$arity = 0);
        
        Opal.defn(self, '$layout', TMP_Page_layout_3 = function $$layout() {
          var $a, $b, self = this, mb = nil;

          
          if ($truthy(($truthy($a = (($b = self['layout'], $b != null && $b !== nil) ? 'instance-variable' : nil)) ? self.layout : $a))) {
            return self.layout};
          mb = self.$dictionary().$data()['$[]']("MediaBox");
          if ($truthy($rb_gt(mb['$[]'](3), mb['$[]'](2)))) {
            return "portrait"
            } else {
            return "landscape"
          };
        }, TMP_Page_layout_3.$$arity = 0);
        
        Opal.defn(self, '$size', TMP_Page_size_4 = function $$size() {
          var $a, $b, $c, self = this;

          return ($truthy($a = ($truthy($b = (($c = self['size'], $c != null && $c !== nil) ? 'instance-variable' : nil)) ? self.size : $b)) ? $a : self.$dimensions()['$[]'](2, 2))
        }, TMP_Page_size_4.$$arity = 0);
        
        Opal.defn(self, '$in_stamp_stream?', TMP_Page_in_stamp_stream$q_5 = function() {
          var self = this;

          return self.stamp_stream['$nil?']()['$!']()
        }, TMP_Page_in_stamp_stream$q_5.$$arity = 0);
        
        Opal.defn(self, '$stamp_stream', TMP_Page_stamp_stream_6 = function $$stamp_stream(dictionary) {
          var $a, self = this, $iter = TMP_Page_stamp_stream_6.$$p, $yield = $iter || nil, graphic_stack_size = nil;

          if ($iter) TMP_Page_stamp_stream_6.$$p = null;
          
          self.stamp_stream = "";
          self.stamp_dictionary = dictionary;
          graphic_stack_size = self.$stack().$stack().$size();
          self.$document().$save_graphics_state();
          self.$document().$send("freeze_stamp_graphics");
          if (($yield !== nil)) {
            Opal.yieldX($yield, [])};
          while (!(graphic_stack_size['$=='](self.$stack().$stack().$size()))) {
            self.$document().$restore_graphics_state()
          };
          self.stamp_dictionary['$<<'](self.stamp_stream);
          self.stamp_stream = nil;
          return (self.stamp_dictionary = nil);
        }, TMP_Page_stamp_stream_6.$$arity = 1);
        
        Opal.defn(self, '$content', TMP_Page_content_7 = function $$content() {
          var $a, self = this;

          return ($truthy($a = self.stamp_stream) ? $a : self.$document().$state().$store()['$[]'](self.content))
        }, TMP_Page_content_7.$$arity = 0);
        
        Opal.defn(self, '$dictionary', TMP_Page_dictionary_8 = function $$dictionary() {
          var $a, $b, $c, self = this;

          return ($truthy($a = ($truthy($b = (($c = self['stamp_dictionary'], $c != null && $c !== nil) ? 'instance-variable' : nil)) ? self.stamp_dictionary : $b)) ? $a : self.$document().$state().$store()['$[]'](self.dictionary))
        }, TMP_Page_dictionary_8.$$arity = 0);
        
        Opal.defn(self, '$resources', TMP_Page_resources_9 = function $$resources() {
          var self = this, $writer = nil;

          if ($truthy(self.$dictionary().$data()['$[]']("Resources"))) {
            return self.$document().$deref(self.$dictionary().$data()['$[]']("Resources"))
            } else {
            
            $writer = ["Resources", $hash2([], {})];
            $send(self.$dictionary().$data(), '[]=', Opal.to_a($writer));
            return $writer[$rb_minus($writer["length"], 1)];
          }
        }, TMP_Page_resources_9.$$arity = 0);
        
        Opal.defn(self, '$fonts', TMP_Page_fonts_10 = function $$fonts() {
          var self = this, $writer = nil;

          if ($truthy(self.$resources()['$[]']("Font"))) {
            return self.$document().$deref(self.$resources()['$[]']("Font"))
            } else {
            
            $writer = ["Font", $hash2([], {})];
            $send(self.$resources(), '[]=', Opal.to_a($writer));
            return $writer[$rb_minus($writer["length"], 1)];
          }
        }, TMP_Page_fonts_10.$$arity = 0);
        
        Opal.defn(self, '$xobjects', TMP_Page_xobjects_11 = function $$xobjects() {
          var self = this, $writer = nil;

          if ($truthy(self.$resources()['$[]']("XObject"))) {
            return self.$document().$deref(self.$resources()['$[]']("XObject"))
            } else {
            
            $writer = ["XObject", $hash2([], {})];
            $send(self.$resources(), '[]=', Opal.to_a($writer));
            return $writer[$rb_minus($writer["length"], 1)];
          }
        }, TMP_Page_xobjects_11.$$arity = 0);
        
        Opal.defn(self, '$ext_gstates', TMP_Page_ext_gstates_12 = function $$ext_gstates() {
          var self = this, $writer = nil;

          if ($truthy(self.$resources()['$[]']("ExtGState"))) {
            return self.$document().$deref(self.$resources()['$[]']("ExtGState"))
            } else {
            
            $writer = ["ExtGState", $hash2([], {})];
            $send(self.$resources(), '[]=', Opal.to_a($writer));
            return $writer[$rb_minus($writer["length"], 1)];
          }
        }, TMP_Page_ext_gstates_12.$$arity = 0);
        
        Opal.defn(self, '$finalize', TMP_Page_finalize_14 = function $$finalize() {
          var TMP_13, self = this;

          if ($truthy(self.$dictionary().$data()['$[]']("Contents")['$is_a?'](Opal.const_get_relative($nesting, 'Array')))) {
            return $send(self.$dictionary().$data()['$[]']("Contents"), 'each', [], (TMP_13 = function(stream){var self = TMP_13.$$s || this;
if (stream == null) stream = nil;
            if ($truthy(self.$document()['$compression_enabled?']())) {
                return stream.$stream()['$compress!']()
                } else {
                return nil
              }}, TMP_13.$$s = self, TMP_13.$$arity = 1, TMP_13))
          } else if ($truthy(self.$document()['$compression_enabled?']())) {
            return self.$content().$stream()['$compress!']()
            } else {
            return nil
          }
        }, TMP_Page_finalize_14.$$arity = 0);
        
        Opal.defn(self, '$dimensions', TMP_Page_dimensions_15 = function $$dimensions() {
          var $a, self = this, coords = nil, $case = nil;

          
          coords = ($truthy($a = Opal.const_get_qualified(Opal.const_get_qualified(Opal.const_get_qualified(Opal.const_get_relative($nesting, 'PDF'), 'Core'), 'PageGeometry'), 'SIZES')['$[]'](self.$size())) ? $a : self.$size());
          return $rb_plus([0, 0], (function() {$case = self.$layout();
          if ("portrait"['$===']($case)) {return coords}
          else if ("landscape"['$===']($case)) {return coords.$reverse()}
          else {return self.$raise(Opal.const_get_qualified(Opal.const_get_qualified(Opal.const_get_qualified(Opal.const_get_relative($nesting, 'PDF'), 'Core'), 'Errors'), 'InvalidPageLayout'), "Layout must be either :portrait or :landscape")}})());
        }, TMP_Page_dimensions_15.$$arity = 0);
        
        Opal.defn(self, '$art_box', TMP_Page_art_box_16 = function $$art_box() {
          var $a, $b, self = this, left = nil, bottom = nil, right = nil, top = nil;

          
          $b = self.$dimensions(), $a = Opal.to_ary($b), (left = ($a[0] == null ? nil : $a[0])), (bottom = ($a[1] == null ? nil : $a[1])), (right = ($a[2] == null ? nil : $a[2])), (top = ($a[3] == null ? nil : $a[3])), $b;
          return [$rb_plus(left, self.$art_indents()['$[]']("left")), $rb_plus(bottom, self.$art_indents()['$[]']("bottom")), $rb_minus(right, self.$art_indents()['$[]']("right")), $rb_minus(top, self.$art_indents()['$[]']("top"))];
        }, TMP_Page_art_box_16.$$arity = 0);
        
        Opal.defn(self, '$bleed_box', TMP_Page_bleed_box_17 = function $$bleed_box() {
          var $a, $b, self = this, left = nil, bottom = nil, right = nil, top = nil;

          
          $b = self.$dimensions(), $a = Opal.to_ary($b), (left = ($a[0] == null ? nil : $a[0])), (bottom = ($a[1] == null ? nil : $a[1])), (right = ($a[2] == null ? nil : $a[2])), (top = ($a[3] == null ? nil : $a[3])), $b;
          return [$rb_plus(left, self.$bleeds()['$[]']("left")), $rb_plus(bottom, self.$bleeds()['$[]']("bottom")), $rb_minus(right, self.$bleeds()['$[]']("right")), $rb_minus(top, self.$bleeds()['$[]']("top"))];
        }, TMP_Page_bleed_box_17.$$arity = 0);
        
        Opal.defn(self, '$crop_box', TMP_Page_crop_box_18 = function $$crop_box() {
          var $a, $b, self = this, left = nil, bottom = nil, right = nil, top = nil;

          
          $b = self.$dimensions(), $a = Opal.to_ary($b), (left = ($a[0] == null ? nil : $a[0])), (bottom = ($a[1] == null ? nil : $a[1])), (right = ($a[2] == null ? nil : $a[2])), (top = ($a[3] == null ? nil : $a[3])), $b;
          return [$rb_plus(left, self.$crops()['$[]']("left")), $rb_plus(bottom, self.$crops()['$[]']("bottom")), $rb_minus(right, self.$crops()['$[]']("right")), $rb_minus(top, self.$crops()['$[]']("top"))];
        }, TMP_Page_crop_box_18.$$arity = 0);
        
        Opal.defn(self, '$trim_box', TMP_Page_trim_box_19 = function $$trim_box() {
          var $a, $b, self = this, left = nil, bottom = nil, right = nil, top = nil;

          
          $b = self.$dimensions(), $a = Opal.to_ary($b), (left = ($a[0] == null ? nil : $a[0])), (bottom = ($a[1] == null ? nil : $a[1])), (right = ($a[2] == null ? nil : $a[2])), (top = ($a[3] == null ? nil : $a[3])), $b;
          return [$rb_plus(left, self.$trims()['$[]']("left")), $rb_plus(bottom, self.$trims()['$[]']("bottom")), $rb_minus(right, self.$trims()['$[]']("right")), $rb_minus(top, self.$trims()['$[]']("top"))];
        }, TMP_Page_trim_box_19.$$arity = 0);
        self.$private();
        return (Opal.defn(self, '$inherited_dictionary_value', TMP_Page_inherited_dictionary_value_20 = function $$inherited_dictionary_value(key, local_dict) {
          var $a, self = this;

          if (local_dict == null) {
            local_dict = nil;
          }
          
          local_dict = ($truthy($a = local_dict) ? $a : self.$dictionary().$data());
          if ($truthy(local_dict['$key?'](key))) {
            return local_dict['$[]'](key)
          } else if ($truthy(local_dict['$key?']("Parent"))) {
            return self.$inherited_dictionary_value(key, local_dict['$[]']("Parent").$data())
            } else {
            return nil
          };
        }, TMP_Page_inherited_dictionary_value_20.$$arity = -2), nil) && 'inherited_dictionary_value';
      })($nesting[0], null, $nesting)
    })($nesting[0], $nesting)
  })($nesting[0], $nesting);
};

/* Generated by Opal 0.11.0 */
Opal.modules["pdf/core/object_store"] = function(Opal) {
  function $rb_minus(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs - rhs : lhs['$-'](rhs);
  }
  function $rb_plus(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs + rhs : lhs['$+'](rhs);
  }
  function $rb_gt(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs > rhs : lhs['$>'](rhs);
  }
  var self = Opal.top, $nesting = [], nil = Opal.nil, $breaker = Opal.breaker, $slice = Opal.slice, $module = Opal.module, $klass = Opal.klass, $hash2 = Opal.hash2, $truthy = Opal.truthy, $send = Opal.send;

  Opal.add_stubs(['$include', '$attr_reader', '$identifier', '$ref', '$[]', '$==', '$[]=', '$data', '$root', '$-', '$nil?', '$pages', '$push', '$+', '$size', '$to_proc', '$is_a?', '$first', '$new', '$<<', '$each', '$>', '$flatten', '$get_page_objects']);
  return (function($base, $parent_nesting) {
    var $PDF, self = $PDF = $module($base, 'PDF');

    var def = self.$$proto, $nesting = [self].concat($parent_nesting);

    (function($base, $parent_nesting) {
      var $Core, self = $Core = $module($base, 'Core');

      var def = self.$$proto, $nesting = [self].concat($parent_nesting);

      (function($base, $super, $parent_nesting) {
        function $ObjectStore(){};
        var self = $ObjectStore = $klass($base, $super, 'ObjectStore', $ObjectStore);

        var def = self.$$proto, $nesting = [self].concat($parent_nesting), TMP_ObjectStore_initialize_1, TMP_ObjectStore_ref_2, TMP_ObjectStore_info_3, TMP_ObjectStore_root_4, TMP_ObjectStore_pages_5, TMP_ObjectStore_page_count_6, TMP_ObjectStore_push_7, TMP_ObjectStore_each_9, TMP_ObjectStore_$$_10, TMP_ObjectStore_size_11, TMP_ObjectStore_object_id_for_page_12;

        def.info = def.root = def.objects = def.identifiers = nil;
        
        self.$include(Opal.const_get_relative($nesting, 'Enumerable'));
        self.$attr_reader("min_version");
        
        Opal.defn(self, '$initialize', TMP_ObjectStore_initialize_1 = function $$initialize(opts) {
          var $a, $b, self = this, $writer = nil;

          if (opts == null) {
            opts = $hash2([], {});
          }
          
          self.objects = $hash2([], {});
          self.identifiers = [];
          self.info = ($truthy($a = self.info) ? $a : self.$ref(($truthy($b = opts['$[]']("info")) ? $b : $hash2([], {}))).$identifier());
          self.root = ($truthy($a = self.root) ? $a : self.$ref($hash2(["Type"], {"Type": "Catalog"})).$identifier());
          if (opts['$[]']("print_scaling")['$==']("none")) {
            
            $writer = ["ViewerPreferences", $hash2(["PrintScaling"], {"PrintScaling": "None"})];
            $send(self.$root().$data(), '[]=', Opal.to_a($writer));
            $writer[$rb_minus($writer["length"], 1)];};
          if ($truthy(self.$pages()['$nil?']())) {
            
            $writer = ["Pages", self.$ref($hash2(["Type", "Count", "Kids"], {"Type": "Pages", "Count": 0, "Kids": []}))];
            $send(self.$root().$data(), '[]=', Opal.to_a($writer));
            return $writer[$rb_minus($writer["length"], 1)];
            } else {
            return nil
          };
        }, TMP_ObjectStore_initialize_1.$$arity = -1);
        
        Opal.defn(self, '$ref', TMP_ObjectStore_ref_2 = function $$ref(data) {
          var self = this, $iter = TMP_ObjectStore_ref_2.$$p, block = $iter || nil;

          if ($iter) TMP_ObjectStore_ref_2.$$p = null;
          return $send(self, 'push', [$rb_plus(self.$size(), 1), data], block.$to_proc())
        }, TMP_ObjectStore_ref_2.$$arity = 1);
        
        Opal.defn(self, '$info', TMP_ObjectStore_info_3 = function $$info() {
          var self = this;

          return self.objects['$[]'](self.info)
        }, TMP_ObjectStore_info_3.$$arity = 0);
        
        Opal.defn(self, '$root', TMP_ObjectStore_root_4 = function $$root() {
          var self = this;

          return self.objects['$[]'](self.root)
        }, TMP_ObjectStore_root_4.$$arity = 0);
        
        Opal.defn(self, '$pages', TMP_ObjectStore_pages_5 = function $$pages() {
          var self = this;

          return self.$root().$data()['$[]']("Pages")
        }, TMP_ObjectStore_pages_5.$$arity = 0);
        
        Opal.defn(self, '$page_count', TMP_ObjectStore_page_count_6 = function $$page_count() {
          var self = this;

          return self.$pages().$data()['$[]']("Count")
        }, TMP_ObjectStore_page_count_6.$$arity = 0);
        
        Opal.defn(self, '$push', TMP_ObjectStore_push_7 = function $$push($a_rest) {
          var self = this, args, $iter = TMP_ObjectStore_push_7.$$p, block = $iter || nil, reference = nil, $writer = nil;

          var $args_len = arguments.length, $rest_len = $args_len - 0;
          if ($rest_len < 0) { $rest_len = 0; }
          args = new Array($rest_len);
          for (var $arg_idx = 0; $arg_idx < $args_len; $arg_idx++) {
            args[$arg_idx - 0] = arguments[$arg_idx];
          }
          if ($iter) TMP_ObjectStore_push_7.$$p = null;
          
          reference = (function() {if ($truthy(args.$first()['$is_a?'](Opal.const_get_qualified(Opal.const_get_qualified(Opal.const_get_relative($nesting, 'PDF'), 'Core'), 'Reference')))) {
            return args.$first()
            } else {
            return $send(Opal.const_get_qualified(Opal.const_get_qualified(Opal.const_get_relative($nesting, 'PDF'), 'Core'), 'Reference'), 'new', Opal.to_a(args), block.$to_proc())
          }; return nil; })();
          
          $writer = [reference.$identifier(), reference];
          $send(self.objects, '[]=', Opal.to_a($writer));
          $writer[$rb_minus($writer["length"], 1)];;
          self.identifiers['$<<'](reference.$identifier());
          return reference;
        }, TMP_ObjectStore_push_7.$$arity = -1);
        Opal.alias(self, "<<", "push");
        
        Opal.defn(self, '$each', TMP_ObjectStore_each_9 = function $$each() {
          var TMP_8, self = this, $iter = TMP_ObjectStore_each_9.$$p, $yield = $iter || nil;

          if ($iter) TMP_ObjectStore_each_9.$$p = null;
          return $send(self.identifiers, 'each', [], (TMP_8 = function(id){var self = TMP_8.$$s || this;
            if (self.objects == null) self.objects = nil;
if (id == null) id = nil;
          return Opal.yield1($yield, self.objects['$[]'](id));}, TMP_8.$$s = self, TMP_8.$$arity = 1, TMP_8))
        }, TMP_ObjectStore_each_9.$$arity = 0);
        
        Opal.defn(self, '$[]', TMP_ObjectStore_$$_10 = function(id) {
          var self = this;

          return self.objects['$[]'](id)
        }, TMP_ObjectStore_$$_10.$$arity = 1);
        
        Opal.defn(self, '$size', TMP_ObjectStore_size_11 = function $$size() {
          var self = this;

          return self.identifiers.$size()
        }, TMP_ObjectStore_size_11.$$arity = 0);
        Opal.alias(self, "length", "size");
        return (Opal.defn(self, '$object_id_for_page', TMP_ObjectStore_object_id_for_page_12 = function $$object_id_for_page(k) {
          var self = this, flat_page_ids = nil;

          
          if ($truthy($rb_gt(k, 0))) {
            k = $rb_minus(k, 1)};
          flat_page_ids = self.$get_page_objects(self.$pages()).$flatten();
          return flat_page_ids['$[]'](k);
        }, TMP_ObjectStore_object_id_for_page_12.$$arity = 1), nil) && 'object_id_for_page';
      })($nesting[0], null, $nesting)
    })($nesting[0], $nesting)
  })($nesting[0], $nesting)
};

/* Generated by Opal 0.11.0 */
Opal.modules["pdf/core/document_state"] = function(Opal) {
  function $rb_le(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs <= rhs : lhs['$<='](rhs);
  }
  function $rb_minus(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs - rhs : lhs['$-'](rhs);
  }
  function $rb_plus(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs + rhs : lhs['$+'](rhs);
  }
  var self = Opal.top, $nesting = [], nil = Opal.nil, $breaker = Opal.breaker, $slice = Opal.slice, $module = Opal.module, $klass = Opal.klass, $truthy = Opal.truthy, $hash2 = Opal.hash2, $send = Opal.send;

  Opal.add_stubs(['$normalize_metadata', '$[]', '$new', '$fetch', '$attr_accessor', '$<=', '$page_count', '$!', '$empty?', '$map', '$object_id_for_page', '$[]=', '$-', '$insert', '$pages', '$data', '$store', '$dictionary', '$+', '$on_page_create_callback', '$each', '$before_render_callbacks', '$call', '$length', '$size', '$offset=', '$<<', '$encrypted_object', '$object']);
  return (function($base, $parent_nesting) {
    var $PDF, self = $PDF = $module($base, 'PDF');

    var def = self.$$proto, $nesting = [self].concat($parent_nesting);

    (function($base, $parent_nesting) {
      var $Core, self = $Core = $module($base, 'Core');

      var def = self.$$proto, $nesting = [self].concat($parent_nesting);

      (function($base, $super, $parent_nesting) {
        function $DocumentState(){};
        var self = $DocumentState = $klass($base, $super, 'DocumentState', $DocumentState);

        var def = self.$$proto, $nesting = [self].concat($parent_nesting), TMP_DocumentState_initialize_1, TMP_DocumentState_populate_pages_from_store_3, TMP_DocumentState_normalize_metadata_4, TMP_DocumentState_insert_page_5, TMP_DocumentState_on_page_create_action_6, TMP_DocumentState_before_render_actions_8, TMP_DocumentState_page_count_9, TMP_DocumentState_render_body_11;

        def.store = def.pages = nil;
        
        
        Opal.defn(self, '$initialize', TMP_DocumentState_initialize_1 = function $$initialize(options) {
          var self = this;

          
          self.$normalize_metadata(options);
          self.store = (function() {if ($truthy(options['$[]']("print_scaling"))) {
            return Opal.const_get_qualified(Opal.const_get_qualified(Opal.const_get_relative($nesting, 'PDF'), 'Core'), 'ObjectStore').$new($hash2(["info", "print_scaling"], {"info": options['$[]']("info"), "print_scaling": options['$[]']("print_scaling")}))
            } else {
            return Opal.const_get_qualified(Opal.const_get_qualified(Opal.const_get_relative($nesting, 'PDF'), 'Core'), 'ObjectStore').$new($hash2(["info"], {"info": options['$[]']("info")}))
          }; return nil; })();
          self.version = 1.3;
          self.pages = [];
          self.page = nil;
          self.trailer = options.$fetch("trailer", $hash2([], {}));
          self.compress = options.$fetch("compress", false);
          self.encrypt = options.$fetch("encrypt", false);
          self.encryption_key = options['$[]']("encryption_key");
          self.skip_encoding = options.$fetch("skip_encoding", false);
          self.before_render_callbacks = [];
          return (self.on_page_create_callback = nil);
        }, TMP_DocumentState_initialize_1.$$arity = 1);
        self.$attr_accessor("store", "version", "pages", "page", "trailer", "compress", "encrypt", "encryption_key", "skip_encoding", "before_render_callbacks", "on_page_create_callback");
        
        Opal.defn(self, '$populate_pages_from_store', TMP_DocumentState_populate_pages_from_store_3 = function $$populate_pages_from_store(document) {
          var $a, TMP_2, self = this, count = nil;

          
          if ($truthy(($truthy($a = $rb_le(self.store.$page_count(), 0)) ? $a : self.pages['$empty?']()['$!']()))) {
            return 0};
          count = Opal.Range.$new(1, self.store.$page_count(), false);
          return (self.pages = $send(count, 'map', [], (TMP_2 = function(index){var self = TMP_2.$$s || this, orig_dict_id = nil;
            if (self.store == null) self.store = nil;
if (index == null) index = nil;
          
            orig_dict_id = self.store.$object_id_for_page(index);
            return Opal.const_get_qualified(Opal.const_get_qualified(Opal.const_get_relative($nesting, 'PDF'), 'Core'), 'Page').$new(document, $hash2(["object_id"], {"object_id": orig_dict_id}));}, TMP_2.$$s = self, TMP_2.$$arity = 1, TMP_2)));
        }, TMP_DocumentState_populate_pages_from_store_3.$$arity = 1);
        
        Opal.defn(self, '$normalize_metadata', TMP_DocumentState_normalize_metadata_4 = function $$normalize_metadata(options) {
          var $a, self = this, $writer = nil, $logical_op_recvr_tmp_3 = nil, $logical_op_recvr_tmp_4 = nil;

          
          ($truthy($a = options['$[]']("info")) ? $a : (($writer = ["info", $hash2([], {})]), $send(options, '[]=', Opal.to_a($writer)), $writer[$rb_minus($writer["length"], 1)]));
          
          $logical_op_recvr_tmp_3 = options['$[]']("info");
          ($truthy($a = $logical_op_recvr_tmp_3['$[]']("Creator")) ? $a : (($writer = ["Creator", "Prawn"]), $send($logical_op_recvr_tmp_3, '[]=', Opal.to_a($writer)), $writer[$rb_minus($writer["length"], 1)]));;
          
          $logical_op_recvr_tmp_4 = options['$[]']("info");
          ($truthy($a = $logical_op_recvr_tmp_4['$[]']("Producer")) ? $a : (($writer = ["Producer", "Prawn"]), $send($logical_op_recvr_tmp_4, '[]=', Opal.to_a($writer)), $writer[$rb_minus($writer["length"], 1)]));;
          return options['$[]']("info");
        }, TMP_DocumentState_normalize_metadata_4.$$arity = 1);
        
        Opal.defn(self, '$insert_page', TMP_DocumentState_insert_page_5 = function $$insert_page(page, page_number) {
          var self = this, $binary_op_recvr_tmp_1 = nil, $writer = nil;

          
          self.$pages().$insert(page_number, page);
          self.$store().$pages().$data()['$[]']("Kids").$insert(page_number, page.$dictionary());
          
          $binary_op_recvr_tmp_1 = self.$store().$pages().$data();
          
          $writer = ["Count", $rb_plus($binary_op_recvr_tmp_1['$[]']("Count"), 1)];
          $send($binary_op_recvr_tmp_1, '[]=', Opal.to_a($writer));
          return $writer[$rb_minus($writer["length"], 1)];;;
        }, TMP_DocumentState_insert_page_5.$$arity = 2);
        
        Opal.defn(self, '$on_page_create_action', TMP_DocumentState_on_page_create_action_6 = function $$on_page_create_action(doc) {
          var self = this;

          if ($truthy(self.$on_page_create_callback())) {
            return self.$on_page_create_callback()['$[]'](doc)
            } else {
            return nil
          }
        }, TMP_DocumentState_on_page_create_action_6.$$arity = 1);
        
        Opal.defn(self, '$before_render_actions', TMP_DocumentState_before_render_actions_8 = function $$before_render_actions(_doc) {
          var TMP_7, self = this;

          return $send(self.$before_render_callbacks(), 'each', [], (TMP_7 = function(c){var self = TMP_7.$$s || this;
if (c == null) c = nil;
          return c.$call(self)}, TMP_7.$$s = self, TMP_7.$$arity = 1, TMP_7))
        }, TMP_DocumentState_before_render_actions_8.$$arity = 1);
        
        Opal.defn(self, '$page_count', TMP_DocumentState_page_count_9 = function $$page_count() {
          var self = this;

          return self.$pages().$length()
        }, TMP_DocumentState_page_count_9.$$arity = 0);
        return (Opal.defn(self, '$render_body', TMP_DocumentState_render_body_11 = function $$render_body(output) {
          var TMP_10, self = this;

          return $send(self.$store(), 'each', [], (TMP_10 = function(ref){var self = TMP_10.$$s || this, $writer = nil;
            if (self.encrypt == null) self.encrypt = nil;
            if (self.encryption_key == null) self.encryption_key = nil;
if (ref == null) ref = nil;
          
            
            $writer = [output.$size()];
            $send(ref, 'offset=', Opal.to_a($writer));
            $writer[$rb_minus($writer["length"], 1)];;
            return output['$<<']((function() {if ($truthy(self.encrypt)) {
              return ref.$encrypted_object(self.encryption_key)
              } else {
              return ref.$object()
            }; return nil; })());}, TMP_10.$$s = self, TMP_10.$$arity = 1, TMP_10))
        }, TMP_DocumentState_render_body_11.$$arity = 1), nil) && 'render_body';
      })($nesting[0], null, $nesting)
    })($nesting[0], $nesting)
  })($nesting[0], $nesting)
};

/* Generated by Opal 0.11.0 */
Opal.modules["pdf/core/name_tree"] = function(Opal) {
  function $rb_minus(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs - rhs : lhs['$-'](rhs);
  }
  function $rb_gt(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs > rhs : lhs['$>'](rhs);
  }
  function $rb_ge(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs >= rhs : lhs['$>='](rhs);
  }
  function $rb_plus(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs + rhs : lhs['$+'](rhs);
  }
  function $rb_divide(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs / rhs : lhs['$/'](rhs);
  }
  var self = Opal.top, $nesting = [], nil = Opal.nil, $breaker = Opal.breaker, $slice = Opal.slice, $module = Opal.module, $klass = Opal.klass, $truthy = Opal.truthy, $send = Opal.send, $hash2 = Opal.hash2;

  Opal.add_stubs(['$require', '$attr_reader', '$attr_accessor', '$empty?', '$children', '$leaf?', '$size', '$reduce', '$map', '$to_proc', '$is_a?', '$first', '$<<', '$new', '$parent', '$least', '$greatest', '$[]=', '$-', '$name', '$last', '$insert', '$insertion_point', '$>', '$length', '$limit', '$split!', '$detect', '$>=', '$split', '$new_node', '$split_children', '$replace', '$dup', '$instance_variable_set', '$deep_clone', '$ref', '$deep_copy', '$protected', '$index', '$+', '$private', '$document', '$ref!', '$ref=', '$/', '$[]', '$each', '$parent=', '$each_with_index', '$include', '$<=>', '$inspect', '$value']);
  
  self.$require("pdf/core/utils");
  return (function($base, $parent_nesting) {
    var $PDF, self = $PDF = $module($base, 'PDF');

    var def = self.$$proto, $nesting = [self].concat($parent_nesting);

    (function($base, $parent_nesting) {
      var $Core, self = $Core = $module($base, 'Core');

      var def = self.$$proto, $nesting = [self].concat($parent_nesting);

      (function($base, $parent_nesting) {
        var $NameTree, self = $NameTree = $module($base, 'NameTree');

        var def = self.$$proto, $nesting = [self].concat($parent_nesting);

        
        (function($base, $super, $parent_nesting) {
          function $Node(){};
          var self = $Node = $klass($base, $super, 'Node', $Node);

          var def = self.$$proto, $nesting = [self].concat($parent_nesting), TMP_Node_initialize_1, TMP_Node_empty$q_2, TMP_Node_size_3, TMP_Node_leaf$q_4, TMP_Node_add_5, TMP_Node_to_hash_6, TMP_Node_least_7, TMP_Node_greatest_8, TMP_Node_$lt$lt_10, TMP_Node_$gt$eq_11, TMP_Node_split$B_12, TMP_Node_deep_copy_13, TMP_Node_split_14, TMP_Node_new_node_15, TMP_Node_split_children_18, TMP_Node_insertion_point_20;

          
          self.$attr_reader("children");
          self.$attr_reader("limit");
          self.$attr_reader("document");
          self.$attr_accessor("parent");
          self.$attr_accessor("ref");
          
          Opal.defn(self, '$initialize', TMP_Node_initialize_1 = function $$initialize(document, limit, parent) {
            var self = this;

            if (parent == null) {
              parent = nil;
            }
            
            self.document = document;
            self.children = [];
            self.limit = limit;
            self.parent = parent;
            return (self.ref = nil);
          }, TMP_Node_initialize_1.$$arity = -3);
          
          Opal.defn(self, '$empty?', TMP_Node_empty$q_2 = function() {
            var self = this;

            return self.$children()['$empty?']()
          }, TMP_Node_empty$q_2.$$arity = 0);
          
          Opal.defn(self, '$size', TMP_Node_size_3 = function $$size() {
            var self = this;

            if ($truthy(self['$leaf?']())) {
              return self.$children().$size()
              } else {
              return $send(self.$children(), 'map', [], "size".$to_proc()).$reduce("+")
            }
          }, TMP_Node_size_3.$$arity = 0);
          
          Opal.defn(self, '$leaf?', TMP_Node_leaf$q_4 = function() {
            var $a, self = this;

            return ($truthy($a = self.$children()['$empty?']()) ? $a : self.$children().$first()['$is_a?'](Opal.const_get_relative($nesting, 'Value')))
          }, TMP_Node_leaf$q_4.$$arity = 0);
          
          Opal.defn(self, '$add', TMP_Node_add_5 = function $$add(name, value) {
            var self = this;

            return self['$<<'](Opal.const_get_relative($nesting, 'Value').$new(name, value))
          }, TMP_Node_add_5.$$arity = 2);
          
          Opal.defn(self, '$to_hash', TMP_Node_to_hash_6 = function $$to_hash() {
            var self = this, hash = nil, $writer = nil;

            
            hash = $hash2([], {});
            if ($truthy(self.$parent())) {
              
              $writer = ["Limits", [self.$least(), self.$greatest()]];
              $send(hash, '[]=', Opal.to_a($writer));
              $writer[$rb_minus($writer["length"], 1)];};
            if ($truthy(self['$leaf?']())) {
              if ($truthy(self['$leaf?']())) {
                
                $writer = ["Names", self.$children()];
                $send(hash, '[]=', Opal.to_a($writer));
                $writer[$rb_minus($writer["length"], 1)];}
              } else {
              
              $writer = ["Kids", $send(self.$children(), 'map', [], "ref".$to_proc())];
              $send(hash, '[]=', Opal.to_a($writer));
              $writer[$rb_minus($writer["length"], 1)];
            };
            return hash;
          }, TMP_Node_to_hash_6.$$arity = 0);
          
          Opal.defn(self, '$least', TMP_Node_least_7 = function $$least() {
            var self = this;

            if ($truthy(self['$leaf?']())) {
              return self.$children().$first().$name()
              } else {
              return self.$children().$first().$least()
            }
          }, TMP_Node_least_7.$$arity = 0);
          
          Opal.defn(self, '$greatest', TMP_Node_greatest_8 = function $$greatest() {
            var self = this;

            if ($truthy(self['$leaf?']())) {
              return self.$children().$last().$name()
              } else {
              return self.$children().$last().$greatest()
            }
          }, TMP_Node_greatest_8.$$arity = 0);
          
          Opal.defn(self, '$<<', TMP_Node_$lt$lt_10 = function(value) {
            var TMP_9, self = this, fit = nil;

            
            if ($truthy(self.$children()['$empty?']())) {
              self.$children()['$<<'](value)
            } else if ($truthy(self['$leaf?']())) {
              
              self.$children().$insert(self.$insertion_point(value), value);
              if ($truthy($rb_gt(self.$children().$length(), self.$limit()))) {
                self['$split!']()};
              } else {
              
              fit = $send(self.$children(), 'detect', [], (TMP_9 = function(child){var self = TMP_9.$$s || this;
if (child == null) child = nil;
              return $rb_ge(child, value)}, TMP_9.$$s = self, TMP_9.$$arity = 1, TMP_9));
              if ($truthy(fit)) {
                } else {
                fit = self.$children().$last()
              };
              fit['$<<'](value);
            };
            return value;
          }, TMP_Node_$lt$lt_10.$$arity = 1);
          
          Opal.defn(self, '$>=', TMP_Node_$gt$eq_11 = function(other) {
            var $a, self = this;

            return ($truthy($a = self.$children()['$empty?']()) ? $a : $rb_ge(self.$children().$last(), other))
          }, TMP_Node_$gt$eq_11.$$arity = 1);
          
          Opal.defn(self, '$split!', TMP_Node_split$B_12 = function() {
            var self = this, left = nil, right = nil;

            if ($truthy(self.$parent())) {
              return self.$parent().$split(self)
              } else {
              
              left = self.$new_node(self);
              right = self.$new_node(self);
              self.$split_children(self, left, right);
              return self.$children().$replace([left, right]);
            }
          }, TMP_Node_split$B_12.$$arity = 0);
          
          Opal.defn(self, '$deep_copy', TMP_Node_deep_copy_13 = function $$deep_copy() {
            var self = this, node = nil;

            
            node = self.$dup();
            node.$instance_variable_set("@children", Opal.const_get_relative($nesting, 'Utils').$deep_clone(self.$children()));
            node.$instance_variable_set("@ref", (function() {if ($truthy(node.$ref())) {
              return node.$ref().$deep_copy()
              } else {
              return nil
            }; return nil; })());
            return node;
          }, TMP_Node_deep_copy_13.$$arity = 0);
          self.$protected();
          
          Opal.defn(self, '$split', TMP_Node_split_14 = function $$split(node) {
            var self = this, new_child = nil, index = nil;

            
            new_child = self.$new_node(self);
            self.$split_children(node, node, new_child);
            index = self.$children().$index(node);
            self.$children().$insert($rb_plus(index, 1), new_child);
            if ($truthy($rb_gt(self.$children().$length(), self.$limit()))) {
              return self['$split!']()
              } else {
              return nil
            };
          }, TMP_Node_split_14.$$arity = 1);
          self.$private();
          
          Opal.defn(self, '$new_node', TMP_Node_new_node_15 = function $$new_node(parent) {
            var self = this, node = nil, $writer = nil;

            if (parent == null) {
              parent = nil;
            }
            
            node = Opal.const_get_relative($nesting, 'Node').$new(self.$document(), self.$limit(), parent);
            
            $writer = [self.$document()['$ref!'](node)];
            $send(node, 'ref=', Opal.to_a($writer));
            $writer[$rb_minus($writer["length"], 1)];;
            return node;
          }, TMP_Node_new_node_15.$$arity = -1);
          
          Opal.defn(self, '$split_children', TMP_Node_split_children_18 = function $$split_children(node, left, right) {
            var TMP_16, TMP_17, self = this, half = nil, left_children = nil, right_children = nil;

            
            half = $rb_divide($rb_plus(node.$limit(), 1), 2);
            left_children = node.$children()['$[]'](Opal.Range.$new(0,half, true));
            right_children = node.$children()['$[]'](Opal.Range.$new(half, -1, false));
            left.$children().$replace(left_children);
            right.$children().$replace(right_children);
            if ($truthy(node['$leaf?']())) {
              return nil
              } else {
              
              $send(left_children, 'each', [], (TMP_16 = function(child){var self = TMP_16.$$s || this, $writer = nil;
if (child == null) child = nil;
              
                $writer = [left];
                $send(child, 'parent=', Opal.to_a($writer));
                return $writer[$rb_minus($writer["length"], 1)];}, TMP_16.$$s = self, TMP_16.$$arity = 1, TMP_16));
              return $send(right_children, 'each', [], (TMP_17 = function(child){var self = TMP_17.$$s || this, $writer = nil;
if (child == null) child = nil;
              
                $writer = [right];
                $send(child, 'parent=', Opal.to_a($writer));
                return $writer[$rb_minus($writer["length"], 1)];}, TMP_17.$$s = self, TMP_17.$$arity = 1, TMP_17));
            };
          }, TMP_Node_split_children_18.$$arity = 3);
          return (Opal.defn(self, '$insertion_point', TMP_Node_insertion_point_20 = function $$insertion_point(value) {try {

            var TMP_19, self = this;

            
            $send(self.$children(), 'each_with_index', [], (TMP_19 = function(child, index){var self = TMP_19.$$s || this;
if (child == null) child = nil;if (index == null) index = nil;
            if ($truthy($rb_ge(child, value))) {
                Opal.ret(index)
                } else {
                return nil
              }}, TMP_19.$$s = self, TMP_19.$$arity = 2, TMP_19));
            return self.$children().$length();
            } catch ($returner) { if ($returner === Opal.returner) { return $returner.$v } throw $returner; }
          }, TMP_Node_insertion_point_20.$$arity = 1), nil) && 'insertion_point';
        })($nesting[0], null, $nesting);
        (function($base, $super, $parent_nesting) {
          function $Value(){};
          var self = $Value = $klass($base, $super, 'Value', $Value);

          var def = self.$$proto, $nesting = [self].concat($parent_nesting), TMP_Value_initialize_21, TMP_Value_$lt$eq$gt_22, TMP_Value_inspect_23, TMP_Value_to_s_24;

          
          self.$include(Opal.const_get_relative($nesting, 'Comparable'));
          self.$attr_reader("name");
          self.$attr_reader("value");
          
          Opal.defn(self, '$initialize', TMP_Value_initialize_21 = function $$initialize(name, value) {
            var self = this;

            
            self.name = Opal.const_get_qualified(Opal.const_get_qualified(Opal.const_get_relative($nesting, 'PDF'), 'Core'), 'LiteralString').$new(name);
            return (self.value = value);
          }, TMP_Value_initialize_21.$$arity = 2);
          
          Opal.defn(self, '$<=>', TMP_Value_$lt$eq$gt_22 = function(other) {
            var self = this;

            return self.$name()['$<=>'](other.$name())
          }, TMP_Value_$lt$eq$gt_22.$$arity = 1);
          
          Opal.defn(self, '$inspect', TMP_Value_inspect_23 = function $$inspect() {
            var self = this;

            return "" + "#<Value: " + (self.$name().$inspect()) + " : " + (self.$value().$inspect()) + ">"
          }, TMP_Value_inspect_23.$$arity = 0);
          return (Opal.defn(self, '$to_s', TMP_Value_to_s_24 = function $$to_s() {
            var self = this;

            return "" + (self.$name()) + " : " + (self.$value())
          }, TMP_Value_to_s_24.$$arity = 0), nil) && 'to_s';
        })($nesting[0], null, $nesting);
      })($nesting[0], $nesting)
    })($nesting[0], $nesting)
  })($nesting[0], $nesting);
};

/* Generated by Opal 0.11.0 */
Opal.modules["pdf/core/page_geometry"] = function(Opal) {
  var self = Opal.top, $nesting = [], nil = Opal.nil, $breaker = Opal.breaker, $slice = Opal.slice, $module = Opal.module, $hash2 = Opal.hash2;

  Opal.add_stubs(['$freeze']);
  return (function($base, $parent_nesting) {
    var $PDF, self = $PDF = $module($base, 'PDF');

    var def = self.$$proto, $nesting = [self].concat($parent_nesting);

    (function($base, $parent_nesting) {
      var $Core, self = $Core = $module($base, 'Core');

      var def = self.$$proto, $nesting = [self].concat($parent_nesting);

      (function($base, $parent_nesting) {
        var $PageGeometry, self = $PageGeometry = $module($base, 'PageGeometry');

        var def = self.$$proto, $nesting = [self].concat($parent_nesting);

        Opal.const_set($nesting[0], 'SIZES', $hash2(["4A0", "2A0", "A0", "A1", "A2", "A3", "A4", "A5", "A6", "A7", "A8", "A9", "A10", "B0", "B1", "B2", "B3", "B4", "B5", "B6", "B7", "B8", "B9", "B10", "C0", "C1", "C2", "C3", "C4", "C5", "C6", "C7", "C8", "C9", "C10", "RA0", "RA1", "RA2", "RA3", "RA4", "SRA0", "SRA1", "SRA2", "SRA3", "SRA4", "EXECUTIVE", "FOLIO", "LEGAL", "LETTER", "TABLOID"], {"4A0": [4767.87, 6740.79], "2A0": [3370.39, 4767.87], "A0": [2383.94, 3370.39], "A1": [1683.78, 2383.94], "A2": [1190.55, 1683.78], "A3": [841.89, 1190.55], "A4": [595.28, 841.89], "A5": [419.53, 595.28], "A6": [297.64, 419.53], "A7": [209.76, 297.64], "A8": [147.4, 209.76], "A9": [104.88, 147.4], "A10": [73.7, 104.88], "B0": [2834.65, 4008.19], "B1": [2004.09, 2834.65], "B2": [1417.32, 2004.09], "B3": [1000.63, 1417.32], "B4": [708.66, 1000.63], "B5": [498.9, 708.66], "B6": [354.33, 498.9], "B7": [249.45, 354.33], "B8": [175.75, 249.45], "B9": [124.72, 175.75], "B10": [87.87, 124.72], "C0": [2599.37, 3676.54], "C1": [1836.85, 2599.37], "C2": [1298.27, 1836.85], "C3": [918.43, 1298.27], "C4": [649.13, 918.43], "C5": [459.21, 649.13], "C6": [323.15, 459.21], "C7": [229.61, 323.15], "C8": [161.57, 229.61], "C9": [113.39, 161.57], "C10": [79.37, 113.39], "RA0": [2437.8, 3458.27], "RA1": [1729.13, 2437.8], "RA2": [1218.9, 1729.13], "RA3": [864.57, 1218.9], "RA4": [609.45, 864.57], "SRA0": [2551.18, 3628.35], "SRA1": [1814.17, 2551.18], "SRA2": [1275.59, 1814.17], "SRA3": [907.09, 1275.59], "SRA4": [637.8, 907.09], "EXECUTIVE": [521.86, 756.0], "FOLIO": [612.0, 936.0], "LEGAL": [612.0, 1008.0], "LETTER": [612.0, 792.0], "TABLOID": [792.0, 1224.0]}).$freeze())
      })($nesting[0], $nesting)
    })($nesting[0], $nesting)
  })($nesting[0], $nesting)
};

/* Generated by Opal 0.11.0 */
Opal.modules["pdf/core/outline_root"] = function(Opal) {
  var self = Opal.top, $nesting = [], nil = Opal.nil, $breaker = Opal.breaker, $slice = Opal.slice, $module = Opal.module, $klass = Opal.klass, $hash2 = Opal.hash2;

  Opal.add_stubs(['$attr_accessor', '$count', '$first', '$last']);
  return (function($base, $parent_nesting) {
    var $PDF, self = $PDF = $module($base, 'PDF');

    var def = self.$$proto, $nesting = [self].concat($parent_nesting);

    (function($base, $parent_nesting) {
      var $Core, self = $Core = $module($base, 'Core');

      var def = self.$$proto, $nesting = [self].concat($parent_nesting);

      (function($base, $super, $parent_nesting) {
        function $OutlineRoot(){};
        var self = $OutlineRoot = $klass($base, $super, 'OutlineRoot', $OutlineRoot);

        var def = self.$$proto, $nesting = [self].concat($parent_nesting), TMP_OutlineRoot_initialize_1, TMP_OutlineRoot_to_hash_2;

        
        self.$attr_accessor("count", "first", "last");
        
        Opal.defn(self, '$initialize', TMP_OutlineRoot_initialize_1 = function $$initialize() {
          var self = this;

          return (self.count = 0)
        }, TMP_OutlineRoot_initialize_1.$$arity = 0);
        return (Opal.defn(self, '$to_hash', TMP_OutlineRoot_to_hash_2 = function $$to_hash() {
          var self = this;

          return $hash2(["Type", "Count", "First", "Last"], {"Type": "Outlines", "Count": self.$count(), "First": self.$first(), "Last": self.$last()})
        }, TMP_OutlineRoot_to_hash_2.$$arity = 0), nil) && 'to_hash';
      })($nesting[0], null, $nesting)
    })($nesting[0], $nesting)
  })($nesting[0], $nesting)
};

/* Generated by Opal 0.11.0 */
Opal.modules["pdf/core/outline_item"] = function(Opal) {
  var self = Opal.top, $nesting = [], nil = Opal.nil, $breaker = Opal.breaker, $slice = Opal.slice, $module = Opal.module, $klass = Opal.klass, $hash2 = Opal.hash2, $truthy = Opal.truthy, $send = Opal.send;

  Opal.add_stubs(['$attr_accessor', '$[]', '$title', '$parent', '$closed', '$-@', '$count', '$each', '$first', '$last', '$prev', '$dest', '$nil?', '$values', '$merge!']);
  return (function($base, $parent_nesting) {
    var $PDF, self = $PDF = $module($base, 'PDF');

    var def = self.$$proto, $nesting = [self].concat($parent_nesting);

    (function($base, $parent_nesting) {
      var $Core, self = $Core = $module($base, 'Core');

      var def = self.$$proto, $nesting = [self].concat($parent_nesting);

      (function($base, $super, $parent_nesting) {
        function $OutlineItem(){};
        var self = $OutlineItem = $klass($base, $super, 'OutlineItem', $OutlineItem);

        var def = self.$$proto, $nesting = [self].concat($parent_nesting), TMP_OutlineItem_initialize_1, TMP_OutlineItem_to_hash_3;

        def.next = nil;
        
        self.$attr_accessor("count", "first", "last", "next", "prev", "parent", "title", "dest", "closed");
        
        Opal.defn(self, '$initialize', TMP_OutlineItem_initialize_1 = function $$initialize(title, parent, options) {
          var self = this;

          
          self.closed = options['$[]']("closed");
          self.title = title;
          self.parent = parent;
          return (self.count = 0);
        }, TMP_OutlineItem_initialize_1.$$arity = 3);
        return (Opal.defn(self, '$to_hash', TMP_OutlineItem_to_hash_3 = function $$to_hash() {
          var $a, $b, TMP_2, self = this, hash = nil;

          
          hash = $hash2(["Title", "Parent", "Count"], {"Title": self.$title(), "Parent": self.$parent(), "Count": (function() {if ($truthy(self.$closed())) {
            return self.$count()['$-@']()
            } else {
            return self.$count()
          }; return nil; })()});
          $send([$hash2(["First"], {"First": self.$first()}), $hash2(["Last"], {"Last": self.$last()}), $hash2(["Next"], {"Next": ($truthy($a = (($b = self['next'], $b != null && $b !== nil) ? 'instance-variable' : nil)) ? self.next : $a)}), $hash2(["Prev"], {"Prev": self.$prev()}), $hash2(["Dest"], {"Dest": self.$dest()})], 'each', [], (TMP_2 = function(h){var self = TMP_2.$$s || this;
if (h == null) h = nil;
          if ($truthy(h.$values().$first()['$nil?']())) {
              return nil
              } else {
              return hash['$merge!'](h)
            }}, TMP_2.$$s = self, TMP_2.$$arity = 1, TMP_2));
          return hash;
        }, TMP_OutlineItem_to_hash_3.$$arity = 0), nil) && 'to_hash';
      })($nesting[0], null, $nesting)
    })($nesting[0], $nesting)
  })($nesting[0], $nesting)
};

/* Generated by Opal 0.11.0 */
Opal.modules["pdf/core/renderer"] = function(Opal) {
  function $rb_minus(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs - rhs : lhs['$-'](rhs);
  }
  function $rb_plus(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs + rhs : lhs['$+'](rhs);
  }
  function $rb_gt(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs > rhs : lhs['$>'](rhs);
  }
  var self = Opal.top, $nesting = [], nil = Opal.nil, $breaker = Opal.breaker, $slice = Opal.slice, $module = Opal.module, $klass = Opal.klass, $truthy = Opal.truthy, $hash2 = Opal.hash2, $send = Opal.send;

  Opal.add_stubs(['$require', '$populate_pages_from_store', '$min_version', '$store', '$attr_reader', '$identifier', '$ref!', '$ref', '$state', '$is_a?', '$data', '$nil?', '$graphic_state', '$save_graphics_state', '$<<', '$content', '$page', '$root', '$[]', '$[]=', '$-', '$before_render_callbacks', '$on_page_create_callback=', '$size', '$layout', '$margins', '$dup', '$color_space=', '$new', '$page=', '$insert_page', '$+', '$on_page_create_action', '$page_count', '$pages', '$each', '$go_to_page', '$present?', '$graphic_stack', '$restore_graphics_state', '$finalize', '$>', '$version', '$version=', '$instance_of?', '$set_encoding', '$finalize_all_page_contents', '$render_header', '$render_body', '$render_xref', '$render_trailer', '$string', '$force_encoding', '$open', '$render', '$before_render_actions', '$printf', '$offset', '$info', '$trailer', '$merge!', '$pdf_object', '$add_content', '$save_graphic_state', '$open_graphics_state', '$compress', '$empty?', '$raise', '$close_graphics_state', '$restore_graphic_state', '$stack', '$current_state']);
  
  self.$require("stringio");
  return (function($base, $parent_nesting) {
    var $PDF, self = $PDF = $module($base, 'PDF');

    var def = self.$$proto, $nesting = [self].concat($parent_nesting);

    (function($base, $parent_nesting) {
      var $Core, self = $Core = $module($base, 'Core');

      var def = self.$$proto, $nesting = [self].concat($parent_nesting);

      (function($base, $super, $parent_nesting) {
        function $Renderer(){};
        var self = $Renderer = $klass($base, $super, 'Renderer', $Renderer);

        var def = self.$$proto, $nesting = [self].concat($parent_nesting), TMP_Renderer_initialize_1, TMP_Renderer_ref_2, TMP_Renderer_ref$B_3, TMP_Renderer_deref_4, TMP_Renderer_add_content_5, TMP_Renderer_names_6, TMP_Renderer_names$q_7, TMP_Renderer_before_render_8, TMP_Renderer_on_page_create_9, TMP_Renderer_start_new_page_10, TMP_Renderer_page_count_11, TMP_Renderer_go_to_page_12, TMP_Renderer_finalize_all_page_contents_14, TMP_Renderer_min_version_15, TMP_Renderer_render_16, TMP_Renderer_render_file_18, TMP_Renderer_render_header_19, TMP_Renderer_render_body_20, TMP_Renderer_render_xref_22, TMP_Renderer_render_trailer_23, TMP_Renderer_open_graphics_state_24, TMP_Renderer_close_graphics_state_25, TMP_Renderer_save_graphics_state_26, TMP_Renderer_compression_enabled$q_27, TMP_Renderer_restore_graphics_state_28, TMP_Renderer_graphic_stack_29, TMP_Renderer_graphic_state_30;

        def.state = def.page_number = def.xref_offset = nil;
        
        
        Opal.defn(self, '$initialize', TMP_Renderer_initialize_1 = function $$initialize(state) {
          var self = this;

          
          self.state = state;
          self.state.$populate_pages_from_store(self);
          if ($truthy(state.$store().$min_version())) {
            self.$min_version(state.$store().$min_version())};
          return (self.page_number = 0);
        }, TMP_Renderer_initialize_1.$$arity = 1);
        self.$attr_reader("state");
        
        Opal.defn(self, '$ref', TMP_Renderer_ref_2 = function $$ref(data) {
          var self = this;

          return self['$ref!'](data).$identifier()
        }, TMP_Renderer_ref_2.$$arity = 1);
        
        Opal.defn(self, '$ref!', TMP_Renderer_ref$B_3 = function(data) {
          var self = this;

          return self.$state().$store().$ref(data)
        }, TMP_Renderer_ref$B_3.$$arity = 1);
        
        Opal.defn(self, '$deref', TMP_Renderer_deref_4 = function $$deref(obj) {
          var self = this;

          if ($truthy(obj['$is_a?'](Opal.const_get_qualified(Opal.const_get_qualified(Opal.const_get_relative($nesting, 'PDF'), 'Core'), 'Reference')))) {
            return obj.$data()
            } else {
            return obj
          }
        }, TMP_Renderer_deref_4.$$arity = 1);
        
        Opal.defn(self, '$add_content', TMP_Renderer_add_content_5 = function $$add_content(str) {
          var self = this;

          
          if ($truthy(self.$graphic_state()['$nil?']())) {
            self.$save_graphics_state()};
          return self.$state().$page().$content()['$<<'](str)['$<<']("\n");
        }, TMP_Renderer_add_content_5.$$arity = 1);
        
        Opal.defn(self, '$names', TMP_Renderer_names_6 = function $$names() {
          var $a, self = this, $logical_op_recvr_tmp_5 = nil, $writer = nil;

          
          $logical_op_recvr_tmp_5 = self.$state().$store().$root().$data();
          return ($truthy($a = $logical_op_recvr_tmp_5['$[]']("Names")) ? $a : (($writer = ["Names", self['$ref!']($hash2(["Type"], {"Type": "Names"}))]), $send($logical_op_recvr_tmp_5, '[]=', Opal.to_a($writer)), $writer[$rb_minus($writer["length"], 1)]));
        }, TMP_Renderer_names_6.$$arity = 0);
        
        Opal.defn(self, '$names?', TMP_Renderer_names$q_7 = function() {
          var self = this;

          return self.$state().$store().$root().$data()['$[]']("Names")
        }, TMP_Renderer_names$q_7.$$arity = 0);
        
        Opal.defn(self, '$before_render', TMP_Renderer_before_render_8 = function $$before_render() {
          var self = this, $iter = TMP_Renderer_before_render_8.$$p, block = $iter || nil;

          if ($iter) TMP_Renderer_before_render_8.$$p = null;
          return self.$state().$before_render_callbacks()['$<<'](block)
        }, TMP_Renderer_before_render_8.$$arity = 0);
        
        Opal.defn(self, '$on_page_create', TMP_Renderer_on_page_create_9 = function $$on_page_create() {
          var self = this, $iter = TMP_Renderer_on_page_create_9.$$p, block = $iter || nil, $writer = nil;

          if ($iter) TMP_Renderer_on_page_create_9.$$p = null;
          
          $writer = [(function() {if ((block !== nil)) {
            return block
            } else {
            return nil
          }; return nil; })()];
          $send(self.$state(), 'on_page_create_callback=', Opal.to_a($writer));
          return $writer[$rb_minus($writer["length"], 1)];
        }, TMP_Renderer_on_page_create_9.$$arity = 0);
        
        Opal.defn(self, '$start_new_page', TMP_Renderer_start_new_page_10 = function $$start_new_page(options) {
          var $a, self = this, last_page = nil, last_page_size = nil, last_page_layout = nil, last_page_margins = nil, page_options = nil, new_graphic_state = nil, $writer = nil;

          if (options == null) {
            options = $hash2([], {});
          }
          
          last_page = self.$state().$page();
          if ($truthy(last_page)) {
            
            last_page_size = last_page.$size();
            last_page_layout = last_page.$layout();
            last_page_margins = last_page.$margins();};
          page_options = $hash2(["size", "layout", "margins"], {"size": ($truthy($a = options['$[]']("size")) ? $a : last_page_size), "layout": ($truthy($a = options['$[]']("layout")) ? $a : last_page_layout), "margins": last_page_margins});
          if ($truthy(last_page)) {
            
            if ($truthy(last_page.$graphic_state())) {
              new_graphic_state = last_page.$graphic_state().$dup()};
            if ($truthy(new_graphic_state)) {
              
              $writer = [$hash2([], {})];
              $send(new_graphic_state, 'color_space=', Opal.to_a($writer));
              $writer[$rb_minus($writer["length"], 1)];};
            
            $writer = ["graphic_state", new_graphic_state];
            $send(page_options, '[]=', Opal.to_a($writer));
            $writer[$rb_minus($writer["length"], 1)];;};
          
          $writer = [Opal.const_get_qualified(Opal.const_get_qualified(Opal.const_get_relative($nesting, 'PDF'), 'Core'), 'Page').$new(self, page_options)];
          $send(self.$state(), 'page=', Opal.to_a($writer));
          $writer[$rb_minus($writer["length"], 1)];;
          self.$state().$insert_page(self.$state().$page(), self.page_number);
          self.page_number = $rb_plus(self.page_number, 1);
          return self.$state().$on_page_create_action(self);
        }, TMP_Renderer_start_new_page_10.$$arity = -1);
        
        Opal.defn(self, '$page_count', TMP_Renderer_page_count_11 = function $$page_count() {
          var self = this;

          return self.$state().$page_count()
        }, TMP_Renderer_page_count_11.$$arity = 0);
        
        Opal.defn(self, '$go_to_page', TMP_Renderer_go_to_page_12 = function $$go_to_page(k) {
          var self = this, $writer = nil;

          
          self.page_number = k;
          
          $writer = [self.$state().$pages()['$[]']($rb_minus(k, 1))];
          $send(self.$state(), 'page=', Opal.to_a($writer));
          return $writer[$rb_minus($writer["length"], 1)];;
        }, TMP_Renderer_go_to_page_12.$$arity = 1);
        
        Opal.defn(self, '$finalize_all_page_contents', TMP_Renderer_finalize_all_page_contents_14 = function $$finalize_all_page_contents() {
          var TMP_13, self = this;

          return $send(Opal.Range.$new(1, self.$page_count(), false), 'each', [], (TMP_13 = function(i){var self = TMP_13.$$s || this, $a;
if (i == null) i = nil;
          
            self.$go_to_page(i);
            while ($truthy(self.$graphic_stack()['$present?']())) {
              self.$restore_graphics_state()
            };
            return self.$state().$page().$finalize();}, TMP_13.$$s = self, TMP_13.$$arity = 1, TMP_13))
        }, TMP_Renderer_finalize_all_page_contents_14.$$arity = 0);
        
        Opal.defn(self, '$min_version', TMP_Renderer_min_version_15 = function $$min_version(min) {
          var self = this, $writer = nil;

          if ($truthy($rb_gt(min, self.$state().$version()))) {
            
            $writer = [min];
            $send(self.$state(), 'version=', Opal.to_a($writer));
            return $writer[$rb_minus($writer["length"], 1)];
            } else {
            return nil
          }
        }, TMP_Renderer_min_version_15.$$arity = 1);
        
        Opal.defn(self, '$render', TMP_Renderer_render_16 = function $$render(output) {
          var self = this, str = nil;

          if (output == null) {
            output = Opal.const_get_relative($nesting, 'StringIO').$new();
          }
          
          if ($truthy(output['$instance_of?'](Opal.const_get_relative($nesting, 'StringIO')))) {
            output.$set_encoding(Opal.const_get_qualified(Opal.const_get_qualified('::', 'Encoding'), 'ASCII_8BIT'))};
          self.$finalize_all_page_contents();
          self.$render_header(output);
          self.$render_body(output);
          self.$render_xref(output);
          self.$render_trailer(output);
          if ($truthy(output['$instance_of?'](Opal.const_get_relative($nesting, 'StringIO')))) {
            
            str = output.$string();
            str.$force_encoding(Opal.const_get_qualified(Opal.const_get_qualified('::', 'Encoding'), 'ASCII_8BIT'));
            return str;
            } else {
            return nil
          };
        }, TMP_Renderer_render_16.$$arity = -1);
        
        Opal.defn(self, '$render_file', TMP_Renderer_render_file_18 = function $$render_file(filename) {
          var TMP_17, self = this;

          return $send(Opal.const_get_relative($nesting, 'File'), 'open', [filename, "wb"], (TMP_17 = function(f){var self = TMP_17.$$s || this;
if (f == null) f = nil;
          return self.$render(f)}, TMP_17.$$s = self, TMP_17.$$arity = 1, TMP_17))
        }, TMP_Renderer_render_file_18.$$arity = 1);
        
        Opal.defn(self, '$render_header', TMP_Renderer_render_header_19 = function $$render_header(output) {
          var self = this;

          
          self.$state().$before_render_actions(self);
          output['$<<']("" + "%PDF-" + (self.$state().$version()) + "\n");
          return output['$<<']("%0xFF0xFF0xFF0xFF\n");
        }, TMP_Renderer_render_header_19.$$arity = 1);
        
        Opal.defn(self, '$render_body', TMP_Renderer_render_body_20 = function $$render_body(output) {
          var self = this;

          return self.$state().$render_body(output)
        }, TMP_Renderer_render_body_20.$$arity = 1);
        
        Opal.defn(self, '$render_xref', TMP_Renderer_render_xref_22 = function $$render_xref(output) {
          var TMP_21, self = this;

          
          self.xref_offset = output.$size();
          output['$<<']("xref\n");
          output['$<<']("" + "0 " + ($rb_plus(self.$state().$store().$size(), 1)) + "\n");
          output['$<<']("0000000000 65535 f \n");
          return $send(self.$state().$store(), 'each', [], (TMP_21 = function(ref){var self = TMP_21.$$s || this;
if (ref == null) ref = nil;
          
            output.$printf("%010d", ref.$offset());
            return output['$<<'](" 00000 n \n");}, TMP_21.$$s = self, TMP_21.$$arity = 1, TMP_21));
        }, TMP_Renderer_render_xref_22.$$arity = 1);
        
        Opal.defn(self, '$render_trailer', TMP_Renderer_render_trailer_23 = function $$render_trailer(output) {
          var self = this, trailer_hash = nil;

          
          trailer_hash = $hash2(["Size", "Root", "Info"], {"Size": $rb_plus(self.$state().$store().$size(), 1), "Root": self.$state().$store().$root(), "Info": self.$state().$store().$info()});
          if ($truthy(self.$state().$trailer())) {
            trailer_hash['$merge!'](self.$state().$trailer())};
          output['$<<']("trailer\n");
          output['$<<'](Opal.const_get_qualified(Opal.const_get_relative($nesting, 'PDF'), 'Core').$pdf_object(trailer_hash))['$<<']("\n");
          output['$<<']("startxref\n");
          output['$<<'](self.xref_offset)['$<<']("\n");
          return output['$<<']("%%EOF")['$<<']("\n");
        }, TMP_Renderer_render_trailer_23.$$arity = 1);
        
        Opal.defn(self, '$open_graphics_state', TMP_Renderer_open_graphics_state_24 = function $$open_graphics_state() {
          var self = this;

          return self.$add_content("q")
        }, TMP_Renderer_open_graphics_state_24.$$arity = 0);
        
        Opal.defn(self, '$close_graphics_state', TMP_Renderer_close_graphics_state_25 = function $$close_graphics_state() {
          var self = this;

          return self.$add_content("Q")
        }, TMP_Renderer_close_graphics_state_25.$$arity = 0);
        
        Opal.defn(self, '$save_graphics_state', TMP_Renderer_save_graphics_state_26 = function $$save_graphics_state(graphic_state) {
          var self = this, $iter = TMP_Renderer_save_graphics_state_26.$$p, $yield = $iter || nil;

          if (graphic_state == null) {
            graphic_state = nil;
          }
          if ($iter) TMP_Renderer_save_graphics_state_26.$$p = null;
          
          self.$graphic_stack().$save_graphic_state(graphic_state);
          self.$open_graphics_state();
          if (($yield !== nil)) {
            
            Opal.yieldX($yield, []);
            return self.$restore_graphics_state();
            } else {
            return nil
          };
        }, TMP_Renderer_save_graphics_state_26.$$arity = -1);
        
        Opal.defn(self, '$compression_enabled?', TMP_Renderer_compression_enabled$q_27 = function() {
          var self = this;

          return self.$state().$compress()
        }, TMP_Renderer_compression_enabled$q_27.$$arity = 0);
        
        Opal.defn(self, '$restore_graphics_state', TMP_Renderer_restore_graphics_state_28 = function $$restore_graphics_state() {
          var self = this;

          
          if ($truthy(self.$graphic_stack()['$empty?']())) {
            self.$raise(Opal.const_get_qualified(Opal.const_get_qualified(Opal.const_get_qualified(Opal.const_get_relative($nesting, 'PDF'), 'Core'), 'Errors'), 'EmptyGraphicStateStack'), "\n You have reached the end of the graphic state stack")};
          self.$close_graphics_state();
          return self.$graphic_stack().$restore_graphic_state();
        }, TMP_Renderer_restore_graphics_state_28.$$arity = 0);
        
        Opal.defn(self, '$graphic_stack', TMP_Renderer_graphic_stack_29 = function $$graphic_stack() {
          var self = this;

          return self.$state().$page().$stack()
        }, TMP_Renderer_graphic_stack_29.$$arity = 0);
        return (Opal.defn(self, '$graphic_state', TMP_Renderer_graphic_state_30 = function $$graphic_state() {
          var self = this;

          
          if ($truthy(self.$graphic_stack().$current_state())) {
            } else {
            self.$save_graphics_state()
          };
          return self.$graphic_stack().$current_state();
        }, TMP_Renderer_graphic_state_30.$$arity = 0), nil) && 'graphic_state';
      })($nesting[0], null, $nesting)
    })($nesting[0], $nesting)
  })($nesting[0], $nesting);
};

/* Generated by Opal 0.11.0 */
Opal.modules["pdf/core/text"] = function(Opal) {
  function $rb_minus(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs - rhs : lhs['$-'](rhs);
  }
  function $rb_divide(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs / rhs : lhs['$/'](rhs);
  }
  function $rb_times(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs * rhs : lhs['$*'](rhs);
  }
  var self = Opal.top, $nesting = [], nil = Opal.nil, $breaker = Opal.breaker, $slice = Opal.slice, $module = Opal.module, $hash2 = Opal.hash2, $truthy = Opal.truthy, $send = Opal.send;

  Opal.add_stubs(['$freeze', '$attr_reader', '$[]', '$family', '$font', '$raise', '$==', '$has_kerning_data?', '$[]=', '$-', '$font_size', '$nil?', '$key?', '$join', '$keys', '$text_rendering_mode', '$add_content', '$character_spacing', '$real', '$word_spacing', '$horizontal_text_scaling', '$encode_text', '$/', '$*', '$to_f', '$cos', '$sin', '$-@', '$real_params', '$each', '$add_to_current_page', '$identifier_for', '$is_a?', '$<<', '$pdf_object']);
  return (function($base, $parent_nesting) {
    var $PDF, self = $PDF = $module($base, 'PDF');

    var def = self.$$proto, $nesting = [self].concat($parent_nesting);

    (function($base, $parent_nesting) {
      var $Core, self = $Core = $module($base, 'Core');

      var def = self.$$proto, $nesting = [self].concat($parent_nesting);

      (function($base, $parent_nesting) {
        var $Text, self = $Text = $module($base, 'Text');

        var def = self.$$proto, $nesting = [self].concat($parent_nesting), TMP_Text_process_text_options_1, TMP_Text_default_kerning$q_2, TMP_Text_default_kerning_3, TMP_Text_default_leading_4, TMP_Text_text_direction_5, TMP_Text_fallback_fonts_6, TMP_Text_text_rendering_mode_7, TMP_Text_forget_text_rendering_mode$B_8, TMP_Text_character_spacing_9, TMP_Text_word_spacing_10, TMP_Text_horizontal_text_scaling_11, TMP_Text_add_text_content_13;

        
        Opal.const_set($nesting[0], 'VALID_OPTIONS', ["kerning", "size", "style"].$freeze());
        Opal.const_set($nesting[0], 'MODES', $hash2(["fill", "stroke", "fill_stroke", "invisible", "fill_clip", "stroke_clip", "fill_stroke_clip", "clip"], {"fill": 0, "stroke": 1, "fill_stroke": 2, "invisible": 3, "fill_clip": 4, "stroke_clip": 5, "fill_stroke_clip": 6, "clip": 7}).$freeze());
        self.$attr_reader("skip_encoding");
        
        Opal.defn(self, '$process_text_options', TMP_Text_process_text_options_1 = function $$process_text_options(options) {
          var $a, self = this, $writer = nil;

          
          if ($truthy(options['$[]']("style"))) {
            
            if ($truthy(self.$font().$family())) {
              } else {
              self.$raise("Bad font family")
            };
            self.$font(self.$font().$family(), $hash2(["style"], {"style": options['$[]']("style")}));};
          if (options['$[]']("kerning")['$=='](false)) {
            } else {
            
            $writer = ["kerning", self.$font()['$has_kerning_data?']()];
            $send(options, '[]=', Opal.to_a($writer));
            $writer[$rb_minus($writer["length"], 1)];
          };
          return ($truthy($a = options['$[]']("size")) ? $a : (($writer = ["size", self.$font_size()]), $send(options, '[]=', Opal.to_a($writer)), $writer[$rb_minus($writer["length"], 1)]));
        }, TMP_Text_process_text_options_1.$$arity = 1);
        
        Opal.defn(self, '$default_kerning?', TMP_Text_default_kerning$q_2 = function() {
          var $a, self = this;
          if (self.default_kerning == null) self.default_kerning = nil;

          
          if ($truthy((($a = self['default_kerning'], $a != null && $a !== nil) ? 'instance-variable' : nil))) {
            } else {
            return true
          };
          return self.default_kerning;
        }, TMP_Text_default_kerning$q_2.$$arity = 0);
        
        Opal.defn(self, '$default_kerning', TMP_Text_default_kerning_3 = function $$default_kerning(boolean$) {
          var self = this;

          return (self.default_kerning = boolean$)
        }, TMP_Text_default_kerning_3.$$arity = 1);
        Opal.alias(self, "default_kerning=", "default_kerning");
        
        Opal.defn(self, '$default_leading', TMP_Text_default_leading_4 = function $$default_leading(number) {
          var $a, $b, $c, self = this;
          if (self.default_leading == null) self.default_leading = nil;

          if (number == null) {
            number = nil;
          }
          if ($truthy(number['$nil?']())) {
            return ($truthy($a = ($truthy($b = (($c = self['default_leading'], $c != null && $c !== nil) ? 'instance-variable' : nil)) ? self.default_leading : $b)) ? $a : 0)
            } else {
            return (self.default_leading = number)
          }
        }, TMP_Text_default_leading_4.$$arity = -1);
        Opal.alias(self, "default_leading=", "default_leading");
        
        Opal.defn(self, '$text_direction', TMP_Text_text_direction_5 = function $$text_direction(direction) {
          var $a, $b, $c, self = this;
          if (self.text_direction == null) self.text_direction = nil;

          if (direction == null) {
            direction = nil;
          }
          if ($truthy(direction['$nil?']())) {
            return ($truthy($a = ($truthy($b = (($c = self['text_direction'], $c != null && $c !== nil) ? 'instance-variable' : nil)) ? self.text_direction : $b)) ? $a : "ltr")
            } else {
            return (self.text_direction = direction)
          }
        }, TMP_Text_text_direction_5.$$arity = -1);
        Opal.alias(self, "text_direction=", "text_direction");
        
        Opal.defn(self, '$fallback_fonts', TMP_Text_fallback_fonts_6 = function $$fallback_fonts(fallback_fonts) {
          var $a, $b, $c, self = this;
          if (self.fallback_fonts == null) self.fallback_fonts = nil;

          if (fallback_fonts == null) {
            fallback_fonts = nil;
          }
          if ($truthy(fallback_fonts['$nil?']())) {
            return ($truthy($a = ($truthy($b = (($c = self['fallback_fonts'], $c != null && $c !== nil) ? 'instance-variable' : nil)) ? self.fallback_fonts : $b)) ? $a : [])
            } else {
            return (self.fallback_fonts = fallback_fonts)
          }
        }, TMP_Text_fallback_fonts_6.$$arity = -1);
        Opal.alias(self, "fallback_fonts=", "fallback_fonts");
        
        Opal.defn(self, '$text_rendering_mode', TMP_Text_text_rendering_mode_7 = function $$text_rendering_mode(mode) {
          var $a, $b, $c, self = this, $iter = TMP_Text_text_rendering_mode_7.$$p, $yield = $iter || nil, original_mode = nil;
          if (self.text_rendering_mode == null) self.text_rendering_mode = nil;

          if (mode == null) {
            mode = nil;
          }
          if ($iter) TMP_Text_text_rendering_mode_7.$$p = null;
          
          if ($truthy(mode['$nil?']())) {
            return ($truthy($a = ($truthy($b = (($c = self['text_rendering_mode'], $c != null && $c !== nil) ? 'instance-variable' : nil)) ? self.text_rendering_mode : $b)) ? $a : "fill")};
          if ($truthy(Opal.const_get_relative($nesting, 'MODES')['$key?'](mode))) {
            } else {
            self.$raise(Opal.const_get_relative($nesting, 'ArgumentError'), "" + "mode must be between one of " + (Opal.const_get_relative($nesting, 'MODES').$keys().$join(", ")) + " (" + (mode) + ")")
          };
          original_mode = self.$text_rendering_mode();
          if (original_mode['$=='](mode)) {
            return Opal.yieldX($yield, []);
            } else {
            
            self.text_rendering_mode = mode;
            self.$add_content("" + "\n" + (Opal.const_get_relative($nesting, 'MODES')['$[]'](mode)) + " Tr");
            Opal.yieldX($yield, []);
            self.$add_content("" + "\n" + (Opal.const_get_relative($nesting, 'MODES')['$[]'](original_mode)) + " Tr");
            return (self.text_rendering_mode = original_mode);
          };
        }, TMP_Text_text_rendering_mode_7.$$arity = -1);
        
        Opal.defn(self, '$forget_text_rendering_mode!', TMP_Text_forget_text_rendering_mode$B_8 = function() {
          var self = this;

          return (self.text_rendering_mode = "unknown")
        }, TMP_Text_forget_text_rendering_mode$B_8.$$arity = 0);
        
        Opal.defn(self, '$character_spacing', TMP_Text_character_spacing_9 = function $$character_spacing(amount) {
          var $a, $b, $c, self = this, $iter = TMP_Text_character_spacing_9.$$p, $yield = $iter || nil, original_character_spacing = nil;
          if (self.character_spacing == null) self.character_spacing = nil;

          if (amount == null) {
            amount = nil;
          }
          if ($iter) TMP_Text_character_spacing_9.$$p = null;
          
          if ($truthy(amount['$nil?']())) {
            return ($truthy($a = ($truthy($b = (($c = self['character_spacing'], $c != null && $c !== nil) ? 'instance-variable' : nil)) ? self.character_spacing : $b)) ? $a : 0)};
          original_character_spacing = self.$character_spacing();
          if (original_character_spacing['$=='](amount)) {
            return Opal.yieldX($yield, []);
            } else {
            
            self.character_spacing = amount;
            self.$add_content("" + "\n" + (Opal.const_get_qualified(Opal.const_get_relative($nesting, 'PDF'), 'Core').$real(amount)) + " Tc");
            Opal.yieldX($yield, []);
            self.$add_content("" + "\n" + (Opal.const_get_qualified(Opal.const_get_relative($nesting, 'PDF'), 'Core').$real(original_character_spacing)) + " Tc");
            return (self.character_spacing = original_character_spacing);
          };
        }, TMP_Text_character_spacing_9.$$arity = -1);
        
        Opal.defn(self, '$word_spacing', TMP_Text_word_spacing_10 = function $$word_spacing(amount) {
          var $a, $b, $c, self = this, $iter = TMP_Text_word_spacing_10.$$p, $yield = $iter || nil, original_word_spacing = nil;
          if (self.word_spacing == null) self.word_spacing = nil;

          if (amount == null) {
            amount = nil;
          }
          if ($iter) TMP_Text_word_spacing_10.$$p = null;
          
          if ($truthy(amount['$nil?']())) {
            return ($truthy($a = ($truthy($b = (($c = self['word_spacing'], $c != null && $c !== nil) ? 'instance-variable' : nil)) ? self.word_spacing : $b)) ? $a : 0)};
          original_word_spacing = self.$word_spacing();
          if (original_word_spacing['$=='](amount)) {
            return Opal.yieldX($yield, []);
            } else {
            
            self.word_spacing = amount;
            self.$add_content("" + "\n" + (Opal.const_get_qualified(Opal.const_get_relative($nesting, 'PDF'), 'Core').$real(amount)) + " Tw");
            Opal.yieldX($yield, []);
            self.$add_content("" + "\n" + (Opal.const_get_qualified(Opal.const_get_relative($nesting, 'PDF'), 'Core').$real(original_word_spacing)) + " Tw");
            return (self.word_spacing = original_word_spacing);
          };
        }, TMP_Text_word_spacing_10.$$arity = -1);
        
        Opal.defn(self, '$horizontal_text_scaling', TMP_Text_horizontal_text_scaling_11 = function $$horizontal_text_scaling(amount) {
          var $a, $b, $c, self = this, $iter = TMP_Text_horizontal_text_scaling_11.$$p, $yield = $iter || nil, original_horizontal_text_scaling = nil;
          if (self.horizontal_text_scaling == null) self.horizontal_text_scaling = nil;

          if (amount == null) {
            amount = nil;
          }
          if ($iter) TMP_Text_horizontal_text_scaling_11.$$p = null;
          
          if ($truthy(amount['$nil?']())) {
            return ($truthy($a = ($truthy($b = (($c = self['horizontal_text_scaling'], $c != null && $c !== nil) ? 'instance-variable' : nil)) ? self.horizontal_text_scaling : $b)) ? $a : 100)};
          original_horizontal_text_scaling = self.$horizontal_text_scaling();
          if (original_horizontal_text_scaling['$=='](amount)) {
            return Opal.yieldX($yield, []);
            } else {
            
            self.horizontal_text_scaling = amount;
            self.$add_content("" + "\n" + (Opal.const_get_qualified(Opal.const_get_relative($nesting, 'PDF'), 'Core').$real(amount)) + " Tz");
            Opal.yieldX($yield, []);
            self.$add_content("" + "\n" + (Opal.const_get_qualified(Opal.const_get_relative($nesting, 'PDF'), 'Core').$real(original_horizontal_text_scaling)) + " Tz");
            return (self.horizontal_text_scaling = original_horizontal_text_scaling);
          };
        }, TMP_Text_horizontal_text_scaling_11.$$arity = -1);
        
        Opal.defn(self, '$add_text_content', TMP_Text_add_text_content_13 = function $$add_text_content(text, x, y, options) {
          var TMP_12, self = this, chunks = nil, rad = nil, array = nil;

          
          chunks = self.$font().$encode_text(text, options);
          self.$add_content("\nBT");
          if ($truthy(options['$[]']("rotate"))) {
            
            rad = $rb_divide($rb_times(options['$[]']("rotate").$to_f(), Opal.const_get_qualified(Opal.const_get_relative($nesting, 'Math'), 'PI')), 180);
            array = [Opal.const_get_relative($nesting, 'Math').$cos(rad), Opal.const_get_relative($nesting, 'Math').$sin(rad), Opal.const_get_relative($nesting, 'Math').$sin(rad)['$-@'](), Opal.const_get_relative($nesting, 'Math').$cos(rad), x, y];
            self.$add_content("" + (Opal.const_get_qualified(Opal.const_get_relative($nesting, 'PDF'), 'Core').$real_params(array)) + " Tm");
            } else {
            self.$add_content("" + (Opal.const_get_qualified(Opal.const_get_relative($nesting, 'PDF'), 'Core').$real_params([x, y])) + " Td")
          };
          $send(chunks, 'each', [], (TMP_12 = function($a){var self = TMP_12.$$s || this, $a_args, subset, string, $b, operation = nil;

            if ($a == null) {
              $a = nil;
            }
            $a = Opal.to_ary($a);
            $a_args = Opal.slice.call($a, 0, $a.length);
            subset = $a_args.splice(0,1)[0];
            if (subset == null) {
              subset = nil;
            }
            string = $a_args.splice(0,1)[0];
            if (string == null) {
              string = nil;
            }
          
            self.$font().$add_to_current_page(subset);
            self.$add_content("" + "/" + (self.$font().$identifier_for(subset)) + " " + (self.$font_size()) + " Tf");
            operation = (function() {if ($truthy(($truthy($b = options['$[]']("kerning")) ? string['$is_a?'](Opal.const_get_relative($nesting, 'Array')) : $b))) {
              return "TJ"
              } else {
              return "Tj"
            }; return nil; })();
            return self.$add_content(Opal.const_get_qualified(Opal.const_get_relative($nesting, 'PDF'), 'Core').$pdf_object(string, true)['$<<'](" ")['$<<'](operation));}, TMP_12.$$s = self, TMP_12.$$arity = 1, TMP_12.$$has_top_level_mlhs_arg = true, TMP_12));
          return self.$add_content("ET\n");
        }, TMP_Text_add_text_content_13.$$arity = 4);
      })($nesting[0], $nesting)
    })($nesting[0], $nesting)
  })($nesting[0], $nesting)
};

/* Generated by Opal 0.11.0 */
Opal.modules["pdf/core"] = function(Opal) {
  var self = Opal.top, $nesting = [], nil = Opal.nil, $breaker = Opal.breaker, $slice = Opal.slice, $module = Opal.module;

  Opal.add_stubs(['$new']);
  
  self.$require("pdf/core"+ '/../' + "core/pdf_object");
  self.$require("pdf/core"+ '/../' + "core/annotations");
  self.$require("pdf/core"+ '/../' + "core/byte_string");
  self.$require("pdf/core"+ '/../' + "core/destinations");
  self.$require("pdf/core"+ '/../' + "core/filters");
  self.$require("pdf/core"+ '/../' + "core/stream");
  self.$require("pdf/core"+ '/../' + "core/reference");
  self.$require("pdf/core"+ '/../' + "core/literal_string");
  self.$require("pdf/core"+ '/../' + "core/filter_list");
  self.$require("pdf/core"+ '/../' + "core/page");
  self.$require("pdf/core"+ '/../' + "core/object_store");
  self.$require("pdf/core"+ '/../' + "core/document_state");
  self.$require("pdf/core"+ '/../' + "core/name_tree");
  self.$require("pdf/core"+ '/../' + "core/graphics_state");
  self.$require("pdf/core"+ '/../' + "core/page_geometry");
  self.$require("pdf/core"+ '/../' + "core/outline_root");
  self.$require("pdf/core"+ '/../' + "core/outline_item");
  self.$require("pdf/core"+ '/../' + "core/renderer");
  self.$require("pdf/core"+ '/../' + "core/text");
  return (function($base, $parent_nesting) {
    var $PDF, self = $PDF = $module($base, 'PDF');

    var def = self.$$proto, $nesting = [self].concat($parent_nesting);

    (function($base, $parent_nesting) {
      var $Core, self = $Core = $module($base, 'Core');

      var def = self.$$proto, $nesting = [self].concat($parent_nesting);

      (function($base, $parent_nesting) {
        var $Errors, self = $Errors = $module($base, 'Errors');

        var def = self.$$proto, $nesting = [self].concat($parent_nesting);

        
        Opal.const_set($nesting[0], 'FailedObjectConversion', Opal.const_get_relative($nesting, 'Class').$new(Opal.const_get_relative($nesting, 'StandardError')));
        Opal.const_set($nesting[0], 'EmptyGraphicStateStack', Opal.const_get_relative($nesting, 'Class').$new(Opal.const_get_relative($nesting, 'StandardError')));
        Opal.const_set($nesting[0], 'InvalidPageLayout', Opal.const_get_relative($nesting, 'Class').$new(Opal.const_get_relative($nesting, 'StandardError')));
      })($nesting[0], $nesting)
    })($nesting[0], $nesting)
  })($nesting[0], $nesting);
};

/* Generated by Opal 0.11.0 */
Opal.modules["prawn/version"] = function(Opal) {
  var self = Opal.top, $nesting = [], nil = Opal.nil, $breaker = Opal.breaker, $slice = Opal.slice, $module = Opal.module;

  return (function($base, $parent_nesting) {
    var $Prawn, self = $Prawn = $module($base, 'Prawn');

    var def = self.$$proto, $nesting = [self].concat($parent_nesting);

    Opal.const_set($nesting[0], 'VERSION', "2.1.0")
  })($nesting[0], $nesting)
};

/* Generated by Opal 0.11.0 */
Opal.modules["prawn/errors"] = function(Opal) {
  var self = Opal.top, $nesting = [], nil = Opal.nil, $breaker = Opal.breaker, $slice = Opal.slice, $module = Opal.module;

  Opal.add_stubs(['$new']);
  return (function($base, $parent_nesting) {
    var $Prawn, self = $Prawn = $module($base, 'Prawn');

    var def = self.$$proto, $nesting = [self].concat($parent_nesting);

    (function($base, $parent_nesting) {
      var $Errors, self = $Errors = $module($base, 'Errors');

      var def = self.$$proto, $nesting = [self].concat($parent_nesting);

      
      Opal.const_set($nesting[0], 'InvalidTableSpan', Opal.const_get_relative($nesting, 'Class').$new(Opal.const_get_relative($nesting, 'StandardError')));
      Opal.const_set($nesting[0], 'NotOnPage', Opal.const_get_relative($nesting, 'Class').$new(Opal.const_get_relative($nesting, 'StandardError')));
      Opal.const_set($nesting[0], 'UnknownFont', Opal.const_get_relative($nesting, 'Class').$new(Opal.const_get_relative($nesting, 'StandardError')));
      Opal.const_set($nesting[0], 'CannotFit', Opal.const_get_relative($nesting, 'Class').$new(Opal.const_get_relative($nesting, 'StandardError')));
      Opal.const_set($nesting[0], 'CannotGroup', Opal.const_get_relative($nesting, 'Class').$new(Opal.const_get_relative($nesting, 'StandardError')));
      Opal.const_set($nesting[0], 'IncompatibleStringEncoding', Opal.const_get_relative($nesting, 'Class').$new(Opal.const_get_relative($nesting, 'StandardError')));
      Opal.const_set($nesting[0], 'UnknownOption', Opal.const_get_relative($nesting, 'Class').$new(Opal.const_get_relative($nesting, 'StandardError')));
      Opal.const_set($nesting[0], 'UnsupportedImageType', Opal.const_get_relative($nesting, 'Class').$new(Opal.const_get_relative($nesting, 'StandardError')));
      Opal.const_set($nesting[0], 'NameTaken', Opal.const_get_relative($nesting, 'Class').$new(Opal.const_get_relative($nesting, 'StandardError')));
      Opal.const_set($nesting[0], 'InvalidName', Opal.const_get_relative($nesting, 'Class').$new(Opal.const_get_relative($nesting, 'StandardError')));
      Opal.const_set($nesting[0], 'UndefinedObjectName', Opal.const_get_relative($nesting, 'Class').$new(Opal.const_get_relative($nesting, 'StandardError')));
      Opal.const_set($nesting[0], 'RequiredOption', Opal.const_get_relative($nesting, 'Class').$new(Opal.const_get_relative($nesting, 'StandardError')));
      Opal.const_set($nesting[0], 'UnknownOutlineTitle', Opal.const_get_relative($nesting, 'Class').$new(Opal.const_get_relative($nesting, 'StandardError')));
      Opal.const_set($nesting[0], 'BlockRequired', Opal.const_get_relative($nesting, 'Class').$new(Opal.const_get_relative($nesting, 'StandardError')));
      Opal.const_set($nesting[0], 'InvalidGraphicsPath', Opal.const_get_relative($nesting, 'Class').$new(Opal.const_get_relative($nesting, 'StandardError')));
      Opal.const_set($nesting[0], 'UnrecognizedTableContent', Opal.const_get_relative($nesting, 'Class').$new(Opal.const_get_relative($nesting, 'StandardError')));
    })($nesting[0], $nesting)
  })($nesting[0], $nesting)
};

/* Generated by Opal 0.11.0 */
Opal.modules["thread"] = function(Opal) {
  function $rb_minus(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs - rhs : lhs['$-'](rhs);
  }
  var self = Opal.top, $nesting = [], nil = Opal.nil, $breaker = Opal.breaker, $slice = Opal.slice, $klass = Opal.klass, $truthy = Opal.truthy, $send = Opal.send, $hash2 = Opal.hash2;

  Opal.add_stubs(['$allocate', '$core_initialize!', '$current', '$fail', '$[]', '$coerce_key_name', '$[]=', '$-', '$key?', '$keys', '$private', '$coerce_to!', '$public', '$clear', '$empty?', '$size', '$shift', '$push', '$each', '$to_proc', '$locked?', '$lock', '$unlock']);
  
  (function($base, $super, $parent_nesting) {
    function $ThreadError(){};
    var self = $ThreadError = $klass($base, $super, 'ThreadError', $ThreadError);

    var def = self.$$proto, $nesting = [self].concat($parent_nesting);

    return nil
  })($nesting[0], Opal.const_get_relative($nesting, 'StandardError'), $nesting);
  (function($base, $super, $parent_nesting) {
    function $Thread(){};
    var self = $Thread = $klass($base, $super, 'Thread', $Thread);

    var def = self.$$proto, $nesting = [self].concat($parent_nesting), TMP_Thread_current_1, TMP_Thread_list_2, TMP_Thread_initialize_3, TMP_Thread_$$_4, TMP_Thread_$$$eq_5, TMP_Thread_key$q_6, TMP_Thread_keys_7, TMP_Thread_thread_variable_get_8, TMP_Thread_thread_variable_set_9, TMP_Thread_thread_variable$q_10, TMP_Thread_thread_variables_11, TMP_Thread_core_initialize$B_12, TMP_Thread_coerce_key_name_13;

    def.fiber_locals = def.thread_locals = nil;
    
    Opal.defs(self, '$current', TMP_Thread_current_1 = function $$current() {
      var self = this;
      if (self.current == null) self.current = nil;

      
      if ($truthy(self.current)) {
        } else {
        
        self.current = self.$allocate();
        self.current['$core_initialize!']();
      };
      return self.current;
    }, TMP_Thread_current_1.$$arity = 0);
    Opal.defs(self, '$list', TMP_Thread_list_2 = function $$list() {
      var self = this;

      return [self.$current()]
    }, TMP_Thread_list_2.$$arity = 0);
    
    Opal.defn(self, '$initialize', TMP_Thread_initialize_3 = function $$initialize($a_rest) {
      var self = this, args;

      var $args_len = arguments.length, $rest_len = $args_len - 0;
      if ($rest_len < 0) { $rest_len = 0; }
      args = new Array($rest_len);
      for (var $arg_idx = 0; $arg_idx < $args_len; $arg_idx++) {
        args[$arg_idx - 0] = arguments[$arg_idx];
      }
      return self.$fail(Opal.const_get_relative($nesting, 'NotImplementedError'), "Thread creation not available")
    }, TMP_Thread_initialize_3.$$arity = -1);
    
    Opal.defn(self, '$[]', TMP_Thread_$$_4 = function(key) {
      var self = this;

      return self.fiber_locals['$[]'](self.$coerce_key_name(key))
    }, TMP_Thread_$$_4.$$arity = 1);
    
    Opal.defn(self, '$[]=', TMP_Thread_$$$eq_5 = function(key, value) {
      var self = this, $writer = nil;

      
      $writer = [self.$coerce_key_name(key), value];
      $send(self.fiber_locals, '[]=', Opal.to_a($writer));
      return $writer[$rb_minus($writer["length"], 1)];
    }, TMP_Thread_$$$eq_5.$$arity = 2);
    
    Opal.defn(self, '$key?', TMP_Thread_key$q_6 = function(key) {
      var self = this;

      return self.fiber_locals['$key?'](self.$coerce_key_name(key))
    }, TMP_Thread_key$q_6.$$arity = 1);
    
    Opal.defn(self, '$keys', TMP_Thread_keys_7 = function $$keys() {
      var self = this;

      return self.fiber_locals.$keys()
    }, TMP_Thread_keys_7.$$arity = 0);
    
    Opal.defn(self, '$thread_variable_get', TMP_Thread_thread_variable_get_8 = function $$thread_variable_get(key) {
      var self = this;

      return self.thread_locals['$[]'](self.$coerce_key_name(key))
    }, TMP_Thread_thread_variable_get_8.$$arity = 1);
    
    Opal.defn(self, '$thread_variable_set', TMP_Thread_thread_variable_set_9 = function $$thread_variable_set(key, value) {
      var self = this, $writer = nil;

      
      $writer = [self.$coerce_key_name(key), value];
      $send(self.thread_locals, '[]=', Opal.to_a($writer));
      return $writer[$rb_minus($writer["length"], 1)];
    }, TMP_Thread_thread_variable_set_9.$$arity = 2);
    
    Opal.defn(self, '$thread_variable?', TMP_Thread_thread_variable$q_10 = function(key) {
      var self = this;

      return self.thread_locals['$key?'](self.$coerce_key_name(key))
    }, TMP_Thread_thread_variable$q_10.$$arity = 1);
    
    Opal.defn(self, '$thread_variables', TMP_Thread_thread_variables_11 = function $$thread_variables() {
      var self = this;

      return self.thread_locals.$keys()
    }, TMP_Thread_thread_variables_11.$$arity = 0);
    self.$private();
    
    Opal.defn(self, '$core_initialize!', TMP_Thread_core_initialize$B_12 = function() {
      var self = this;

      
      self.thread_locals = $hash2([], {});
      return (self.fiber_locals = $hash2([], {}));
    }, TMP_Thread_core_initialize$B_12.$$arity = 0);
    
    Opal.defn(self, '$coerce_key_name', TMP_Thread_coerce_key_name_13 = function $$coerce_key_name(key) {
      var self = this;

      return Opal.const_get_relative($nesting, 'Opal')['$coerce_to!'](key, Opal.const_get_relative($nesting, 'String'), "to_s")
    }, TMP_Thread_coerce_key_name_13.$$arity = 1);
    self.$public();
    return (function($base, $super, $parent_nesting) {
      function $Queue(){};
      var self = $Queue = $klass($base, $super, 'Queue', $Queue);

      var def = self.$$proto, $nesting = [self].concat($parent_nesting), TMP_Queue_initialize_14, TMP_Queue_clear_15, TMP_Queue_empty$q_16, TMP_Queue_size_17, TMP_Queue_pop_18, TMP_Queue_push_19, TMP_Queue_each_20;

      def.storage = nil;
      
      
      Opal.defn(self, '$initialize', TMP_Queue_initialize_14 = function $$initialize() {
        var self = this;

        return self.$clear()
      }, TMP_Queue_initialize_14.$$arity = 0);
      
      Opal.defn(self, '$clear', TMP_Queue_clear_15 = function $$clear() {
        var self = this;

        return (self.storage = [])
      }, TMP_Queue_clear_15.$$arity = 0);
      
      Opal.defn(self, '$empty?', TMP_Queue_empty$q_16 = function() {
        var self = this;

        return self.storage['$empty?']()
      }, TMP_Queue_empty$q_16.$$arity = 0);
      
      Opal.defn(self, '$size', TMP_Queue_size_17 = function $$size() {
        var self = this;

        return self.storage.$size()
      }, TMP_Queue_size_17.$$arity = 0);
      Opal.alias(self, "length", "size");
      
      Opal.defn(self, '$pop', TMP_Queue_pop_18 = function $$pop(non_block) {
        var self = this;

        if (non_block == null) {
          non_block = false;
        }
        
        if ($truthy(self['$empty?']())) {
          
          if ($truthy(non_block)) {
            self.$fail(Opal.const_get_relative($nesting, 'ThreadError'), "Queue empty")};
          self.$fail(Opal.const_get_relative($nesting, 'ThreadError'), "Deadlock");};
        return self.storage.$shift();
      }, TMP_Queue_pop_18.$$arity = -1);
      Opal.alias(self, "shift", "pop");
      Opal.alias(self, "deq", "pop");
      
      Opal.defn(self, '$push', TMP_Queue_push_19 = function $$push(value) {
        var self = this;

        return self.storage.$push(value)
      }, TMP_Queue_push_19.$$arity = 1);
      Opal.alias(self, "<<", "push");
      Opal.alias(self, "enq", "push");
      return (Opal.defn(self, '$each', TMP_Queue_each_20 = function $$each() {
        var self = this, $iter = TMP_Queue_each_20.$$p, block = $iter || nil;

        if ($iter) TMP_Queue_each_20.$$p = null;
        return $send(self.storage, 'each', [], block.$to_proc())
      }, TMP_Queue_each_20.$$arity = 0), nil) && 'each';
    })($nesting[0], null, $nesting);
  })($nesting[0], null, $nesting);
  Opal.const_set($nesting[0], 'Queue', Opal.const_get_qualified(Opal.const_get_relative($nesting, 'Thread'), 'Queue'));
  return (function($base, $super, $parent_nesting) {
    function $Mutex(){};
    var self = $Mutex = $klass($base, $super, 'Mutex', $Mutex);

    var def = self.$$proto, $nesting = [self].concat($parent_nesting), TMP_Mutex_initialize_21, TMP_Mutex_lock_22, TMP_Mutex_locked$q_23, TMP_Mutex_owned$q_24, TMP_Mutex_try_lock_25, TMP_Mutex_unlock_26, TMP_Mutex_synchronize_27;

    def.locked = nil;
    
    
    Opal.defn(self, '$initialize', TMP_Mutex_initialize_21 = function $$initialize() {
      var self = this;

      return (self.locked = false)
    }, TMP_Mutex_initialize_21.$$arity = 0);
    
    Opal.defn(self, '$lock', TMP_Mutex_lock_22 = function $$lock() {
      var self = this;

      
      if ($truthy(self.locked)) {
        self.$fail(Opal.const_get_relative($nesting, 'ThreadError'), "Deadlock")};
      self.locked = true;
      return self;
    }, TMP_Mutex_lock_22.$$arity = 0);
    
    Opal.defn(self, '$locked?', TMP_Mutex_locked$q_23 = function() {
      var self = this;

      return self.locked
    }, TMP_Mutex_locked$q_23.$$arity = 0);
    
    Opal.defn(self, '$owned?', TMP_Mutex_owned$q_24 = function() {
      var self = this;

      return self.locked
    }, TMP_Mutex_owned$q_24.$$arity = 0);
    
    Opal.defn(self, '$try_lock', TMP_Mutex_try_lock_25 = function $$try_lock() {
      var self = this;

      if ($truthy(self['$locked?']())) {
        return false
        } else {
        
        self.$lock();
        return true;
      }
    }, TMP_Mutex_try_lock_25.$$arity = 0);
    
    Opal.defn(self, '$unlock', TMP_Mutex_unlock_26 = function $$unlock() {
      var self = this;

      
      if ($truthy(self.locked)) {
        } else {
        self.$fail(Opal.const_get_relative($nesting, 'ThreadError'), "Mutex not locked")
      };
      self.locked = false;
      return self;
    }, TMP_Mutex_unlock_26.$$arity = 0);
    return (Opal.defn(self, '$synchronize', TMP_Mutex_synchronize_27 = function $$synchronize() {
      var self = this, $iter = TMP_Mutex_synchronize_27.$$p, $yield = $iter || nil;

      if ($iter) TMP_Mutex_synchronize_27.$$p = null;
      
      self.$lock();
      
      return (function() { try {
      return Opal.yieldX($yield, []);
      } finally {
        self.$unlock()
      }; })();;
    }, TMP_Mutex_synchronize_27.$$arity = 0), nil) && 'synchronize';
  })($nesting[0], null, $nesting);
};

/* Generated by Opal 0.11.0 */
Opal.modules["prawn/utilities"] = function(Opal) {
  function $rb_minus(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs - rhs : lhs['$-'](rhs);
  }
  var self = Opal.top, $nesting = [], nil = Opal.nil, $breaker = Opal.breaker, $slice = Opal.slice, $module = Opal.module, $klass = Opal.klass, $hash2 = Opal.hash2, $send = Opal.send, $truthy = Opal.truthy;

  Opal.add_stubs(['$require', '$new', '$synchronize', '$[]', '$[]=', '$-', '$to_sym', '$object_id', '$current']);
  
  self.$require("thread");
  return (function($base, $parent_nesting) {
    var $Prawn, self = $Prawn = $module($base, 'Prawn');

    var def = self.$$proto, $nesting = [self].concat($parent_nesting);

    
    (function($base, $super, $parent_nesting) {
      function $SynchronizedCache(){};
      var self = $SynchronizedCache = $klass($base, $super, 'SynchronizedCache', $SynchronizedCache);

      var def = self.$$proto, $nesting = [self].concat($parent_nesting), TMP_SynchronizedCache_initialize_1, TMP_SynchronizedCache_$$_3, TMP_SynchronizedCache_$$$eq_5;

      def.mutex = nil;
      
      
      Opal.defn(self, '$initialize', TMP_SynchronizedCache_initialize_1 = function $$initialize() {
        var self = this;

        
        self.cache = $hash2([], {});
        return (self.mutex = Opal.const_get_relative($nesting, 'Mutex').$new());
      }, TMP_SynchronizedCache_initialize_1.$$arity = 0);
      
      Opal.defn(self, '$[]', TMP_SynchronizedCache_$$_3 = function(key) {
        var TMP_2, self = this;

        return $send(self.mutex, 'synchronize', [], (TMP_2 = function(){var self = TMP_2.$$s || this;
          if (self.cache == null) self.cache = nil;

        return self.cache['$[]'](key)}, TMP_2.$$s = self, TMP_2.$$arity = 0, TMP_2))
      }, TMP_SynchronizedCache_$$_3.$$arity = 1);
      return (Opal.defn(self, '$[]=', TMP_SynchronizedCache_$$$eq_5 = function(key, value) {
        var TMP_4, self = this;

        return $send(self.mutex, 'synchronize', [], (TMP_4 = function(){var self = TMP_4.$$s || this, $writer = nil;
          if (self.cache == null) self.cache = nil;

        
          $writer = [key, value];
          $send(self.cache, '[]=', Opal.to_a($writer));
          return $writer[$rb_minus($writer["length"], 1)];}, TMP_4.$$s = self, TMP_4.$$arity = 0, TMP_4))
      }, TMP_SynchronizedCache_$$$eq_5.$$arity = 2), nil) && '[]=';
    })($nesting[0], null, $nesting);
    (function($base, $super, $parent_nesting) {
      function $ThreadLocalCache(){};
      var self = $ThreadLocalCache = $klass($base, $super, 'ThreadLocalCache', $ThreadLocalCache);

      var def = self.$$proto, $nesting = [self].concat($parent_nesting), TMP_ThreadLocalCache_initialize_6, TMP_ThreadLocalCache_$$_7, TMP_ThreadLocalCache_$$$eq_8;

      def.cache_id = nil;
      
      
      Opal.defn(self, '$initialize', TMP_ThreadLocalCache_initialize_6 = function $$initialize() {
        var self = this;

        return (self.cache_id = (("" + "cache_") + (self.$object_id())).$to_sym())
      }, TMP_ThreadLocalCache_initialize_6.$$arity = 0);
      
      Opal.defn(self, '$[]', TMP_ThreadLocalCache_$$_7 = function(key) {
        var $a, self = this, $logical_op_recvr_tmp_6 = nil, $writer = nil;

        return (($logical_op_recvr_tmp_6 = Opal.const_get_relative($nesting, 'Thread').$current()), ($truthy($a = $logical_op_recvr_tmp_6['$[]'](self.cache_id)) ? $a : (($writer = [self.cache_id, $hash2([], {})]), $send($logical_op_recvr_tmp_6, '[]=', Opal.to_a($writer)), $writer[$rb_minus($writer["length"], 1)])))['$[]'](key)
      }, TMP_ThreadLocalCache_$$_7.$$arity = 1);
      return (Opal.defn(self, '$[]=', TMP_ThreadLocalCache_$$$eq_8 = function(key, value) {
        var $a, self = this, $writer = nil, $logical_op_recvr_tmp_7 = nil;

        
        $writer = [key, value];
        $send((($logical_op_recvr_tmp_7 = Opal.const_get_relative($nesting, 'Thread').$current()), ($truthy($a = $logical_op_recvr_tmp_7['$[]'](self.cache_id)) ? $a : $logical_op_recvr_tmp_7['$[]='](self.cache_id, $hash2([], {})))), '[]=', Opal.to_a($writer));
        return $writer[$rb_minus($writer["length"], 1)];
      }, TMP_ThreadLocalCache_$$$eq_8.$$arity = 2), nil) && '[]=';
    })($nesting[0], null, $nesting);
  })($nesting[0], $nesting);
};

/* Generated by Opal 0.11.0 */
Opal.modules["prawn/text/formatted/line_wrap"] = function(Opal) {
  function $rb_le(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs <= rhs : lhs['$<='](rhs);
  }
  function $rb_plus(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs + rhs : lhs['$+'](rhs);
  }
  function $rb_minus(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs - rhs : lhs['$-'](rhs);
  }
  var self = Opal.top, $nesting = [], nil = Opal.nil, $breaker = Opal.breaker, $slice = Opal.slice, $module = Opal.module, $klass = Opal.klass, $truthy = Opal.truthy, $send = Opal.send, $hash2 = Opal.hash2;

  Opal.add_stubs(['$attr_reader', '$is_next_string_newline?', '$finished?', '$scan', '$scan_pattern', '$initialize_line', '$next_string', '$first_fragment_on_this_line?', '$lstrip!', '$empty_line?', '$apply_font_settings_and_add_fragment_to_line', '$finalize_line', '$line_width', '$space_count', '$line', '$private', '$line_empty?', '$!=', '$empty?', '$update_last_string', '$soft_hyphen', '$==', '$preview_next_string', '$apply_font_settings', '$set_soft_hyphen_and_zero_width_space', '$add_fragment_to_line', '$each', '$tokenize', '$zero_width_space', '$width_of', '$<=', '$+', '$[]', '$-', '$end_of_the_line_reached', '$fragment_finished', '$break_chars', '$hyphen', '$whitespace', '$new', '$font', '$normalize_encoding', '$unicode?', '$update_output_based_on_last_fragment', '$update_line_status_based_on_last_output', '$determine_whether_to_pull_preceding_fragment_to_join_this_one', '$remember_this_fragment_for_backward_looking_ops', '$slice', '$length', '$line_finished?', '$!', '$strip', '$fail', '$previous_fragment_ended_with_breakable?', '$fragment_begins_with_breakable?', '$dup', '$=~', '$nil?', '$paragraph_finished?', '$word_division_scan_pattern', '$wrap_by_char', '$each_char', '$append_char', '$compute_width_of', '$<<']);
  return (function($base, $parent_nesting) {
    var $Prawn, self = $Prawn = $module($base, 'Prawn');

    var def = self.$$proto, $nesting = [self].concat($parent_nesting);

    (function($base, $parent_nesting) {
      var $Text, self = $Text = $module($base, 'Text');

      var def = self.$$proto, $nesting = [self].concat($parent_nesting);

      (function($base, $parent_nesting) {
        var $Formatted, self = $Formatted = $module($base, 'Formatted');

        var def = self.$$proto, $nesting = [self].concat($parent_nesting);

        (function($base, $super, $parent_nesting) {
          function $LineWrap(){};
          var self = $LineWrap = $klass($base, $super, 'LineWrap', $LineWrap);

          var def = self.$$proto, $nesting = [self].concat($parent_nesting), TMP_LineWrap_width_1, TMP_LineWrap_paragraph_finished$q_2, TMP_LineWrap_tokenize_3, TMP_LineWrap_wrap_line_4, TMP_LineWrap_first_fragment_on_this_line$q_5, TMP_LineWrap_empty_line$q_6, TMP_LineWrap_is_next_string_newline$q_7, TMP_LineWrap_apply_font_settings_and_add_fragment_to_line_9, TMP_LineWrap_add_fragment_to_line_11, TMP_LineWrap_scan_pattern_12, TMP_LineWrap_word_division_scan_pattern_13, TMP_LineWrap_break_chars_14, TMP_LineWrap_whitespace_15, TMP_LineWrap_hyphen_16, TMP_LineWrap_line_empty$q_17, TMP_LineWrap_initialize_line_18, TMP_LineWrap_set_soft_hyphen_and_zero_width_space_19, TMP_LineWrap_fragment_finished_20, TMP_LineWrap_update_output_based_on_last_fragment_21, TMP_LineWrap_determine_whether_to_pull_preceding_fragment_to_join_this_one_22, TMP_LineWrap_remember_this_fragment_for_backward_looking_ops_23, TMP_LineWrap_previous_fragment_ended_with_breakable$q_24, TMP_LineWrap_fragment_begins_with_breakable$q_25, TMP_LineWrap_line_finished$q_26, TMP_LineWrap_update_line_status_based_on_last_output_27, TMP_LineWrap_end_of_the_line_reached_28, TMP_LineWrap_wrap_by_char_30, TMP_LineWrap_append_char_31;

          def.accumulated_width = def.newline_encountered = def.arranger = def.line_empty = def.document = def.fragment_output = def.line_contains_more_than_one_word = def.previous_fragment_output_without_last_word = def.previous_fragment = def.previous_fragment_ended_with_breakable = def.line_full = def.disable_wrap_by_char = def.width = nil;
          
          
          Opal.defn(self, '$width', TMP_LineWrap_width_1 = function $$width() {
            var $a, self = this;

            return ($truthy($a = self.accumulated_width) ? $a : 0)
          }, TMP_LineWrap_width_1.$$arity = 0);
          self.$attr_reader("space_count");
          self.$attr_reader("soft_hyphen");
          self.$attr_reader("zero_width_space");
          
          Opal.defn(self, '$paragraph_finished?', TMP_LineWrap_paragraph_finished$q_2 = function() {
            var $a, $b, self = this;

            return ($truthy($a = ($truthy($b = self.newline_encountered) ? $b : self['$is_next_string_newline?']())) ? $a : self.arranger['$finished?']())
          }, TMP_LineWrap_paragraph_finished$q_2.$$arity = 0);
          
          Opal.defn(self, '$tokenize', TMP_LineWrap_tokenize_3 = function $$tokenize(fragment) {
            var self = this;

            return fragment.$scan(self.$scan_pattern())
          }, TMP_LineWrap_tokenize_3.$$arity = 1);
          
          Opal.defn(self, '$wrap_line', TMP_LineWrap_wrap_line_4 = function $$wrap_line(options) {
            var $a, self = this, fragment = nil;

            
            self.$initialize_line(options);
            while ($truthy((fragment = self.arranger.$next_string()))) {
              
              self.fragment_output = "";
              if ($truthy(self['$first_fragment_on_this_line?'](fragment))) {
                fragment['$lstrip!']()};
              if ($truthy(self['$empty_line?'](fragment))) {
                continue;};
              if ($truthy(self.$apply_font_settings_and_add_fragment_to_line(fragment))) {
                } else {
                break;
              };
            };
            self.arranger.$finalize_line();
            self.accumulated_width = self.arranger.$line_width();
            self.space_count = self.arranger.$space_count();
            return self.arranger.$line();
          }, TMP_LineWrap_wrap_line_4.$$arity = 1);
          self.$private();
          
          Opal.defn(self, '$first_fragment_on_this_line?', TMP_LineWrap_first_fragment_on_this_line$q_5 = function(fragment) {
            var $a, self = this;

            return ($truthy($a = self['$line_empty?']()) ? fragment['$!=']("\n") : $a)
          }, TMP_LineWrap_first_fragment_on_this_line$q_5.$$arity = 1);
          
          Opal.defn(self, '$empty_line?', TMP_LineWrap_empty_line$q_6 = function(fragment) {
            var $a, $b, self = this, empty = nil;

            
            empty = ($truthy($a = ($truthy($b = self['$line_empty?']()) ? fragment['$empty?']() : $b)) ? self['$is_next_string_newline?']() : $a);
            if ($truthy(empty)) {
              self.arranger.$update_last_string("", "", self.$soft_hyphen())};
            return empty;
          }, TMP_LineWrap_empty_line$q_6.$$arity = 1);
          
          Opal.defn(self, '$is_next_string_newline?', TMP_LineWrap_is_next_string_newline$q_7 = function() {
            var self = this;

            return self.arranger.$preview_next_string()['$==']("\n")
          }, TMP_LineWrap_is_next_string_newline$q_7.$$arity = 0);
          
          Opal.defn(self, '$apply_font_settings_and_add_fragment_to_line', TMP_LineWrap_apply_font_settings_and_add_fragment_to_line_9 = function $$apply_font_settings_and_add_fragment_to_line(fragment) {
            var TMP_8, self = this, result = nil;

            
            result = nil;
            $send(self.arranger, 'apply_font_settings', [], (TMP_8 = function(){var self = TMP_8.$$s || this;

            
              self.$set_soft_hyphen_and_zero_width_space();
              return (result = self.$add_fragment_to_line(fragment));}, TMP_8.$$s = self, TMP_8.$$arity = 0, TMP_8));
            return result;
          }, TMP_LineWrap_apply_font_settings_and_add_fragment_to_line_9.$$arity = 1);
          
          Opal.defn(self, '$add_fragment_to_line', TMP_LineWrap_add_fragment_to_line_11 = function $$add_fragment_to_line(fragment) {try {

            var TMP_10, self = this;

            if (fragment['$==']("")) {
              return true
            } else if (fragment['$==']("\n")) {
              
              self.newline_encountered = true;
              return false;
              } else {
              
              $send(self.$tokenize(fragment), 'each', [], (TMP_10 = function(segment){var self = TMP_10.$$s || this, segment_width = nil, sh_width = nil;
                if (self.document == null) self.document = nil;
                if (self.kerning == null) self.kerning = nil;
                if (self.accumulated_width == null) self.accumulated_width = nil;
                if (self.width == null) self.width = nil;
                if (self.fragment_output == null) self.fragment_output = nil;
if (segment == null) segment = nil;
              
                if (segment['$=='](self.$zero_width_space())) {
                  segment_width = 0
                  } else {
                  segment_width = self.document.$width_of(segment, $hash2(["kerning"], {"kerning": self.kerning}))
                };
                if ($truthy($rb_le($rb_plus(self.accumulated_width, segment_width), self.width))) {
                  
                  self.accumulated_width = $rb_plus(self.accumulated_width, segment_width);
                  if (segment['$[]'](-1)['$=='](self.$soft_hyphen())) {
                    
                    sh_width = self.document.$width_of("" + (self.$soft_hyphen()), $hash2(["kerning"], {"kerning": self.kerning}));
                    self.accumulated_width = $rb_minus(self.accumulated_width, sh_width);};
                  return (self.fragment_output = $rb_plus(self.fragment_output, segment));
                  } else {
                  
                  self.$end_of_the_line_reached(segment);
                  self.$fragment_finished(fragment);
                  Opal.ret(false);
                };}, TMP_10.$$s = self, TMP_10.$$arity = 1, TMP_10));
              self.$fragment_finished(fragment);
              return true;
            }
            } catch ($returner) { if ($returner === Opal.returner) { return $returner.$v } throw $returner; }
          }, TMP_LineWrap_add_fragment_to_line_11.$$arity = 1);
          
          Opal.defn(self, '$scan_pattern', TMP_LineWrap_scan_pattern_12 = function $$scan_pattern() {
            var self = this, pattern = nil;

            
            pattern = "" + ("" + "[^" + (self.$break_chars()) + "]+" + (self.$soft_hyphen()) + "|") + ("" + "[^" + (self.$break_chars()) + "]+" + (self.$hyphen()) + "+|") + ("" + "[^" + (self.$break_chars()) + "]+|") + ("" + "[" + (self.$whitespace()) + "]+|") + ("" + (self.$hyphen()) + "+[^" + (self.$break_chars()) + "]*|") + ("" + (self.$soft_hyphen()));
            return Opal.const_get_relative($nesting, 'Regexp').$new(pattern);
          }, TMP_LineWrap_scan_pattern_12.$$arity = 0);
          
          Opal.defn(self, '$word_division_scan_pattern', TMP_LineWrap_word_division_scan_pattern_13 = function $$word_division_scan_pattern() {
            var self = this;

            return Opal.const_get_relative($nesting, 'Regexp').$new("" + "\\s|[" + (self.$zero_width_space()) + (self.$soft_hyphen()) + (self.$hyphen()) + "]")
          }, TMP_LineWrap_word_division_scan_pattern_13.$$arity = 0);
          
          Opal.defn(self, '$break_chars', TMP_LineWrap_break_chars_14 = function $$break_chars() {
            var self = this;

            return "" + (self.$whitespace()) + (self.$soft_hyphen()) + (self.$hyphen())
          }, TMP_LineWrap_break_chars_14.$$arity = 0);
          
          Opal.defn(self, '$whitespace', TMP_LineWrap_whitespace_15 = function $$whitespace() {
            var self = this;

            return "" + " \\t" + (self.$zero_width_space())
          }, TMP_LineWrap_whitespace_15.$$arity = 0);
          
          Opal.defn(self, '$hyphen', TMP_LineWrap_hyphen_16 = function $$hyphen() {
            var self = this;

            return "-"
          }, TMP_LineWrap_hyphen_16.$$arity = 0);
          
          Opal.defn(self, '$line_empty?', TMP_LineWrap_line_empty$q_17 = function() {
            var $a, self = this;

            return ($truthy($a = self.line_empty) ? self.accumulated_width['$=='](0) : $a)
          }, TMP_LineWrap_line_empty$q_17.$$arity = 0);
          
          Opal.defn(self, '$initialize_line', TMP_LineWrap_initialize_line_18 = function $$initialize_line(options) {
            var self = this;

            
            self.document = options['$[]']("document");
            self.kerning = options['$[]']("kerning");
            self.width = options['$[]']("width");
            self.disable_wrap_by_char = options['$[]']("disable_wrap_by_char");
            self.accumulated_width = 0;
            self.line_empty = true;
            self.line_contains_more_than_one_word = false;
            self.arranger = options['$[]']("arranger");
            self.arranger.$initialize_line();
            self.newline_encountered = false;
            return (self.line_full = false);
          }, TMP_LineWrap_initialize_line_18.$$arity = 1);
          
          Opal.defn(self, '$set_soft_hyphen_and_zero_width_space', TMP_LineWrap_set_soft_hyphen_and_zero_width_space_19 = function $$set_soft_hyphen_and_zero_width_space() {
            var self = this, font = nil;

            
            font = self.document.$font();
            self.soft_hyphen = font.$normalize_encoding(Opal.const_get_qualified(Opal.const_get_qualified(Opal.const_get_relative($nesting, 'Prawn'), 'Text'), 'SHY'));
            return (self.zero_width_space = (function() {if ($truthy(font['$unicode?']())) {
              return Opal.const_get_qualified(Opal.const_get_qualified(Opal.const_get_relative($nesting, 'Prawn'), 'Text'), 'ZWSP')
              } else {
              return ""
            }; return nil; })());
          }, TMP_LineWrap_set_soft_hyphen_and_zero_width_space_19.$$arity = 0);
          
          Opal.defn(self, '$fragment_finished', TMP_LineWrap_fragment_finished_20 = function $$fragment_finished(fragment) {
            var self = this;

            
            if (fragment['$==']("\n")) {
              
              self.newline_encountered = true;
              self.line_empty = false;
              } else {
              
              self.$update_output_based_on_last_fragment(fragment, self.$soft_hyphen());
              self.$update_line_status_based_on_last_output();
              self.$determine_whether_to_pull_preceding_fragment_to_join_this_one(fragment);
            };
            return self.$remember_this_fragment_for_backward_looking_ops();
          }, TMP_LineWrap_fragment_finished_20.$$arity = 1);
          
          Opal.defn(self, '$update_output_based_on_last_fragment', TMP_LineWrap_update_output_based_on_last_fragment_21 = function $$update_output_based_on_last_fragment(fragment, normalized_soft_hyphen) {
            var $a, $b, $c, self = this, remaining_text = nil;

            if (normalized_soft_hyphen == null) {
              normalized_soft_hyphen = nil;
            }
            
            remaining_text = fragment.$slice(Opal.Range.$new(self.fragment_output.$length(), fragment.$length(), false));
            if ($truthy(($truthy($a = ($truthy($b = ($truthy($c = self['$line_finished?']()) ? self['$line_empty?']() : $c)) ? self.fragment_output['$empty?']() : $b)) ? fragment.$strip()['$empty?']()['$!']() : $a))) {
              self.$fail(Opal.const_get_qualified(Opal.const_get_qualified(Opal.const_get_relative($nesting, 'Prawn'), 'Errors'), 'CannotFit'))};
            return self.arranger.$update_last_string(self.fragment_output, remaining_text, normalized_soft_hyphen);
          }, TMP_LineWrap_update_output_based_on_last_fragment_21.$$arity = -2);
          
          Opal.defn(self, '$determine_whether_to_pull_preceding_fragment_to_join_this_one', TMP_LineWrap_determine_whether_to_pull_preceding_fragment_to_join_this_one_22 = function $$determine_whether_to_pull_preceding_fragment_to_join_this_one(current_fragment) {
            var $a, $b, self = this;

            if ($truthy(($truthy($a = ($truthy($b = self.fragment_output['$empty?']()) ? current_fragment['$empty?']()['$!']() : $b)) ? self.line_contains_more_than_one_word : $a))) {
              if ($truthy(($truthy($a = self['$previous_fragment_ended_with_breakable?']()) ? $a : self['$fragment_begins_with_breakable?'](current_fragment)))) {
                return nil
                } else {
                
                self.fragment_output = self.previous_fragment_output_without_last_word;
                return self.$update_output_based_on_last_fragment(self.previous_fragment);
              }
              } else {
              return nil
            }
          }, TMP_LineWrap_determine_whether_to_pull_preceding_fragment_to_join_this_one_22.$$arity = 1);
          
          Opal.defn(self, '$remember_this_fragment_for_backward_looking_ops', TMP_LineWrap_remember_this_fragment_for_backward_looking_ops_23 = function $$remember_this_fragment_for_backward_looking_ops() {
            var self = this, pf = nil, last_word = nil, last_word_length = nil;

            
            self.previous_fragment = self.fragment_output.$dup();
            pf = self.previous_fragment;
            self.previous_fragment_ended_with_breakable = pf['$=~'](new RegExp("" + "[" + (self.$break_chars()) + "]$"));
            last_word = pf.$slice(new RegExp("" + "[^" + (self.$break_chars()) + "]*$"));
            last_word_length = (function() {if ($truthy(last_word['$nil?']())) {
              return 0
              } else {
              return last_word.$length()
            }; return nil; })();
            return (self.previous_fragment_output_without_last_word = pf.$slice(0, $rb_minus(pf.$length(), last_word_length)));
          }, TMP_LineWrap_remember_this_fragment_for_backward_looking_ops_23.$$arity = 0);
          
          Opal.defn(self, '$previous_fragment_ended_with_breakable?', TMP_LineWrap_previous_fragment_ended_with_breakable$q_24 = function() {
            var self = this;

            return self.previous_fragment_ended_with_breakable
          }, TMP_LineWrap_previous_fragment_ended_with_breakable$q_24.$$arity = 0);
          
          Opal.defn(self, '$fragment_begins_with_breakable?', TMP_LineWrap_fragment_begins_with_breakable$q_25 = function(fragment) {
            var self = this;

            return fragment['$=~'](new RegExp("" + "^[" + (self.$break_chars()) + "]"))
          }, TMP_LineWrap_fragment_begins_with_breakable$q_25.$$arity = 1);
          
          Opal.defn(self, '$line_finished?', TMP_LineWrap_line_finished$q_26 = function() {
            var $a, self = this;

            return ($truthy($a = self.line_full) ? $a : self['$paragraph_finished?']())
          }, TMP_LineWrap_line_finished$q_26.$$arity = 0);
          
          Opal.defn(self, '$update_line_status_based_on_last_output', TMP_LineWrap_update_line_status_based_on_last_output_27 = function $$update_line_status_based_on_last_output() {
            var self = this;

            if ($truthy(self.fragment_output['$=~'](self.$word_division_scan_pattern()))) {
              return (self.line_contains_more_than_one_word = true)
              } else {
              return nil
            }
          }, TMP_LineWrap_update_line_status_based_on_last_output_27.$$arity = 0);
          
          Opal.defn(self, '$end_of_the_line_reached', TMP_LineWrap_end_of_the_line_reached_28 = function $$end_of_the_line_reached(segment) {
            var $a, self = this;

            
            self.$update_line_status_based_on_last_output();
            if ($truthy(($truthy($a = self.disable_wrap_by_char) ? $a : self.line_contains_more_than_one_word))) {
              } else {
              self.$wrap_by_char(segment)
            };
            return (self.line_full = true);
          }, TMP_LineWrap_end_of_the_line_reached_28.$$arity = 1);
          
          Opal.defn(self, '$wrap_by_char', TMP_LineWrap_wrap_by_char_30 = function $$wrap_by_char(segment) {
            var TMP_29, self = this, font = nil;

            
            font = self.document.$font();
            return (function(){var $brk = Opal.new_brk(); try {return $send(segment, 'each_char', [], (TMP_29 = function(char$){var self = TMP_29.$$s || this;
if (char$ == null) char$ = nil;
            if ($truthy(self.$append_char(char$, font))) {
                return nil
                } else {
                
                Opal.brk(nil, $brk)
              }}, TMP_29.$$s = self, TMP_29.$$brk = $brk, TMP_29.$$arity = 1, TMP_29))
            } catch (err) { if (err === $brk) { return err.$v } else { throw err } }})();
          }, TMP_LineWrap_wrap_by_char_30.$$arity = 1);
          return (Opal.defn(self, '$append_char', TMP_LineWrap_append_char_31 = function $$append_char(char$, font) {
            var self = this, char_width = nil;

            
            char_width = font.$compute_width_of(char$);
            if ($truthy($rb_le($rb_plus(self.accumulated_width, char_width), self.width))) {
              
              self.accumulated_width = $rb_plus(self.accumulated_width, char_width);
              self.fragment_output['$<<'](char$);
              return true;
              } else {
              return false
            };
          }, TMP_LineWrap_append_char_31.$$arity = 2), nil) && 'append_char';
        })($nesting[0], null, $nesting)
      })($nesting[0], $nesting)
    })($nesting[0], $nesting)
  })($nesting[0], $nesting)
};

/* Generated by Opal 0.11.0 */
Opal.modules["prawn/text/formatted/arranger"] = function(Opal) {
  function $rb_plus(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs + rhs : lhs['$+'](rhs);
  }
  function $rb_minus(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs - rhs : lhs['$-'](rhs);
  }
  function $rb_times(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs * rhs : lhs['$*'](rhs);
  }
  function $rb_gt(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs > rhs : lhs['$>'](rhs);
  }
  var self = Opal.top, $nesting = [], nil = Opal.nil, $breaker = Opal.breaker, $slice = Opal.slice, $module = Opal.module, $klass = Opal.klass, $hash2 = Opal.hash2, $truthy = Opal.truthy, $send = Opal.send;

  Opal.add_stubs(['$attr_reader', '$attr_accessor', '$[]', '$finalized', '$fail', '$inject', '$+', '$space_count', '$width', '$join', '$collect', '$force_encoding', '$dup', '$text', '$omit_trailing_whitespace_from_line_width', '$each', '$delete', '$new', '$<<', '$set_fragment_measurements', '$set_line_measurement_maximums', '$initialize_line', '$scan', '$merge', '$==', '$length', '$shift', '$first', '$color', '$fill_color', '$stroke_color', '$apply_font_settings', '$to_proc', '$stroke_color=', '$-', '$fill_color=', '$nil?', '$current_format_state', '$character_spacing', '$font_style', '$font', '$size', '$styles', '$!=', '$family', '$apply_font_size', '$empty?', '$pop', '$[]=', '$last', '$unshift', '$load_previous_format_state', '$retrieve_fragment', '$include_trailing_white_space!', '$format_state', '$concat', '$include?', '$private', '$subscript?', '$superscript?', '$*', '$font_size', '$reverse_each', '$strip', '$>', '$width_of', '$width=', '$height', '$line_height=', '$descender', '$descender=', '$ascender', '$ascender=', '$max', '$compact', '$line_height']);
  return (function($base, $parent_nesting) {
    var $Prawn, self = $Prawn = $module($base, 'Prawn');

    var def = self.$$proto, $nesting = [self].concat($parent_nesting);

    (function($base, $parent_nesting) {
      var $Text, self = $Text = $module($base, 'Text');

      var def = self.$$proto, $nesting = [self].concat($parent_nesting);

      (function($base, $parent_nesting) {
        var $Formatted, self = $Formatted = $module($base, 'Formatted');

        var def = self.$$proto, $nesting = [self].concat($parent_nesting);

        (function($base, $super, $parent_nesting) {
          function $Arranger(){};
          var self = $Arranger = $klass($base, $super, 'Arranger', $Arranger);

          var def = self.$$proto, $nesting = [self].concat($parent_nesting), TMP_Arranger_initialize_1, TMP_Arranger_space_count_3, TMP_Arranger_line_width_5, TMP_Arranger_line_7, TMP_Arranger_finalize_line_9, TMP_Arranger_format_array$eq_12, TMP_Arranger_initialize_line_13, TMP_Arranger_finished$q_14, TMP_Arranger_next_string_15, TMP_Arranger_preview_next_string_16, TMP_Arranger_apply_color_and_font_settings_17, TMP_Arranger_apply_font_settings_18, TMP_Arranger_update_last_string_21, TMP_Arranger_retrieve_fragment_22, TMP_Arranger_repack_unretrieved_23, TMP_Arranger_font_style_24, TMP_Arranger_load_previous_format_state_25, TMP_Arranger_apply_font_size_26, TMP_Arranger_subscript$q_28, TMP_Arranger_superscript$q_29, TMP_Arranger_omit_trailing_whitespace_from_line_width_31, TMP_Arranger_set_fragment_measurements_33, TMP_Arranger_set_line_measurement_maximums_34;

          def.fragments = def.consumed = def.unconsumed = def.current_format_state = def.document = def.max_line_height = def.max_descender = def.max_ascender = nil;
          
          self.$attr_reader("max_line_height");
          self.$attr_reader("max_descender");
          self.$attr_reader("max_ascender");
          self.$attr_reader("finalized");
          self.$attr_accessor("consumed");
          self.$attr_reader("unconsumed");
          self.$attr_reader("fragments");
          self.$attr_reader("current_format_state");
          
          Opal.defn(self, '$initialize', TMP_Arranger_initialize_1 = function $$initialize(document, options) {
            var self = this;

            if (options == null) {
              options = $hash2([], {});
            }
            
            self.document = document;
            self.fragments = [];
            self.unconsumed = [];
            return (self.kerning = options['$[]']("kerning"));
          }, TMP_Arranger_initialize_1.$$arity = -2);
          
          Opal.defn(self, '$space_count', TMP_Arranger_space_count_3 = function $$space_count() {
            var TMP_2, self = this;

            
            if ($truthy(self.$finalized())) {
              } else {
              self.$fail("Lines must be finalized before calling #space_count")
            };
            return $send(self.fragments, 'inject', [0], (TMP_2 = function(sum, fragment){var self = TMP_2.$$s || this;
if (sum == null) sum = nil;if (fragment == null) fragment = nil;
            return $rb_plus(sum, fragment.$space_count())}, TMP_2.$$s = self, TMP_2.$$arity = 2, TMP_2));
          }, TMP_Arranger_space_count_3.$$arity = 0);
          
          Opal.defn(self, '$line_width', TMP_Arranger_line_width_5 = function $$line_width() {
            var TMP_4, self = this;

            
            if ($truthy(self.$finalized())) {
              } else {
              self.$fail("Lines must be finalized before calling #line_width")
            };
            return $send(self.fragments, 'inject', [0], (TMP_4 = function(sum, fragment){var self = TMP_4.$$s || this;
if (sum == null) sum = nil;if (fragment == null) fragment = nil;
            return $rb_plus(sum, fragment.$width())}, TMP_4.$$s = self, TMP_4.$$arity = 2, TMP_4));
          }, TMP_Arranger_line_width_5.$$arity = 0);
          
          Opal.defn(self, '$line', TMP_Arranger_line_7 = function $$line() {
            var TMP_6, self = this;

            
            if ($truthy(self.$finalized())) {
              } else {
              self.$fail("Lines must be finalized before calling #line")
            };
            return $send(self.fragments, 'collect', [], (TMP_6 = function(fragment){var self = TMP_6.$$s || this;
if (fragment == null) fragment = nil;
            return fragment.$text().$dup().$force_encoding(Opal.const_get_qualified(Opal.const_get_qualified('::', 'Encoding'), 'UTF_8'))}, TMP_6.$$s = self, TMP_6.$$arity = 1, TMP_6)).$join();
          }, TMP_Arranger_line_7.$$arity = 0);
          
          Opal.defn(self, '$finalize_line', TMP_Arranger_finalize_line_9 = function $$finalize_line() {
            var TMP_8, self = this;

            
            self.finalized = true;
            self.$omit_trailing_whitespace_from_line_width();
            self.fragments = [];
            return $send(self.consumed, 'each', [], (TMP_8 = function(hash){var self = TMP_8.$$s || this, text = nil, format_state = nil, fragment = nil;
              if (self.document == null) self.document = nil;
              if (self.fragments == null) self.fragments = nil;
if (hash == null) hash = nil;
            
              text = hash['$[]']("text");
              format_state = hash.$dup();
              format_state.$delete("text");
              fragment = Opal.const_get_qualified(Opal.const_get_qualified(Opal.const_get_qualified(Opal.const_get_relative($nesting, 'Prawn'), 'Text'), 'Formatted'), 'Fragment').$new(text, format_state, self.document);
              self.fragments['$<<'](fragment);
              self.$set_fragment_measurements(fragment);
              return self.$set_line_measurement_maximums(fragment);}, TMP_8.$$s = self, TMP_8.$$arity = 1, TMP_8));
          }, TMP_Arranger_finalize_line_9.$$arity = 0);
          
          Opal.defn(self, '$format_array=', TMP_Arranger_format_array$eq_12 = function(array) {
            var TMP_10, self = this;

            
            self.$initialize_line();
            self.unconsumed = [];
            return $send(array, 'each', [], (TMP_10 = function(hash){var self = TMP_10.$$s || this, TMP_11;
if (hash == null) hash = nil;
            return $send(hash['$[]']("text"), 'scan', [/[^\n]+|\n/], (TMP_11 = function(line){var self = TMP_11.$$s || this;
                if (self.unconsumed == null) self.unconsumed = nil;
if (line == null) line = nil;
              return self.unconsumed['$<<'](hash.$merge($hash2(["text"], {"text": line})))}, TMP_11.$$s = self, TMP_11.$$arity = 1, TMP_11))}, TMP_10.$$s = self, TMP_10.$$arity = 1, TMP_10));
          }, TMP_Arranger_format_array$eq_12.$$arity = 1);
          
          Opal.defn(self, '$initialize_line', TMP_Arranger_initialize_line_13 = function $$initialize_line() {
            var self = this;

            
            self.finalized = false;
            self.max_line_height = 0;
            self.max_descender = 0;
            self.max_ascender = 0;
            self.consumed = [];
            return (self.fragments = []);
          }, TMP_Arranger_initialize_line_13.$$arity = 0);
          
          Opal.defn(self, '$finished?', TMP_Arranger_finished$q_14 = function() {
            var self = this;

            return self.unconsumed.$length()['$=='](0)
          }, TMP_Arranger_finished$q_14.$$arity = 0);
          
          Opal.defn(self, '$next_string', TMP_Arranger_next_string_15 = function $$next_string() {
            var self = this, next_unconsumed_hash = nil;

            
            if ($truthy(self.$finalized())) {
              self.$fail("Lines must not be finalized when calling #next_string")};
            next_unconsumed_hash = self.unconsumed.$shift();
            if ($truthy(next_unconsumed_hash)) {
              
              self.consumed['$<<'](next_unconsumed_hash.$dup());
              self.current_format_state = next_unconsumed_hash.$dup();
              self.current_format_state.$delete("text");
              return next_unconsumed_hash['$[]']("text");
              } else {
              return nil
            };
          }, TMP_Arranger_next_string_15.$$arity = 0);
          
          Opal.defn(self, '$preview_next_string', TMP_Arranger_preview_next_string_16 = function $$preview_next_string() {
            var self = this, next_unconsumed_hash = nil;

            
            next_unconsumed_hash = self.unconsumed.$first();
            if ($truthy(next_unconsumed_hash)) {
              return next_unconsumed_hash['$[]']("text")
              } else {
              return nil
            };
          }, TMP_Arranger_preview_next_string_16.$$arity = 0);
          
          Opal.defn(self, '$apply_color_and_font_settings', TMP_Arranger_apply_color_and_font_settings_17 = function $$apply_color_and_font_settings(fragment) {
            var self = this, $iter = TMP_Arranger_apply_color_and_font_settings_17.$$p, block = $iter || nil, original_fill_color = nil, original_stroke_color = nil, $writer = nil;

            if ($iter) TMP_Arranger_apply_color_and_font_settings_17.$$p = null;
            if ($truthy(fragment.$color())) {
              
              original_fill_color = self.document.$fill_color();
              original_stroke_color = self.document.$stroke_color();
              $send(self.document, 'fill_color', Opal.to_a(fragment.$color()));
              $send(self.document, 'stroke_color', Opal.to_a(fragment.$color()));
              $send(self, 'apply_font_settings', [fragment], block.$to_proc());
              
              $writer = [original_stroke_color];
              $send(self.document, 'stroke_color=', Opal.to_a($writer));
              $writer[$rb_minus($writer["length"], 1)];;
              
              $writer = [original_fill_color];
              $send(self.document, 'fill_color=', Opal.to_a($writer));
              return $writer[$rb_minus($writer["length"], 1)];;
              } else {
              return $send(self, 'apply_font_settings', [fragment], block.$to_proc())
            }
          }, TMP_Arranger_apply_color_and_font_settings_17.$$arity = 1);
          
          Opal.defn(self, '$apply_font_settings', TMP_Arranger_apply_font_settings_18 = function $$apply_font_settings(fragment) {
            var $a, TMP_19, self = this, $iter = TMP_Arranger_apply_font_settings_18.$$p, block = $iter || nil, font = nil, size = nil, character_spacing = nil, styles = nil, font_style = nil;

            if (fragment == null) {
              fragment = nil;
            }
            if ($iter) TMP_Arranger_apply_font_settings_18.$$p = null;
            
            if ($truthy(fragment['$nil?']())) {
              
              font = self.$current_format_state()['$[]']("font");
              size = self.$current_format_state()['$[]']("size");
              character_spacing = ($truthy($a = self.$current_format_state()['$[]']("character_spacing")) ? $a : self.document.$character_spacing());
              styles = self.$current_format_state()['$[]']("styles");
              font_style = self.$font_style(styles);
              } else {
              
              font = fragment.$font();
              size = fragment.$size();
              character_spacing = fragment.$character_spacing();
              styles = fragment.$styles();
              font_style = self.$font_style(styles);
            };
            return $send(self.document, 'character_spacing', [character_spacing], (TMP_19 = function(){var self = TMP_19.$$s || this, $b, TMP_20;
              if (self.document == null) self.document = nil;

            if ($truthy(($truthy($b = font) ? $b : font_style['$!=']("normal")))) {
                
                if ($truthy(self.document.$font().$family())) {
                  } else {
                  self.$fail("Bad font family")
                };
                return $send(self.document, 'font', [($truthy($b = font) ? $b : self.document.$font().$family()), $hash2(["style"], {"style": font_style})], (TMP_20 = function(){var self = TMP_20.$$s || this;

                return $send(self, 'apply_font_size', [size, styles], block.$to_proc())}, TMP_20.$$s = self, TMP_20.$$arity = 0, TMP_20));
                } else {
                return $send(self, 'apply_font_size', [size, styles], block.$to_proc())
              }}, TMP_19.$$s = self, TMP_19.$$arity = 0, TMP_19));
          }, TMP_Arranger_apply_font_settings_18.$$arity = -1);
          
          Opal.defn(self, '$update_last_string', TMP_Arranger_update_last_string_21 = function $$update_last_string(printed, unprinted, normalized_soft_hyphen) {
            var self = this, $writer = nil;

            if (normalized_soft_hyphen == null) {
              normalized_soft_hyphen = nil;
            }
            
            if ($truthy(printed['$nil?']())) {
              return nil};
            if ($truthy(printed['$empty?']())) {
              self.consumed.$pop()
              } else {
              
              
              $writer = ["text", printed];
              $send(self.consumed.$last(), '[]=', Opal.to_a($writer));
              $writer[$rb_minus($writer["length"], 1)];;
              if ($truthy(normalized_soft_hyphen)) {
                
                $writer = ["normalized_soft_hyphen", normalized_soft_hyphen];
                $send(self.consumed.$last(), '[]=', Opal.to_a($writer));
                $writer[$rb_minus($writer["length"], 1)];};
            };
            if ($truthy(unprinted['$empty?']())) {
              } else {
              self.unconsumed.$unshift(self.current_format_state.$merge($hash2(["text"], {"text": unprinted})))
            };
            if ($truthy(printed['$empty?']())) {
              return self.$load_previous_format_state()
              } else {
              return nil
            };
          }, TMP_Arranger_update_last_string_21.$$arity = -3);
          
          Opal.defn(self, '$retrieve_fragment', TMP_Arranger_retrieve_fragment_22 = function $$retrieve_fragment() {
            var self = this;

            
            if ($truthy(self.$finalized())) {
              } else {
              self.$fail("Lines must be finalized before fragments can be retrieved")
            };
            return self.fragments.$shift();
          }, TMP_Arranger_retrieve_fragment_22.$$arity = 0);
          
          Opal.defn(self, '$repack_unretrieved', TMP_Arranger_repack_unretrieved_23 = function $$repack_unretrieved() {
            var $a, self = this, new_unconsumed = nil, fragment = nil;

            
            new_unconsumed = [];
            while ($truthy((fragment = self.$retrieve_fragment()))) {
              
              fragment['$include_trailing_white_space!']();
              new_unconsumed['$<<'](fragment.$format_state().$merge($hash2(["text"], {"text": fragment.$text()})));
            };
            return (self.unconsumed = new_unconsumed.$concat(self.unconsumed));
          }, TMP_Arranger_repack_unretrieved_23.$$arity = 0);
          
          Opal.defn(self, '$font_style', TMP_Arranger_font_style_24 = function $$font_style(styles) {
            var $a, self = this;

            if ($truthy(styles['$nil?']())) {
              return "normal"
            } else if ($truthy(($truthy($a = styles['$include?']("bold")) ? styles['$include?']("italic") : $a))) {
              return "bold_italic"
            } else if ($truthy(styles['$include?']("bold"))) {
              return "bold"
            } else if ($truthy(styles['$include?']("italic"))) {
              return "italic"
              } else {
              return "normal"
            }
          }, TMP_Arranger_font_style_24.$$arity = 1);
          self.$private();
          
          Opal.defn(self, '$load_previous_format_state', TMP_Arranger_load_previous_format_state_25 = function $$load_previous_format_state() {
            var self = this, hash = nil;

            if ($truthy(self.consumed['$empty?']())) {
              return (self.current_format_state = $hash2([], {}))
              } else {
              
              hash = self.consumed.$last();
              self.current_format_state = hash.$dup();
              return self.current_format_state.$delete("text");
            }
          }, TMP_Arranger_load_previous_format_state_25.$$arity = 0);
          
          Opal.defn(self, '$apply_font_size', TMP_Arranger_apply_font_size_26 = function $$apply_font_size(size, styles) {
            var $a, TMP_27, self = this, $iter = TMP_Arranger_apply_font_size_26.$$p, $yield = $iter || nil, relative_size = nil;

            if ($iter) TMP_Arranger_apply_font_size_26.$$p = null;
            
            if ($truthy(($truthy($a = self['$subscript?'](styles)) ? $a : self['$superscript?'](styles)))) {
              
              relative_size = 0.583;
              if ($truthy(size['$nil?']())) {
                size = $rb_times(self.document.$font_size(), relative_size)
                } else {
                size = $rb_times(size, relative_size)
              };};
            if ($truthy(size['$nil?']())) {
              return Opal.yieldX($yield, []);
              } else {
              return $send(self.document, 'font_size', [size], (TMP_27 = function(){var self = TMP_27.$$s || this;

              return Opal.yieldX($yield, []);}, TMP_27.$$s = self, TMP_27.$$arity = 0, TMP_27))
            };
          }, TMP_Arranger_apply_font_size_26.$$arity = 2);
          
          Opal.defn(self, '$subscript?', TMP_Arranger_subscript$q_28 = function(styles) {
            var self = this;

            if ($truthy(styles['$nil?']())) {
              return false
              } else {
              return styles['$include?']("subscript")
            }
          }, TMP_Arranger_subscript$q_28.$$arity = 1);
          
          Opal.defn(self, '$superscript?', TMP_Arranger_superscript$q_29 = function(styles) {
            var self = this;

            if ($truthy(styles['$nil?']())) {
              return false
              } else {
              return styles['$include?']("superscript")
            }
          }, TMP_Arranger_superscript$q_29.$$arity = 1);
          
          Opal.defn(self, '$omit_trailing_whitespace_from_line_width', TMP_Arranger_omit_trailing_whitespace_from_line_width_31 = function $$omit_trailing_whitespace_from_line_width() {
            var TMP_30, self = this;

            return (function(){var $brk = Opal.new_brk(); try {return $send(self.consumed, 'reverse_each', [], (TMP_30 = function(hash){var self = TMP_30.$$s || this, $a, $writer = nil;
              if (self.consumed == null) self.consumed = nil;
if (hash == null) hash = nil;
            if (hash['$[]']("text")['$==']("\n")) {
                
                Opal.brk(nil, $brk)
              } else if ($truthy(($truthy($a = hash['$[]']("text").$strip()['$empty?']()) ? $rb_gt(self.consumed.$length(), 1) : $a))) {
                
                $writer = ["exclude_trailing_white_space", true];
                $send(hash, '[]=', Opal.to_a($writer));
                return $writer[$rb_minus($writer["length"], 1)];
                } else {
                
                
                $writer = ["exclude_trailing_white_space", true];
                $send(hash, '[]=', Opal.to_a($writer));
                $writer[$rb_minus($writer["length"], 1)];;
                
                Opal.brk(nil, $brk);
              }}, TMP_30.$$s = self, TMP_30.$$brk = $brk, TMP_30.$$arity = 1, TMP_30))
            } catch (err) { if (err === $brk) { return err.$v } else { throw err } }})()
          }, TMP_Arranger_omit_trailing_whitespace_from_line_width_31.$$arity = 0);
          
          Opal.defn(self, '$set_fragment_measurements', TMP_Arranger_set_fragment_measurements_33 = function $$set_fragment_measurements(fragment) {
            var TMP_32, self = this;

            return $send(self, 'apply_font_settings', [fragment], (TMP_32 = function(){var self = TMP_32.$$s || this, $writer = nil;
              if (self.document == null) self.document = nil;
              if (self.kerning == null) self.kerning = nil;

            
              
              $writer = [self.document.$width_of(fragment.$text(), $hash2(["kerning"], {"kerning": self.kerning}))];
              $send(fragment, 'width=', Opal.to_a($writer));
              $writer[$rb_minus($writer["length"], 1)];;
              
              $writer = [self.document.$font().$height()];
              $send(fragment, 'line_height=', Opal.to_a($writer));
              $writer[$rb_minus($writer["length"], 1)];;
              
              $writer = [self.document.$font().$descender()];
              $send(fragment, 'descender=', Opal.to_a($writer));
              $writer[$rb_minus($writer["length"], 1)];;
              
              $writer = [self.document.$font().$ascender()];
              $send(fragment, 'ascender=', Opal.to_a($writer));
              return $writer[$rb_minus($writer["length"], 1)];;}, TMP_32.$$s = self, TMP_32.$$arity = 0, TMP_32))
          }, TMP_Arranger_set_fragment_measurements_33.$$arity = 1);
          return (Opal.defn(self, '$set_line_measurement_maximums', TMP_Arranger_set_line_measurement_maximums_34 = function $$set_line_measurement_maximums(fragment) {
            var $a, $b, $c, $d, self = this;

            
            self.max_line_height = [($truthy($a = (($b = self['max_line_height'], $b != null && $b !== nil) ? 'instance-variable' : nil)) ? self.max_line_height : $a), fragment.$line_height()].$compact().$max();
            self.max_descender = [($truthy($a = (($c = self['max_descender'], $c != null && $c !== nil) ? 'instance-variable' : nil)) ? self.max_descender : $a), fragment.$descender()].$compact().$max();
            return (self.max_ascender = [($truthy($a = (($d = self['max_ascender'], $d != null && $d !== nil) ? 'instance-variable' : nil)) ? self.max_ascender : $a), fragment.$ascender()].$compact().$max());
          }, TMP_Arranger_set_line_measurement_maximums_34.$$arity = 1), nil) && 'set_line_measurement_maximums';
        })($nesting[0], null, $nesting)
      })($nesting[0], $nesting)
    })($nesting[0], $nesting)
  })($nesting[0], $nesting)
};

/* Generated by Opal 0.11.0 */
Opal.modules["prawn/text/formatted/wrap"] = function(Opal) {
  function $rb_minus(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs - rhs : lhs['$-'](rhs);
  }
  function $rb_plus(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs + rhs : lhs['$+'](rhs);
  }
  function $rb_gt(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs > rhs : lhs['$>'](rhs);
  }
  function $rb_divide(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs / rhs : lhs['$/'](rhs);
  }
  var self = Opal.top, $nesting = [], nil = Opal.nil, $breaker = Opal.breaker, $slice = Opal.slice, $module = Opal.module, $hash2 = Opal.hash2, $truthy = Opal.truthy, $send = Opal.send;

  Opal.add_stubs(['$new', '$[]', '$initialize_wrap', '$!', '$wrap_line', '$available_width', '$enough_height_for_this_line?', '$move_baseline_down', '$print_line', '$finished?', '$join', '$unconsumed', '$private', '$word_spacing_for_this_line', '$retrieve_fragment', '$word_spacing=', '$-', '$==', '$text', '$last', '$<<', '$reverse!', '$each', '$default_direction=', '$format_and_draw_fragment', '$width', '$+', '$map', '$force_encoding', '$>', '$space_count', '$paragraph_finished?', '$/', '$max_line_height', '$max_descender', '$max_ascender', '$abs', '$repack_unretrieved', '$format_array=', '$apply_color_and_font_settings', '$draw_fragment']);
  
  self.$require("prawn/text/formatted/wrap"+ '/../' + "line_wrap");
  self.$require("prawn/text/formatted/wrap"+ '/../' + "arranger");
  return (function($base, $parent_nesting) {
    var $Prawn, self = $Prawn = $module($base, 'Prawn');

    var def = self.$$proto, $nesting = [self].concat($parent_nesting);

    (function($base, $parent_nesting) {
      var $Text, self = $Text = $module($base, 'Text');

      var def = self.$$proto, $nesting = [self].concat($parent_nesting);

      (function($base, $parent_nesting) {
        var $Formatted, self = $Formatted = $module($base, 'Formatted');

        var def = self.$$proto, $nesting = [self].concat($parent_nesting);

        (function($base, $parent_nesting) {
          var $Wrap, self = $Wrap = $module($base, 'Wrap');

          var def = self.$$proto, $nesting = [self].concat($parent_nesting), TMP_Wrap_initialize_1, TMP_Wrap_wrap_2, TMP_Wrap_print_line_5, TMP_Wrap_word_spacing_for_this_line_6, TMP_Wrap_enough_height_for_this_line$q_7, TMP_Wrap_initialize_wrap_8, TMP_Wrap_format_and_draw_fragment_10;

          
          
          Opal.defn(self, '$initialize', TMP_Wrap_initialize_1 = function $$initialize(array, options) {
            var self = this;
            if (self.document == null) self.document = nil;

            
            self.line_wrap = Opal.const_get_qualified(Opal.const_get_qualified(Opal.const_get_qualified(Opal.const_get_relative($nesting, 'Prawn'), 'Text'), 'Formatted'), 'LineWrap').$new();
            self.arranger = Opal.const_get_qualified(Opal.const_get_qualified(Opal.const_get_qualified(Opal.const_get_relative($nesting, 'Prawn'), 'Text'), 'Formatted'), 'Arranger').$new(self.document, $hash2(["kerning"], {"kerning": options['$[]']("kerning")}));
            return (self.disable_wrap_by_char = options['$[]']("disable_wrap_by_char"));
          }, TMP_Wrap_initialize_1.$$arity = 2);
          
          Opal.defn(self, '$wrap', TMP_Wrap_wrap_2 = function $$wrap(array) {
            var $a, $b, $c, self = this, stop = nil;
            if (self.line_wrap == null) self.line_wrap = nil;
            if (self.document == null) self.document = nil;
            if (self.kerning == null) self.kerning = nil;
            if (self.arranger == null) self.arranger = nil;
            if (self.disable_wrap_by_char == null) self.disable_wrap_by_char = nil;
            if (self.single_line == null) self.single_line = nil;
            if (self.printed_lines == null) self.printed_lines = nil;

            
            self.$initialize_wrap(array);
            stop = false;
            while ($truthy(stop['$!']())) {
              
              self.line_wrap.$wrap_line($hash2(["document", "kerning", "width", "arranger", "disable_wrap_by_char"], {"document": self.document, "kerning": self.kerning, "width": self.$available_width(), "arranger": self.arranger, "disable_wrap_by_char": self.disable_wrap_by_char}));
              if ($truthy(self['$enough_height_for_this_line?']())) {
                
                self.$move_baseline_down();
                self.$print_line();
                } else {
                stop = true
              };
              stop = ($truthy($b = stop) ? $b : ($truthy($c = self.single_line) ? $c : self.arranger['$finished?']()));
            };
            self.text = self.printed_lines.$join("\n");
            self.everything_printed = self.arranger['$finished?']();
            return self.arranger.$unconsumed();
          }, TMP_Wrap_wrap_2.$$arity = 1);
          self.$private();
          
          Opal.defn(self, '$print_line', TMP_Wrap_print_line_5 = function $$print_line() {
            var $a, TMP_3, TMP_4, self = this, printed_fragments = nil, fragments_this_line = nil, word_spacing = nil, fragment = nil, $writer = nil, accumulated_width = nil;
            if (self.arranger == null) self.arranger = nil;
            if (self.printed_lines == null) self.printed_lines = nil;
            if (self.direction == null) self.direction = nil;

            
            self.nothing_printed = false;
            printed_fragments = [];
            fragments_this_line = [];
            word_spacing = self.$word_spacing_for_this_line();
            while ($truthy((fragment = self.arranger.$retrieve_fragment()))) {
              
              
              $writer = [word_spacing];
              $send(fragment, 'word_spacing=', Opal.to_a($writer));
              $writer[$rb_minus($writer["length"], 1)];;
              if (fragment.$text()['$==']("\n")) {
                
                if (self.printed_lines.$last()['$==']("")) {
                  printed_fragments['$<<']("\n")};
                break;;};
              printed_fragments['$<<'](fragment.$text());
              fragments_this_line['$<<'](fragment);
            };
            accumulated_width = 0;
            if (self.direction['$==']("rtl")) {
              fragments_this_line['$reverse!']()};
            $send(fragments_this_line, 'each', [], (TMP_3 = function(fragment_this_line){var self = TMP_3.$$s || this;
              if (self.direction == null) self.direction = nil;
              if (self.line_wrap == null) self.line_wrap = nil;
if (fragment_this_line == null) fragment_this_line = nil;
            
              
              $writer = [self.direction];
              $send(fragment_this_line, 'default_direction=', Opal.to_a($writer));
              $writer[$rb_minus($writer["length"], 1)];;
              self.$format_and_draw_fragment(fragment_this_line, accumulated_width, self.line_wrap.$width(), word_spacing);
              return (accumulated_width = $rb_plus(accumulated_width, fragment_this_line.$width()));}, TMP_3.$$s = self, TMP_3.$$arity = 1, TMP_3));
            return self.printed_lines['$<<']($send(printed_fragments, 'map', [], (TMP_4 = function(s){var self = TMP_4.$$s || this;
if (s == null) s = nil;
            return s.$force_encoding(Opal.const_get_qualified(Opal.const_get_qualified('::', 'Encoding'), 'UTF_8'))}, TMP_4.$$s = self, TMP_4.$$arity = 1, TMP_4)).$join());
          }, TMP_Wrap_print_line_5.$$arity = 0);
          
          Opal.defn(self, '$word_spacing_for_this_line', TMP_Wrap_word_spacing_for_this_line_6 = function $$word_spacing_for_this_line() {
            var $a, $b, self = this;
            if (self.align == null) self.align = nil;
            if (self.line_wrap == null) self.line_wrap = nil;

            if ($truthy(($truthy($a = (($b = self.align['$==']("justify")) ? $rb_gt(self.line_wrap.$space_count(), 0) : self.align['$==']("justify"))) ? self.line_wrap['$paragraph_finished?']()['$!']() : $a))) {
              return $rb_divide($rb_minus(self.$available_width(), self.line_wrap.$width()), self.line_wrap.$space_count())
              } else {
              return 0
            }
          }, TMP_Wrap_word_spacing_for_this_line_6.$$arity = 0);
          
          Opal.defn(self, '$enough_height_for_this_line?', TMP_Wrap_enough_height_for_this_line$q_7 = function() {
            var self = this, diff = nil, require_relatived_total_height = nil;
            if (self.arranger == null) self.arranger = nil;
            if (self.baseline_y == null) self.baseline_y = nil;
            if (self.ascender == null) self.ascender = nil;
            if (self.descender == null) self.descender = nil;
            if (self.line_height == null) self.line_height = nil;
            if (self.leading == null) self.leading = nil;
            if (self.height == null) self.height = nil;

            
            self.line_height = self.arranger.$max_line_height();
            self.descender = self.arranger.$max_descender();
            self.ascender = self.arranger.$max_ascender();
            if (self.baseline_y['$=='](0)) {
              diff = $rb_plus(self.ascender, self.descender)
              } else {
              diff = $rb_plus($rb_plus(self.descender, self.line_height), self.leading)
            };
            require_relatived_total_height = $rb_plus(self.baseline_y.$abs(), diff);
            if ($truthy($rb_gt(require_relatived_total_height, $rb_plus(self.height, 0.0001)))) {
              
              self.arranger.$repack_unretrieved();
              return false;
              } else {
              return true
            };
          }, TMP_Wrap_enough_height_for_this_line$q_7.$$arity = 0);
          
          Opal.defn(self, '$initialize_wrap', TMP_Wrap_initialize_wrap_8 = function $$initialize_wrap(array) {
            var self = this, $writer = nil;
            if (self.arranger == null) self.arranger = nil;

            
            self.text = nil;
            
            $writer = [array];
            $send(self.arranger, 'format_array=', Opal.to_a($writer));
            $writer[$rb_minus($writer["length"], 1)];;
            self.line_height = 0;
            self.descender = 0;
            self.ascender = 0;
            self.baseline_y = 0;
            self.printed_lines = [];
            self.nothing_printed = true;
            return (self.everything_printed = false);
          }, TMP_Wrap_initialize_wrap_8.$$arity = 1);
          
          Opal.defn(self, '$format_and_draw_fragment', TMP_Wrap_format_and_draw_fragment_10 = function $$format_and_draw_fragment(fragment, accumulated_width, line_width, word_spacing) {
            var TMP_9, self = this;
            if (self.arranger == null) self.arranger = nil;

            return $send(self.arranger, 'apply_color_and_font_settings', [fragment], (TMP_9 = function(){var self = TMP_9.$$s || this;

            return self.$draw_fragment(fragment, accumulated_width, line_width, word_spacing)}, TMP_9.$$s = self, TMP_9.$$arity = 0, TMP_9))
          }, TMP_Wrap_format_and_draw_fragment_10.$$arity = 4);
        })($nesting[0], $nesting)
      })($nesting[0], $nesting)
    })($nesting[0], $nesting)
  })($nesting[0], $nesting);
};

/* Generated by Opal 0.11.0 */
Opal.modules["prawn/text/formatted/box"] = function(Opal) {
  function $rb_minus(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs - rhs : lhs['$-'](rhs);
  }
  function $rb_plus(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs + rhs : lhs['$+'](rhs);
  }
  function $rb_times(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs * rhs : lhs['$*'](rhs);
  }
  function $rb_gt(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs > rhs : lhs['$>'](rhs);
  }
  function $rb_le(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs <= rhs : lhs['$<='](rhs);
  }
  var self = Opal.top, $nesting = [], nil = Opal.nil, $breaker = Opal.breaker, $slice = Opal.slice, $module = Opal.module, $hash2 = Opal.hash2, $klass = Opal.klass, $send = Opal.send, $truthy = Opal.truthy;

  Opal.add_stubs(['$render', '$new', '$merge', '$include', '$attr_reader', '$-', '$line_height', '$+', '$ascender', '$descender', '$verify_options', '$valid_options', '$dup', '$reverse_each', '$extensions', '$class', '$extend', '$[]', '$original_text=', '$text_direction', '$fallback_fonts', '$left', '$bounds', '$top', '$right', '$default_height', '$==', '$default_leading', '$character_spacing', '$text_rendering_mode', '$nil?', '$default_kerning?', '$[]=', '$save_font', '$process_options', '$normalized_text', '$font_size', '$shrink_to_fit', '$process_vertical_alignment', '$!=', '$render_rotated', '$wrap', '$map', '$to_utf8', '$font', '$abs', '$===', '$*', '$y_offset', '$left=', '$baseline=', '$draw_fragment_underlays', '$word_spacing', '$call', '$text', '$draw_text!', '$draw_fragment_overlays', '$each', '$<<', '$private', '$normalize_encoding', '$delete', '$collect', '$to_proc', '$original_text', '$empty?', '$process_fallback_fonts', '$analyze_glyphs_for_fallback_font_support', '$concat', '$family', '$each_char', '$find_font_for_this_glyph', '$form_fragments_from_like_font_glyph_pairs', '$length', '$glyph_present?', '$shift', '$count', '$-@', '$stretchy?', '$parent', '$absolute_bottom', '$height', '$loop', '$>', '$<=', '$max', '$font_size=', '$process_text_options', '$rotate', '$callback_objects', '$respond_to?', '$render_behind', '$draw_fragment_overlay_styles', '$draw_fragment_overlay_link', '$draw_fragment_overlay_anchor', '$draw_fragment_overlay_local', '$render_in_front', '$link', '$absolute_bounding_box', '$link_annotation', '$anchor', '$local', '$include?', '$styles', '$stroke_line', '$underline_points', '$strikethrough_points']);
  return (function($base, $parent_nesting) {
    var $Prawn, self = $Prawn = $module($base, 'Prawn');

    var def = self.$$proto, $nesting = [self].concat($parent_nesting);

    (function($base, $parent_nesting) {
      var $Text, self = $Text = $module($base, 'Text');

      var def = self.$$proto, $nesting = [self].concat($parent_nesting);

      (function($base, $parent_nesting) {
        var $Formatted, self = $Formatted = $module($base, 'Formatted');

        var def = self.$$proto, $nesting = [self].concat($parent_nesting), TMP_Formatted_formatted_text_box_1;

        
        
        Opal.defn(self, '$formatted_text_box', TMP_Formatted_formatted_text_box_1 = function $$formatted_text_box(array, options) {
          var self = this;

          if (options == null) {
            options = $hash2([], {});
          }
          return Opal.const_get_qualified(Opal.const_get_qualified(Opal.const_get_relative($nesting, 'Text'), 'Formatted'), 'Box').$new(array, options.$merge($hash2(["document"], {"document": self}))).$render()
        }, TMP_Formatted_formatted_text_box_1.$$arity = -2);
        (function($base, $super, $parent_nesting) {
          function $Box(){};
          var self = $Box = $klass($base, $super, 'Box', $Box);

          var def = self.$$proto, $nesting = [self].concat($parent_nesting), TMP_Box_nothing_printed$q_2, TMP_Box_everything_printed$q_3, TMP_Box_line_gap_4, TMP_Box_initialize_6, TMP_Box_render_12, TMP_Box_available_width_13, TMP_Box_height_14, TMP_Box_draw_fragment_16, TMP_Box_extensions_17, TMP_Box_inherited_19, TMP_Box_valid_options_20, TMP_Box_normalized_text_22, TMP_Box_original_text_23, TMP_Box_original_text$eq_24, TMP_Box_normalize_encoding_27, TMP_Box_process_fallback_fonts_29, TMP_Box_analyze_glyphs_for_fallback_font_support_33, TMP_Box_find_font_for_this_glyph_34, TMP_Box_form_fragments_from_like_font_glyph_pairs_36, TMP_Box_move_baseline_down_37, TMP_Box_default_height_38, TMP_Box_process_vertical_alignment_39, TMP_Box_shrink_to_fit_41, TMP_Box_process_options_42, TMP_Box_render_rotated_44, TMP_Box_draw_fragment_underlays_46, TMP_Box_draw_fragment_overlays_48, TMP_Box_draw_fragment_overlay_link_49, TMP_Box_draw_fragment_overlay_anchor_50, TMP_Box_draw_fragment_overlay_local_51, TMP_Box_draw_fragment_overlay_styles_52;

          def.nothing_printed = def.everything_printed = def.document = def.at = def.direction = def.mode = def.overflow = def.width = def.baseline_y = def.descender = def.align = def.inked = def.original_array = def.fallback_fonts = def.ascender = def.line_height = def.leading = def.vertical_alignment_processed = def.vertical_align = def.height = def.options = def.rotate_around = def.rotate = nil;
          
          self.$include(Opal.const_get_qualified(Opal.const_get_qualified(Opal.const_get_qualified(Opal.const_get_relative($nesting, 'Prawn'), 'Text'), 'Formatted'), 'Wrap'));
          self.$attr_reader("text");
          
          Opal.defn(self, '$nothing_printed?', TMP_Box_nothing_printed$q_2 = function() {
            var self = this;

            return self.nothing_printed
          }, TMP_Box_nothing_printed$q_2.$$arity = 0);
          
          Opal.defn(self, '$everything_printed?', TMP_Box_everything_printed$q_3 = function() {
            var self = this;

            return self.everything_printed
          }, TMP_Box_everything_printed$q_3.$$arity = 0);
          self.$attr_reader("at");
          self.$attr_reader("line_height");
          self.$attr_reader("ascender");
          self.$attr_reader("descender");
          self.$attr_reader("leading");
          
          Opal.defn(self, '$line_gap', TMP_Box_line_gap_4 = function $$line_gap() {
            var self = this;

            return $rb_minus(self.$line_height(), $rb_plus(self.$ascender(), self.$descender()))
          }, TMP_Box_line_gap_4.$$arity = 0);
          
          Opal.defn(self, '$initialize', TMP_Box_initialize_6 = function $$initialize(formatted_text, options) {
            var TMP_5, $a, self = this, $iter = TMP_Box_initialize_6.$$p, $yield = $iter || nil, $writer = nil;

            if (options == null) {
              options = $hash2([], {});
            }
            if ($iter) TMP_Box_initialize_6.$$p = null;
            
            self.inked = false;
            Opal.const_get_relative($nesting, 'Prawn').$verify_options(self.$valid_options(), options);
            options = options.$dup();
            $send(self.$class().$extensions(), 'reverse_each', [], (TMP_5 = function(e){var self = TMP_5.$$s || this;
if (e == null) e = nil;
            return self.$extend(e)}, TMP_5.$$s = self, TMP_5.$$arity = 1, TMP_5));
            self.overflow = ($truthy($a = options['$[]']("overflow")) ? $a : "truncate");
            self.disable_wrap_by_char = options['$[]']("disable_wrap_by_char");
            
            $writer = [formatted_text];
            $send(self, 'original_text=', Opal.to_a($writer));
            $writer[$rb_minus($writer["length"], 1)];;
            self.text = nil;
            self.document = options['$[]']("document");
            self.direction = ($truthy($a = options['$[]']("direction")) ? $a : self.document.$text_direction());
            self.fallback_fonts = ($truthy($a = options['$[]']("fallback_fonts")) ? $a : self.document.$fallback_fonts());
            self.at = ($truthy($a = options['$[]']("at")) ? $a : [self.document.$bounds().$left(), self.document.$bounds().$top()]).$dup();
            self.width = ($truthy($a = options['$[]']("width")) ? $a : $rb_minus(self.document.$bounds().$right(), self.at['$[]'](0)));
            self.height = ($truthy($a = options['$[]']("height")) ? $a : self.$default_height());
            self.align = ($truthy($a = options['$[]']("align")) ? $a : (function() {if (self.direction['$==']("rtl")) {
              return "right"
              } else {
              return "left"
            }; return nil; })());
            self.vertical_align = ($truthy($a = options['$[]']("valign")) ? $a : "top");
            self.leading = ($truthy($a = options['$[]']("leading")) ? $a : self.document.$default_leading());
            self.character_spacing = ($truthy($a = options['$[]']("character_spacing")) ? $a : self.document.$character_spacing());
            self.mode = ($truthy($a = options['$[]']("mode")) ? $a : self.document.$text_rendering_mode());
            self.rotate = ($truthy($a = options['$[]']("rotate")) ? $a : 0);
            self.rotate_around = ($truthy($a = options['$[]']("rotate_around")) ? $a : "upper_left");
            self.single_line = options['$[]']("single_line");
            self.draw_text_callback = options['$[]']("draw_text_callback");
            if (self.mode['$==']("unknown")) {
              self.mode = "fill"};
            if (self.overflow['$==']("expand")) {
              
              self.height = self.$default_height();
              self.overflow = "truncate";};
            self.min_font_size = ($truthy($a = options['$[]']("min_font_size")) ? $a : 5);
            if ($truthy(options['$[]']("kerning")['$nil?']())) {
              
              $writer = ["kerning", self.document['$default_kerning?']()];
              $send(options, '[]=', Opal.to_a($writer));
              $writer[$rb_minus($writer["length"], 1)];};
            self.options = $hash2(["kerning", "size", "style"], {"kerning": options['$[]']("kerning"), "size": options['$[]']("size"), "style": options['$[]']("style")});
            return $send(self, Opal.find_super_dispatcher(self, 'initialize', TMP_Box_initialize_6, false), [formatted_text, options], null);
          }, TMP_Box_initialize_6.$$arity = -2);
          
          Opal.defn(self, '$render', TMP_Box_render_12 = function $$render(flags) {
            var TMP_7, TMP_11, self = this, unprinted_text = nil;

            if (flags == null) {
              flags = $hash2([], {});
            }
            
            unprinted_text = [];
            $send(self.document, 'save_font', [], (TMP_7 = function(){var self = TMP_7.$$s || this, TMP_8;
              if (self.document == null) self.document = nil;
              if (self.character_spacing == null) self.character_spacing = nil;

            return $send(self.document, 'character_spacing', [self.character_spacing], (TMP_8 = function(){var self = TMP_8.$$s || this, TMP_9;
                if (self.document == null) self.document = nil;
                if (self.mode == null) self.mode = nil;

              return $send(self.document, 'text_rendering_mode', [self.mode], (TMP_9 = function(){var self = TMP_9.$$s || this, TMP_10, text = nil;
                  if (self.document == null) self.document = nil;
                  if (self.font_size == null) self.font_size = nil;

                
                  self.$process_options();
                  text = self.$normalized_text(flags);
                  return $send(self.document, 'font_size', [self.font_size], (TMP_10 = function(){var self = TMP_10.$$s || this, $a;
                    if (self.overflow == null) self.overflow = nil;
                    if (self.rotate == null) self.rotate = nil;
                    if (self.inked == null) self.inked = nil;

                  
                    if (self.overflow['$==']("shrink_to_fit")) {
                      self.$shrink_to_fit(text)};
                    self.$process_vertical_alignment(text);
                    if ($truthy(flags['$[]']("dry_run"))) {
                      } else {
                      self.inked = true
                    };
                    if ($truthy(($truthy($a = self.rotate['$!='](0)) ? self.inked : $a))) {
                      unprinted_text = self.$render_rotated(text)
                      } else {
                      unprinted_text = self.$wrap(text)
                    };
                    return (self.inked = false);}, TMP_10.$$s = self, TMP_10.$$arity = 0, TMP_10));}, TMP_9.$$s = self, TMP_9.$$arity = 0, TMP_9))}, TMP_8.$$s = self, TMP_8.$$arity = 0, TMP_8))}, TMP_7.$$s = self, TMP_7.$$arity = 0, TMP_7));
            return $send(unprinted_text, 'map', [], (TMP_11 = function(e){var self = TMP_11.$$s || this;
              if (self.document == null) self.document = nil;
if (e == null) e = nil;
            return e.$merge($hash2(["text"], {"text": self.document.$font().$to_utf8(e['$[]']("text"))}))}, TMP_11.$$s = self, TMP_11.$$arity = 1, TMP_11));
          }, TMP_Box_render_12.$$arity = -1);
          
          Opal.defn(self, '$available_width', TMP_Box_available_width_13 = function $$available_width() {
            var self = this;

            return self.width
          }, TMP_Box_available_width_13.$$arity = 0);
          
          Opal.defn(self, '$height', TMP_Box_height_14 = function $$height() {
            var $a, self = this;

            
            if ($truthy(($truthy($a = self.baseline_y['$nil?']()) ? $a : self.descender['$nil?']()))) {
              return 0};
            return $rb_minus(self.baseline_y, self.descender).$abs();
          }, TMP_Box_height_14.$$arity = 0);
          
          Opal.defn(self, '$draw_fragment', TMP_Box_draw_fragment_16 = function $$draw_fragment(fragment, accumulated_width, line_width, word_spacing) {
            var TMP_15, self = this, $case = nil, x = nil, y = nil, $writer = nil;

            if (accumulated_width == null) {
              accumulated_width = 0;
            }
            if (line_width == null) {
              line_width = 0;
            }
            if (word_spacing == null) {
              word_spacing = 0;
            }
            
            $case = self.align;
            if ("left"['$===']($case)) {x = self.at['$[]'](0)}
            else if ("center"['$===']($case)) {x = $rb_minus($rb_plus(self.at['$[]'](0), $rb_times(self.width, 0.5)), $rb_times(line_width, 0.5))}
            else if ("right"['$===']($case)) {x = $rb_minus($rb_plus(self.at['$[]'](0), self.width), line_width)}
            else if ("justify"['$===']($case)) {if (self.direction['$==']("ltr")) {
              x = self.at['$[]'](0)
              } else {
              x = $rb_minus($rb_plus(self.at['$[]'](0), self.width), line_width)
            }};
            x = $rb_plus(x, accumulated_width);
            y = $rb_plus(self.at['$[]'](1), self.baseline_y);
            y = $rb_plus(y, fragment.$y_offset());
            
            $writer = [x];
            $send(fragment, 'left=', Opal.to_a($writer));
            $writer[$rb_minus($writer["length"], 1)];;
            
            $writer = [y];
            $send(fragment, 'baseline=', Opal.to_a($writer));
            $writer[$rb_minus($writer["length"], 1)];;
            if ($truthy(self.inked)) {
              
              self.$draw_fragment_underlays(fragment);
              $send(self.document, 'word_spacing', [word_spacing], (TMP_15 = function(){var self = TMP_15.$$s || this;
                if (self.draw_text_callback == null) self.draw_text_callback = nil;
                if (self.kerning == null) self.kerning = nil;
                if (self.document == null) self.document = nil;

              if ($truthy(self.draw_text_callback)) {
                  return self.draw_text_callback.$call(fragment.$text(), $hash2(["at", "kerning"], {"at": [x, y], "kerning": self.kerning}))
                  } else {
                  return self.document['$draw_text!'](fragment.$text(), $hash2(["at", "kerning"], {"at": [x, y], "kerning": self.kerning}))
                }}, TMP_15.$$s = self, TMP_15.$$arity = 0, TMP_15));
              return self.$draw_fragment_overlays(fragment);
              } else {
              return nil
            };
          }, TMP_Box_draw_fragment_16.$$arity = -2);
          Opal.defs(self, '$extensions', TMP_Box_extensions_17 = function $$extensions() {
            var $a, self = this;
            if (self.extensions == null) self.extensions = nil;

            return (self.extensions = ($truthy($a = self.extensions) ? $a : []))
          }, TMP_Box_extensions_17.$$arity = 0);
          Opal.defs(self, '$inherited', TMP_Box_inherited_19 = function $$inherited(base) {
            var TMP_18, self = this;

            return $send(self.$extensions(), 'each', [], (TMP_18 = function(e){var self = TMP_18.$$s || this;
if (e == null) e = nil;
            return base.$extensions()['$<<'](e)}, TMP_18.$$s = self, TMP_18.$$arity = 1, TMP_18))
          }, TMP_Box_inherited_19.$$arity = 1);
          
          Opal.defn(self, '$valid_options', TMP_Box_valid_options_20 = function $$valid_options() {
            var self = this;

            return $rb_plus(Opal.const_get_qualified(Opal.const_get_qualified(Opal.const_get_qualified(Opal.const_get_relative($nesting, 'PDF'), 'Core'), 'Text'), 'VALID_OPTIONS'), ["at", "height", "width", "align", "valign", "rotate", "rotate_around", "overflow", "min_font_size", "disable_wrap_by_char", "leading", "character_spacing", "mode", "single_line", "document", "direction", "fallback_fonts", "draw_text_callback"])
          }, TMP_Box_valid_options_20.$$arity = 0);
          self.$private();
          
          Opal.defn(self, '$normalized_text', TMP_Box_normalized_text_22 = function $$normalized_text(flags) {
            var TMP_21, self = this, text = nil;

            
            text = self.$normalize_encoding();
            if ($truthy(flags['$[]']("dry_run"))) {
              $send(text, 'each', [], (TMP_21 = function(t){var self = TMP_21.$$s || this;
if (t == null) t = nil;
              return t.$delete("color")}, TMP_21.$$s = self, TMP_21.$$arity = 1, TMP_21))};
            return text;
          }, TMP_Box_normalized_text_22.$$arity = 1);
          
          Opal.defn(self, '$original_text', TMP_Box_original_text_23 = function $$original_text() {
            var self = this;

            return $send(self.original_array, 'collect', [], "dup".$to_proc())
          }, TMP_Box_original_text_23.$$arity = 0);
          
          Opal.defn(self, '$original_text=', TMP_Box_original_text$eq_24 = function(formatted_text) {
            var self = this;

            return (self.original_array = formatted_text)
          }, TMP_Box_original_text$eq_24.$$arity = 1);
          
          Opal.defn(self, '$normalize_encoding', TMP_Box_normalize_encoding_27 = function $$normalize_encoding() {
            var TMP_25, self = this, formatted_text = nil;

            
            formatted_text = self.$original_text();
            if ($truthy(self.fallback_fonts['$empty?']())) {
              } else {
              formatted_text = self.$process_fallback_fonts(formatted_text)
            };
            $send(formatted_text, 'each', [], (TMP_25 = function(hash){var self = TMP_25.$$s || this, TMP_26, $writer = nil;
              if (self.document == null) self.document = nil;
if (hash == null) hash = nil;
            if ($truthy(hash['$[]']("font"))) {
                return $send(self.document, 'font', [hash['$[]']("font")], (TMP_26 = function(){var self = TMP_26.$$s || this, $writer = nil;
                  if (self.document == null) self.document = nil;

                
                  $writer = ["text", self.document.$font().$normalize_encoding(hash['$[]']("text"))];
                  $send(hash, '[]=', Opal.to_a($writer));
                  return $writer[$rb_minus($writer["length"], 1)];}, TMP_26.$$s = self, TMP_26.$$arity = 0, TMP_26))
                } else {
                
                $writer = ["text", self.document.$font().$normalize_encoding(hash['$[]']("text"))];
                $send(hash, '[]=', Opal.to_a($writer));
                return $writer[$rb_minus($writer["length"], 1)];
              }}, TMP_25.$$s = self, TMP_25.$$arity = 1, TMP_25));
            return formatted_text;
          }, TMP_Box_normalize_encoding_27.$$arity = 0);
          
          Opal.defn(self, '$process_fallback_fonts', TMP_Box_process_fallback_fonts_29 = function $$process_fallback_fonts(formatted_text) {
            var TMP_28, self = this, modified_formatted_text = nil;

            
            modified_formatted_text = [];
            $send(formatted_text, 'each', [], (TMP_28 = function(hash){var self = TMP_28.$$s || this, fragments = nil;
if (hash == null) hash = nil;
            
              fragments = self.$analyze_glyphs_for_fallback_font_support(hash);
              return modified_formatted_text.$concat(fragments);}, TMP_28.$$s = self, TMP_28.$$arity = 1, TMP_28));
            return modified_formatted_text;
          }, TMP_Box_process_fallback_fonts_29.$$arity = 1);
          
          Opal.defn(self, '$analyze_glyphs_for_fallback_font_support', TMP_Box_analyze_glyphs_for_fallback_font_support_33 = function $$analyze_glyphs_for_fallback_font_support(hash) {
            var $a, TMP_30, TMP_32, self = this, font_glyph_pairs = nil, original_font = nil, fragment_font = nil, fallback_fonts = nil;

            
            font_glyph_pairs = [];
            original_font = self.document.$font().$family();
            fragment_font = ($truthy($a = hash['$[]']("font")) ? $a : original_font);
            fallback_fonts = self.fallback_fonts.$dup();
            fallback_fonts['$<<'](fragment_font);
            $send(self.document, 'save_font', [], (TMP_30 = function(){var self = TMP_30.$$s || this, TMP_31;

            return $send(hash['$[]']("text"), 'each_char', [], (TMP_31 = function(char$){var self = TMP_31.$$s || this;
if (char$ == null) char$ = nil;
              return font_glyph_pairs['$<<']([self.$find_font_for_this_glyph(char$, fragment_font, fallback_fonts.$dup()), char$])}, TMP_31.$$s = self, TMP_31.$$arity = 1, TMP_31))}, TMP_30.$$s = self, TMP_30.$$arity = 0, TMP_30));
            if ($truthy(hash['$[]']("font")['$nil?']())) {
              $send(font_glyph_pairs, 'each', [], (TMP_32 = function(pair){var self = TMP_32.$$s || this, $writer = nil;
if (pair == null) pair = nil;
              if (pair['$[]'](0)['$=='](original_font)) {
                  
                  $writer = [0, nil];
                  $send(pair, '[]=', Opal.to_a($writer));
                  return $writer[$rb_minus($writer["length"], 1)];
                  } else {
                  return nil
                }}, TMP_32.$$s = self, TMP_32.$$arity = 1, TMP_32))};
            return self.$form_fragments_from_like_font_glyph_pairs(font_glyph_pairs, hash);
          }, TMP_Box_analyze_glyphs_for_fallback_font_support_33.$$arity = 1);
          
          Opal.defn(self, '$find_font_for_this_glyph', TMP_Box_find_font_for_this_glyph_34 = function $$find_font_for_this_glyph(char$, current_font, fallback_fonts) {
            var $a, self = this;

            
            self.document.$font(current_font);
            if ($truthy(($truthy($a = fallback_fonts.$length()['$=='](0)) ? $a : self.document.$font()['$glyph_present?'](char$)))) {
              return current_font
              } else {
              return self.$find_font_for_this_glyph(char$, fallback_fonts.$shift(), fallback_fonts)
            };
          }, TMP_Box_find_font_for_this_glyph_34.$$arity = 3);
          
          Opal.defn(self, '$form_fragments_from_like_font_glyph_pairs', TMP_Box_form_fragments_from_like_font_glyph_pairs_36 = function $$form_fragments_from_like_font_glyph_pairs(font_glyph_pairs, hash) {
            var TMP_35, self = this, fragments = nil, fragment = nil, current_font = nil;

            
            fragments = [];
            fragment = nil;
            current_font = nil;
            $send(font_glyph_pairs, 'each', [], (TMP_35 = function(font, char$){var self = TMP_35.$$s || this, $a, $writer = nil;
if (font == null) font = nil;if (char$ == null) char$ = nil;
            if ($truthy(($truthy($a = font['$!='](current_font)) ? $a : fragments.$count()['$=='](0)))) {
                
                current_font = font;
                fragment = hash.$dup();
                
                $writer = ["text", char$];
                $send(fragment, '[]=', Opal.to_a($writer));
                $writer[$rb_minus($writer["length"], 1)];;
                if ($truthy(font['$nil?']())) {
                  } else {
                  
                  $writer = ["font", font];
                  $send(fragment, '[]=', Opal.to_a($writer));
                  $writer[$rb_minus($writer["length"], 1)];
                };
                return fragments['$<<'](fragment);
                } else {
                
                $writer = ["text", $rb_plus(fragment['$[]']("text"), char$)];
                $send(fragment, '[]=', Opal.to_a($writer));
                return $writer[$rb_minus($writer["length"], 1)];
              }}, TMP_35.$$s = self, TMP_35.$$arity = 2, TMP_35));
            return fragments;
          }, TMP_Box_form_fragments_from_like_font_glyph_pairs_36.$$arity = 2);
          
          Opal.defn(self, '$move_baseline_down', TMP_Box_move_baseline_down_37 = function $$move_baseline_down() {
            var self = this;

            if (self.baseline_y['$=='](0)) {
              return (self.baseline_y = self.ascender['$-@']())
              } else {
              return (self.baseline_y = $rb_minus(self.baseline_y, $rb_plus(self.line_height, self.leading)))
            }
          }, TMP_Box_move_baseline_down_37.$$arity = 0);
          
          Opal.defn(self, '$default_height', TMP_Box_default_height_38 = function $$default_height() {
            var $a, $b, self = this, frame = nil;

            
            frame = self.document.$bounds();
            while ($truthy(($truthy($b = frame['$stretchy?']()) ? frame.$parent() : $b))) {
              frame = frame.$parent()
            };
            return $rb_minus($rb_plus(self.at['$[]'](1), self.document.$bounds().$absolute_bottom()), frame.$absolute_bottom());
          }, TMP_Box_default_height_38.$$arity = 0);
          
          Opal.defn(self, '$process_vertical_alignment', TMP_Box_process_vertical_alignment_39 = function $$process_vertical_alignment(text) {
            var $a, $b, self = this, $case = nil, $writer = nil;

            
            if ($truthy(($truthy($a = (($b = self['vertical_alignment_processed'], $b != null && $b !== nil) ? 'instance-variable' : nil)) ? self.vertical_alignment_processed : $a))) {
              return nil};
            self.vertical_alignment_processed = true;
            if (self.vertical_align['$==']("top")) {
              return nil};
            self.$wrap(text);
            $case = self.vertical_align;
            if ("center"['$===']($case)) {
            $writer = [1, $rb_minus(self.at['$[]'](1), $rb_times($rb_plus($rb_minus(self.height, self.$height()), self.descender), 0.5))];
            $send(self.at, '[]=', Opal.to_a($writer));
            $writer[$rb_minus($writer["length"], 1)];}
            else if ("bottom"['$===']($case)) {
            $writer = [1, $rb_minus(self.at['$[]'](1), $rb_minus(self.height, self.$height()))];
            $send(self.at, '[]=', Opal.to_a($writer));
            $writer[$rb_minus($writer["length"], 1)];};
            return (self.height = self.$height());
          }, TMP_Box_process_vertical_alignment_39.$$arity = 1);
          
          Opal.defn(self, '$shrink_to_fit', TMP_Box_shrink_to_fit_41 = function $$shrink_to_fit(text) {
            var TMP_40, self = this;

            return (function(){var $brk = Opal.new_brk(); try {return $send(self, 'loop', [], (TMP_40 = function(){var self = TMP_40.$$s || this, $a, $writer = nil;
              if (self.disable_wrap_by_char == null) self.disable_wrap_by_char = nil;
              if (self.font_size == null) self.font_size = nil;
              if (self.min_font_size == null) self.min_font_size = nil;
              if (self.everything_printed == null) self.everything_printed = nil;
              if (self.document == null) self.document = nil;

            
              if ($truthy(($truthy($a = self.disable_wrap_by_char) ? $rb_gt(self.font_size, self.min_font_size) : $a))) {
                
                try {
                  self.$wrap(text)
                } catch ($err) {
                  if (Opal.rescue($err, [Opal.const_get_qualified(Opal.const_get_relative($nesting, 'Errors'), 'CannotFit')])) {
                    try {
                      nil
                    } finally { Opal.pop_exception() }
                  } else { throw $err; }
                };
                } else {
                self.$wrap(text)
              };
              if ($truthy(($truthy($a = self.everything_printed) ? $a : $rb_le(self.font_size, self.min_font_size)))) {
                
                Opal.brk(nil, $brk)};
              self.font_size = [$rb_minus(self.font_size, 0.5), self.min_font_size].$max();
              
              $writer = [self.font_size];
              $send(self.document, 'font_size=', Opal.to_a($writer));
              return $writer[$rb_minus($writer["length"], 1)];;}, TMP_40.$$s = self, TMP_40.$$brk = $brk, TMP_40.$$arity = 0, TMP_40))
            } catch (err) { if (err === $brk) { return err.$v } else { throw err } }})()
          }, TMP_Box_shrink_to_fit_41.$$arity = 1);
          
          Opal.defn(self, '$process_options', TMP_Box_process_options_42 = function $$process_options() {
            var self = this;

            
            self.document.$process_text_options(self.options);
            self.font_size = self.options['$[]']("size");
            return (self.kerning = self.options['$[]']("kerning"));
          }, TMP_Box_process_options_42.$$arity = 0);
          
          Opal.defn(self, '$render_rotated', TMP_Box_render_rotated_44 = function $$render_rotated(text) {
            var TMP_43, self = this, unprinted_text = nil, $case = nil, x = nil, y = nil;

            
            unprinted_text = "";
            $case = self.rotate_around;
            if ("center"['$===']($case)) {
            x = $rb_plus(self.at['$[]'](0), $rb_times(self.width, 0.5));
            y = $rb_minus(self.at['$[]'](1), $rb_times(self.height, 0.5));}
            else if ("upper_right"['$===']($case)) {
            x = $rb_plus(self.at['$[]'](0), self.width);
            y = self.at['$[]'](1);}
            else if ("lower_right"['$===']($case)) {
            x = $rb_plus(self.at['$[]'](0), self.width);
            y = $rb_minus(self.at['$[]'](1), self.height);}
            else if ("lower_left"['$===']($case)) {
            x = self.at['$[]'](0);
            y = $rb_minus(self.at['$[]'](1), self.height);}
            else {
            x = self.at['$[]'](0);
            y = self.at['$[]'](1);};
            $send(self.document, 'rotate', [self.rotate, $hash2(["origin"], {"origin": [x, y]})], (TMP_43 = function(){var self = TMP_43.$$s || this;

            return (unprinted_text = self.$wrap(text))}, TMP_43.$$s = self, TMP_43.$$arity = 0, TMP_43));
            return unprinted_text;
          }, TMP_Box_render_rotated_44.$$arity = 1);
          
          Opal.defn(self, '$draw_fragment_underlays', TMP_Box_draw_fragment_underlays_46 = function $$draw_fragment_underlays(fragment) {
            var TMP_45, self = this;

            return $send(fragment.$callback_objects(), 'each', [], (TMP_45 = function(obj){var self = TMP_45.$$s || this;
if (obj == null) obj = nil;
            if ($truthy(obj['$respond_to?']("render_behind"))) {
                return obj.$render_behind(fragment)
                } else {
                return nil
              }}, TMP_45.$$s = self, TMP_45.$$arity = 1, TMP_45))
          }, TMP_Box_draw_fragment_underlays_46.$$arity = 1);
          
          Opal.defn(self, '$draw_fragment_overlays', TMP_Box_draw_fragment_overlays_48 = function $$draw_fragment_overlays(fragment) {
            var TMP_47, self = this;

            
            self.$draw_fragment_overlay_styles(fragment);
            self.$draw_fragment_overlay_link(fragment);
            self.$draw_fragment_overlay_anchor(fragment);
            self.$draw_fragment_overlay_local(fragment);
            return $send(fragment.$callback_objects(), 'each', [], (TMP_47 = function(obj){var self = TMP_47.$$s || this;
if (obj == null) obj = nil;
            if ($truthy(obj['$respond_to?']("render_in_front"))) {
                return obj.$render_in_front(fragment)
                } else {
                return nil
              }}, TMP_47.$$s = self, TMP_47.$$arity = 1, TMP_47));
          }, TMP_Box_draw_fragment_overlays_48.$$arity = 1);
          
          Opal.defn(self, '$draw_fragment_overlay_link', TMP_Box_draw_fragment_overlay_link_49 = function $$draw_fragment_overlay_link(fragment) {
            var self = this, box = nil;

            
            if ($truthy(fragment.$link())) {
              } else {
              return nil
            };
            box = fragment.$absolute_bounding_box();
            return self.document.$link_annotation(box, $hash2(["Border", "A"], {"Border": [0, 0, 0], "A": $hash2(["Type", "S", "URI"], {"Type": "Action", "S": "URI", "URI": Opal.const_get_qualified(Opal.const_get_qualified(Opal.const_get_relative($nesting, 'PDF'), 'Core'), 'LiteralString').$new(fragment.$link())})}));
          }, TMP_Box_draw_fragment_overlay_link_49.$$arity = 1);
          
          Opal.defn(self, '$draw_fragment_overlay_anchor', TMP_Box_draw_fragment_overlay_anchor_50 = function $$draw_fragment_overlay_anchor(fragment) {
            var self = this, box = nil;

            
            if ($truthy(fragment.$anchor())) {
              } else {
              return nil
            };
            box = fragment.$absolute_bounding_box();
            return self.document.$link_annotation(box, $hash2(["Border", "Dest"], {"Border": [0, 0, 0], "Dest": fragment.$anchor()}));
          }, TMP_Box_draw_fragment_overlay_anchor_50.$$arity = 1);
          
          Opal.defn(self, '$draw_fragment_overlay_local', TMP_Box_draw_fragment_overlay_local_51 = function $$draw_fragment_overlay_local(fragment) {
            var self = this, box = nil;

            
            if ($truthy(fragment.$local())) {
              } else {
              return nil
            };
            box = fragment.$absolute_bounding_box();
            return self.document.$link_annotation(box, $hash2(["Border", "A"], {"Border": [0, 0, 0], "A": $hash2(["Type", "S", "F", "NewWindow"], {"Type": "Action", "S": "Launch", "F": Opal.const_get_qualified(Opal.const_get_qualified(Opal.const_get_relative($nesting, 'PDF'), 'Core'), 'LiteralString').$new(fragment.$local()), "NewWindow": true})}));
          }, TMP_Box_draw_fragment_overlay_local_51.$$arity = 1);
          return (Opal.defn(self, '$draw_fragment_overlay_styles', TMP_Box_draw_fragment_overlay_styles_52 = function $$draw_fragment_overlay_styles(fragment) {
            var self = this, underline = nil, strikethrough = nil;

            
            underline = fragment.$styles()['$include?']("underline");
            if ($truthy(underline)) {
              self.document.$stroke_line(fragment.$underline_points())};
            strikethrough = fragment.$styles()['$include?']("strikethrough");
            if ($truthy(strikethrough)) {
              return self.document.$stroke_line(fragment.$strikethrough_points())
              } else {
              return nil
            };
          }, TMP_Box_draw_fragment_overlay_styles_52.$$arity = 1), nil) && 'draw_fragment_overlay_styles';
        })($nesting[0], null, $nesting);
      })($nesting[0], $nesting)
    })($nesting[0], $nesting)
  })($nesting[0], $nesting)
};

/* Generated by Opal 0.11.0 */
Opal.modules["prawn/text/formatted/parser"] = function(Opal) {
  function $rb_plus(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs + rhs : lhs['$+'](rhs);
  }
  var self = Opal.top, $nesting = [], nil = Opal.nil, $breaker = Opal.breaker, $slice = Opal.slice, $module = Opal.module, $klass = Opal.klass, $hash2 = Opal.hash2, $send = Opal.send, $truthy = Opal.truthy;

  Opal.add_stubs(['$new', '$scan', '$gsub', '$array_from_tokens', '$join', '$collect', '$[]', '$each', '$+', '$kind_of?', '$==', '$<<', '$merge', '$dup', '$empty?', '$shift', '$===', '$delete', '$pop', '$=~', '$match', '$nil?', '$to_i', '$to_f', '$last']);
  return (function($base, $parent_nesting) {
    var $Prawn, self = $Prawn = $module($base, 'Prawn');

    var def = self.$$proto, $nesting = [self].concat($parent_nesting);

    (function($base, $parent_nesting) {
      var $Text, self = $Text = $module($base, 'Text');

      var def = self.$$proto, $nesting = [self].concat($parent_nesting);

      (function($base, $parent_nesting) {
        var $Formatted, self = $Formatted = $module($base, 'Formatted');

        var def = self.$$proto, $nesting = [self].concat($parent_nesting);

        (function($base, $super, $parent_nesting) {
          function $Parser(){};
          var self = $Parser = $klass($base, $super, 'Parser', $Parser);

          var def = self.$$proto, $nesting = [self].concat($parent_nesting), TMP_Parser_format_1, TMP_Parser_to_string_4, TMP_Parser_array_paragraphs_7, TMP_Parser_array_from_tokens_8, regex_string = nil;

          
          Opal.const_set($nesting[0], 'PARSER_REGEX', ((regex_string = "" + "\n|" + "<b>|</b>|" + "<i>|</i>|" + "<u>|</u>|" + "<strikethrough>|</strikethrough>|" + "<sub>|</sub>|" + "<sup>|</sup>|" + "<link[^>]*>|</link>|" + "<color[^>]*>|</color>|" + "<font[^>]*>|</font>|" + "<strong>|</strong>|" + "<em>|</em>|" + "<a[^>]*>|</a>|" + "[^<\n]+"), Opal.const_get_relative($nesting, 'Regexp').$new(regex_string, Opal.const_get_qualified(Opal.const_get_relative($nesting, 'Regexp'), 'MULTILINE'))));
          Opal.defs(self, '$format', TMP_Parser_format_1 = function $$format(string, $a_rest) {
            var self = this, args, tokens = nil;

            var $args_len = arguments.length, $rest_len = $args_len - 1;
            if ($rest_len < 0) { $rest_len = 0; }
            args = new Array($rest_len);
            for (var $arg_idx = 1; $arg_idx < $args_len; $arg_idx++) {
              args[$arg_idx - 1] = arguments[$arg_idx];
            }
            
            tokens = string.$gsub(/<br\s*\/?>/, "\n").$scan(Opal.const_get_relative($nesting, 'PARSER_REGEX'));
            return self.$array_from_tokens(tokens);
          }, TMP_Parser_format_1.$$arity = -2);
          Opal.defs(self, '$to_string', TMP_Parser_to_string_4 = function $$to_string(array) {
            var TMP_2, self = this, prefixes = nil, suffixes = nil;

            
            prefixes = $hash2(["bold", "italic", "underline", "strikethrough", "subscript", "superscript"], {"bold": "<b>", "italic": "<i>", "underline": "<u>", "strikethrough": "<strikethrough>", "subscript": "<sub>", "superscript": "<sup>"});
            suffixes = $hash2(["bold", "italic", "underline", "strikethrough", "subscript", "superscript"], {"bold": "</b>", "italic": "</i>", "underline": "</u>", "strikethrough": "</strikethrough>", "subscript": "</sub>", "superscript": "</sup>"});
            return $send(array, 'collect', [], (TMP_2 = function(hash){var self = TMP_2.$$s || this, TMP_3, $a, $b, prefix = nil, suffix = nil, font = nil, size = nil, character_spacing = nil, link = nil, anchor = nil, string = nil;
if (hash == null) hash = nil;
            
              prefix = "";
              suffix = "";
              if ($truthy(hash['$[]']("styles"))) {
                $send(hash['$[]']("styles"), 'each', [], (TMP_3 = function(style){var self = TMP_3.$$s || this;
if (style == null) style = nil;
                
                  prefix = $rb_plus(prefix, prefixes['$[]'](style));
                  return (suffix = $rb_plus(suffixes['$[]'](style), suffix));}, TMP_3.$$s = self, TMP_3.$$arity = 1, TMP_3))};
              font = (function() {if ($truthy(hash['$[]']("font"))) {
                return "" + " name='" + (hash['$[]']("font")) + "'"
                } else {
                return nil
              }; return nil; })();
              size = (function() {if ($truthy(hash['$[]']("size"))) {
                return "" + " size='" + (hash['$[]']("size")) + "'"
                } else {
                return nil
              }; return nil; })();
              if ($truthy(hash['$[]']("character_spacing"))) {
                character_spacing = "" + " character_spacing='" + (hash['$[]']("character_spacing")) + "'"
                } else {
                character_spacing = nil
              };
              if ($truthy(($truthy($a = ($truthy($b = font) ? $b : size)) ? $a : character_spacing))) {
                
                prefix = $rb_plus(prefix, "" + "<font" + (font) + (size) + (character_spacing) + ">");
                suffix = "</font>";};
              link = (function() {if ($truthy(hash['$[]']("link"))) {
                return "" + " href='" + (hash['$[]']("link")) + "'"
                } else {
                return nil
              }; return nil; })();
              anchor = (function() {if ($truthy(hash['$[]']("anchor"))) {
                return "" + " anchor='" + (hash['$[]']("anchor")) + "'"
                } else {
                return nil
              }; return nil; })();
              if ($truthy(($truthy($a = link) ? $a : anchor))) {
                
                prefix = $rb_plus(prefix, "" + "<link" + (link) + (anchor) + ">");
                suffix = "</link>";};
              if ($truthy(hash['$[]']("color"))) {
                
                if ($truthy(hash['$[]']("color")['$kind_of?'](Opal.const_get_relative($nesting, 'Array')))) {
                  prefix = $rb_plus(prefix, "" + ("" + "<color c='" + (hash['$[]']("color")['$[]'](0)) + "'") + ("" + " m='" + (hash['$[]']("color")['$[]'](1)) + "'") + ("" + " y='" + (hash['$[]']("color")['$[]'](2)) + "'") + ("" + " k='" + (hash['$[]']("color")['$[]'](3)) + "'>"))
                  } else {
                  prefix = $rb_plus(prefix, "" + "<color rgb='" + (hash['$[]']("color")) + "'>")
                };
                suffix = "</color>";};
              string = hash['$[]']("text").$gsub("&", "&amp;").$gsub(">", "&gt;").$gsub("<", "&lt;");
              return $rb_plus($rb_plus(prefix, string), suffix);}, TMP_2.$$s = self, TMP_2.$$arity = 1, TMP_2)).$join();
          }, TMP_Parser_to_string_4.$$arity = 1);
          Opal.defs(self, '$array_paragraphs', TMP_Parser_array_paragraphs_7 = function $$array_paragraphs(array) {
            var TMP_5, self = this, paragraphs = nil, paragraph = nil, previous_string = nil, scan_pattern = nil;

            
            paragraphs = [];
            paragraph = [];
            previous_string = "\n";
            scan_pattern = /[^\n]+|\n/;
            $send(array, 'each', [], (TMP_5 = function(hash){var self = TMP_5.$$s || this, TMP_6;
if (hash == null) hash = nil;
            return $send(hash['$[]']("text").$scan(scan_pattern), 'each', [], (TMP_6 = function(string){var self = TMP_6.$$s || this;
if (string == null) string = nil;
              
                if (string['$==']("\n")) {
                  
                  if (previous_string['$==']("\n")) {
                    paragraph['$<<'](hash.$dup().$merge($hash2(["text"], {"text": "\n"})))};
                  if ($truthy(paragraph['$empty?']())) {
                    } else {
                    paragraphs['$<<'](paragraph)
                  };
                  paragraph = [];
                  } else {
                  paragraph['$<<'](hash.$dup().$merge($hash2(["text"], {"text": string})))
                };
                return (previous_string = string);}, TMP_6.$$s = self, TMP_6.$$arity = 1, TMP_6))}, TMP_5.$$s = self, TMP_5.$$arity = 1, TMP_5));
            if ($truthy(paragraph['$empty?']())) {
              } else {
              paragraphs['$<<'](paragraph)
            };
            return paragraphs;
          }, TMP_Parser_array_paragraphs_7.$$arity = 1);
          return Opal.defs(self, '$array_from_tokens', TMP_Parser_array_from_tokens_8 = function $$array_from_tokens(tokens) {
            var $a, $b, self = this, array = nil, styles = nil, colors = nil, link = nil, anchor = nil, local = nil, fonts = nil, sizes = nil, character_spacings = nil, token = nil, $case = nil, matches = nil, string = nil;

            
            array = [];
            styles = [];
            colors = [];
            link = nil;
            anchor = nil;
            local = nil;
            fonts = [];
            sizes = [];
            character_spacings = [];
            while ($truthy((token = tokens.$shift()))) {
              $case = token;
              if ("<b>"['$===']($case) || "<strong>"['$===']($case)) {styles['$<<']("bold")}
              else if ("<i>"['$===']($case) || "<em>"['$===']($case)) {styles['$<<']("italic")}
              else if ("<u>"['$===']($case)) {styles['$<<']("underline")}
              else if ("<strikethrough>"['$===']($case)) {styles['$<<']("strikethrough")}
              else if ("<sub>"['$===']($case)) {styles['$<<']("subscript")}
              else if ("<sup>"['$===']($case)) {styles['$<<']("superscript")}
              else if ("</b>"['$===']($case) || "</strong>"['$===']($case)) {styles.$delete("bold")}
              else if ("</i>"['$===']($case) || "</em>"['$===']($case)) {styles.$delete("italic")}
              else if ("</u>"['$===']($case)) {styles.$delete("underline")}
              else if ("</strikethrough>"['$===']($case)) {styles.$delete("strikethrough")}
              else if ("</sub>"['$===']($case)) {styles.$delete("subscript")}
              else if ("</sup>"['$===']($case)) {styles.$delete("superscript")}
              else if ("</link>"['$===']($case) || "</a>"['$===']($case)) {
              link = nil;
              anchor = nil;
              local = nil;}
              else if ("</color>"['$===']($case)) {colors.$pop()}
              else if ("</font>"['$===']($case)) {
              fonts.$pop();
              sizes.$pop();
              character_spacings.$pop();}
              else {if ($truthy(($truthy($b = token['$=~'](/^<link[^>]*>$/)) ? $b : token['$=~'](/^<a[^>]*>$/)))) {
                
                matches = ($truthy($b = /href="([^"]*)"/.$match(token)) ? $b : /href='([^']*)'/.$match(token));
                if ($truthy(matches['$nil?']())) {
                  } else {
                  link = matches['$[]'](1)
                };
                matches = ($truthy($b = /anchor="([^"]*)"/.$match(token)) ? $b : /anchor='([^']*)'/.$match(token));
                if ($truthy(matches['$nil?']())) {
                  } else {
                  anchor = matches['$[]'](1)
                };
                matches = ($truthy($b = /local="([^"]*)"/.$match(token)) ? $b : /local='([^']*)'/.$match(token));
                if ($truthy(matches['$nil?']())) {
                  } else {
                  local = matches['$[]'](1)
                };
              } else if ($truthy(token['$=~'](/^<color[^>]*>$/))) {
                
                matches = ($truthy($b = /rgb="#?([^"]*)"/.$match(token)) ? $b : /rgb='#?([^']*)'/.$match(token));
                if ($truthy(matches)) {
                  colors['$<<'](matches['$[]'](1))};
                matches = ($truthy($b = /c="#?([^"]*)" +m="#?([^"]*)" +y="#?([^"]*)" +k="#?([^"]*)"/.$match(token)) ? $b : /c='#?([^']*)' +m='#?([^']*)' +y='#?([^']*)' +k='#?([^']*)'/.$match(token));
                if ($truthy(matches)) {
                  colors['$<<']([matches['$[]'](1).$to_i(), matches['$[]'](2).$to_i(), matches['$[]'](3).$to_i(), matches['$[]'](4).$to_i()])};
              } else if ($truthy(token['$=~'](/^<font[^>]*>$/))) {
                
                matches = ($truthy($b = /name="([^"]*)"/.$match(token)) ? $b : /name='([^']*)'/.$match(token));
                if ($truthy(matches['$nil?']())) {
                  } else {
                  fonts['$<<'](matches['$[]'](1))
                };
                matches = ($truthy($b = /size="([^"]*)"/.$match(token)) ? $b : /size='([^']*)'/.$match(token));
                if ($truthy(matches['$nil?']())) {
                  } else {
                  sizes['$<<'](matches['$[]'](1).$to_f())
                };
                matches = ($truthy($b = /character_spacing="([^"]*)"/.$match(token)) ? $b : /character_spacing='([^']*)'/.$match(token));
                if ($truthy(matches['$nil?']())) {
                  } else {
                  character_spacings['$<<'](matches['$[]'](1).$to_f())
                };
                } else {
                
                string = token.$gsub("&lt;", "<").$gsub("&gt;", ">").$gsub("&amp;", "&");
                array['$<<']($hash2(["text", "styles", "color", "local", "link", "anchor", "font", "size", "character_spacing"], {"text": string, "styles": styles.$dup(), "color": colors.$last(), "local": local, "link": link, "anchor": anchor, "font": fonts.$last(), "size": sizes.$last(), "character_spacing": character_spacings.$last()}));
              }}
            };
            return array;
          }, TMP_Parser_array_from_tokens_8.$$arity = 1);
        })($nesting[0], null, $nesting)
      })($nesting[0], $nesting)
    })($nesting[0], $nesting)
  })($nesting[0], $nesting)
};

/* Generated by Opal 0.11.0 */
Opal.modules["prawn/text/formatted/fragment"] = function(Opal) {
  function $rb_plus(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs + rhs : lhs['$+'](rhs);
  }
  function $rb_times(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs * rhs : lhs['$*'](rhs);
  }
  function $rb_minus(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs - rhs : lhs['$-'](rhs);
  }
  function $rb_gt(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs > rhs : lhs['$>'](rhs);
  }
  var self = Opal.top, $nesting = [], nil = Opal.nil, $breaker = Opal.breaker, $slice = Opal.slice, $module = Opal.module, $klass = Opal.klass, $truthy = Opal.truthy, $send = Opal.send, $range = Opal.range;

  Opal.add_stubs(['$attr_reader', '$attr_writer', '$attr_accessor', '$process_text', '$==', '$+', '$*', '$space_count', '$-', '$top', '$bottom', '$include?', '$styles', '$subscript?', '$-@', '$descender', '$superscript?', '$ascender', '$left', '$right', '$bounding_box', '$[]', '$absolute_left', '$bounds', '$[]=', '$absolute_bottom', '$baseline', '$character_spacing', '$delete', '$count', '$nil?', '$is_a?', '$width', '$absolute_bounding_box', '$absolute_top', '$absolute_right', '$private', '$strip_zero_width_spaces', '$exclude_trailing_white_space?', '$rstrip', '$soft_hyphens_need_processing?', '$process_soft_hyphens', '$direction', '$===', '$reverse', '$>', '$length', '$normalized_soft_hyphen', '$!=', '$encoding', '$force_encoding', '$gsub']);
  return (function($base, $parent_nesting) {
    var $Prawn, self = $Prawn = $module($base, 'Prawn');

    var def = self.$$proto, $nesting = [self].concat($parent_nesting);

    (function($base, $parent_nesting) {
      var $Text, self = $Text = $module($base, 'Text');

      var def = self.$$proto, $nesting = [self].concat($parent_nesting);

      (function($base, $parent_nesting) {
        var $Formatted, self = $Formatted = $module($base, 'Formatted');

        var def = self.$$proto, $nesting = [self].concat($parent_nesting);

        (function($base, $super, $parent_nesting) {
          function $Fragment(){};
          var self = $Fragment = $klass($base, $super, 'Fragment', $Fragment);

          var def = self.$$proto, $nesting = [self].concat($parent_nesting), TMP_Fragment_initialize_1, TMP_Fragment_width_2, TMP_Fragment_height_3, TMP_Fragment_subscript$q_4, TMP_Fragment_superscript$q_5, TMP_Fragment_y_offset_6, TMP_Fragment_bounding_box_7, TMP_Fragment_absolute_bounding_box_8, TMP_Fragment_underline_points_9, TMP_Fragment_strikethrough_points_10, TMP_Fragment_styles_11, TMP_Fragment_link_12, TMP_Fragment_anchor_13, TMP_Fragment_local_14, TMP_Fragment_color_15, TMP_Fragment_font_16, TMP_Fragment_size_17, TMP_Fragment_character_spacing_18, TMP_Fragment_direction_19, TMP_Fragment_default_direction$eq_20, TMP_Fragment_include_trailing_white_space$B_21, TMP_Fragment_space_count_22, TMP_Fragment_callback_objects_23, TMP_Fragment_right_24, TMP_Fragment_top_25, TMP_Fragment_bottom_26, TMP_Fragment_top_left_27, TMP_Fragment_top_right_28, TMP_Fragment_bottom_right_29, TMP_Fragment_bottom_left_30, TMP_Fragment_absolute_left_31, TMP_Fragment_absolute_right_32, TMP_Fragment_absolute_top_33, TMP_Fragment_absolute_bottom_34, TMP_Fragment_absolute_top_left_35, TMP_Fragment_absolute_top_right_36, TMP_Fragment_absolute_bottom_left_37, TMP_Fragment_absolute_bottom_right_38, TMP_Fragment_process_text_39, TMP_Fragment_exclude_trailing_white_space$q_40, TMP_Fragment_soft_hyphens_need_processing$q_41, TMP_Fragment_normalized_soft_hyphen_42, TMP_Fragment_process_soft_hyphens_43, TMP_Fragment_strip_zero_width_spaces_44;

          def.original_text = def.word_spacing = def.width = def.document = def.format_state = def.text = nil;
          
          self.$attr_reader("format_state", "text");
          self.$attr_writer("width");
          self.$attr_accessor("line_height", "descender", "ascender");
          self.$attr_accessor("word_spacing", "left", "baseline");
          
          Opal.defn(self, '$initialize', TMP_Fragment_initialize_1 = function $$initialize(text, format_state, document) {
            var self = this;

            
            self.format_state = format_state;
            self.document = document;
            self.word_spacing = 0;
            self.original_text = text;
            return (self.text = self.$process_text(self.original_text));
          }, TMP_Fragment_initialize_1.$$arity = 3);
          
          Opal.defn(self, '$width', TMP_Fragment_width_2 = function $$width() {
            var self = this;

            if (self.word_spacing['$=='](0)) {
              return self.width
              } else {
              return $rb_plus(self.width, $rb_times(self.word_spacing, self.$space_count()))
            }
          }, TMP_Fragment_width_2.$$arity = 0);
          
          Opal.defn(self, '$height', TMP_Fragment_height_3 = function $$height() {
            var self = this;

            return $rb_minus(self.$top(), self.$bottom())
          }, TMP_Fragment_height_3.$$arity = 0);
          
          Opal.defn(self, '$subscript?', TMP_Fragment_subscript$q_4 = function() {
            var self = this;

            return self.$styles()['$include?']("subscript")
          }, TMP_Fragment_subscript$q_4.$$arity = 0);
          
          Opal.defn(self, '$superscript?', TMP_Fragment_superscript$q_5 = function() {
            var self = this;

            return self.$styles()['$include?']("superscript")
          }, TMP_Fragment_superscript$q_5.$$arity = 0);
          
          Opal.defn(self, '$y_offset', TMP_Fragment_y_offset_6 = function $$y_offset() {
            var self = this;

            if ($truthy(self['$subscript?']())) {
              return self.$descender()['$-@']()
            } else if ($truthy(self['$superscript?']())) {
              return $rb_times(0.85, self.$ascender())
              } else {
              return 0
            }
          }, TMP_Fragment_y_offset_6.$$arity = 0);
          
          Opal.defn(self, '$bounding_box', TMP_Fragment_bounding_box_7 = function $$bounding_box() {
            var self = this;

            return [self.$left(), self.$bottom(), self.$right(), self.$top()]
          }, TMP_Fragment_bounding_box_7.$$arity = 0);
          
          Opal.defn(self, '$absolute_bounding_box', TMP_Fragment_absolute_bounding_box_8 = function $$absolute_bounding_box() {
            var self = this, box = nil, $writer = nil;

            
            box = self.$bounding_box();
            
            $writer = [0, $rb_plus(box['$[]'](0), self.document.$bounds().$absolute_left())];
            $send(box, '[]=', Opal.to_a($writer));
            $writer[$rb_minus($writer["length"], 1)];;
            
            $writer = [2, $rb_plus(box['$[]'](2), self.document.$bounds().$absolute_left())];
            $send(box, '[]=', Opal.to_a($writer));
            $writer[$rb_minus($writer["length"], 1)];;
            
            $writer = [1, $rb_plus(box['$[]'](1), self.document.$bounds().$absolute_bottom())];
            $send(box, '[]=', Opal.to_a($writer));
            $writer[$rb_minus($writer["length"], 1)];;
            
            $writer = [3, $rb_plus(box['$[]'](3), self.document.$bounds().$absolute_bottom())];
            $send(box, '[]=', Opal.to_a($writer));
            $writer[$rb_minus($writer["length"], 1)];;
            return box;
          }, TMP_Fragment_absolute_bounding_box_8.$$arity = 0);
          
          Opal.defn(self, '$underline_points', TMP_Fragment_underline_points_9 = function $$underline_points() {
            var self = this, y = nil;

            
            y = $rb_minus(self.$baseline(), 1.25);
            return [[self.$left(), y], [self.$right(), y]];
          }, TMP_Fragment_underline_points_9.$$arity = 0);
          
          Opal.defn(self, '$strikethrough_points', TMP_Fragment_strikethrough_points_10 = function $$strikethrough_points() {
            var self = this, y = nil;

            
            y = $rb_plus(self.$baseline(), $rb_times(self.$ascender(), 0.3));
            return [[self.$left(), y], [self.$right(), y]];
          }, TMP_Fragment_strikethrough_points_10.$$arity = 0);
          
          Opal.defn(self, '$styles', TMP_Fragment_styles_11 = function $$styles() {
            var $a, self = this;

            return ($truthy($a = self.format_state['$[]']("styles")) ? $a : [])
          }, TMP_Fragment_styles_11.$$arity = 0);
          
          Opal.defn(self, '$link', TMP_Fragment_link_12 = function $$link() {
            var self = this;

            return self.format_state['$[]']("link")
          }, TMP_Fragment_link_12.$$arity = 0);
          
          Opal.defn(self, '$anchor', TMP_Fragment_anchor_13 = function $$anchor() {
            var self = this;

            return self.format_state['$[]']("anchor")
          }, TMP_Fragment_anchor_13.$$arity = 0);
          
          Opal.defn(self, '$local', TMP_Fragment_local_14 = function $$local() {
            var self = this;

            return self.format_state['$[]']("local")
          }, TMP_Fragment_local_14.$$arity = 0);
          
          Opal.defn(self, '$color', TMP_Fragment_color_15 = function $$color() {
            var self = this;

            return self.format_state['$[]']("color")
          }, TMP_Fragment_color_15.$$arity = 0);
          
          Opal.defn(self, '$font', TMP_Fragment_font_16 = function $$font() {
            var self = this;

            return self.format_state['$[]']("font")
          }, TMP_Fragment_font_16.$$arity = 0);
          
          Opal.defn(self, '$size', TMP_Fragment_size_17 = function $$size() {
            var self = this;

            return self.format_state['$[]']("size")
          }, TMP_Fragment_size_17.$$arity = 0);
          
          Opal.defn(self, '$character_spacing', TMP_Fragment_character_spacing_18 = function $$character_spacing() {
            var $a, self = this;

            return ($truthy($a = self.format_state['$[]']("character_spacing")) ? $a : self.document.$character_spacing())
          }, TMP_Fragment_character_spacing_18.$$arity = 0);
          
          Opal.defn(self, '$direction', TMP_Fragment_direction_19 = function $$direction() {
            var self = this;

            return self.format_state['$[]']("direction")
          }, TMP_Fragment_direction_19.$$arity = 0);
          
          Opal.defn(self, '$default_direction=', TMP_Fragment_default_direction$eq_20 = function(direction) {
            var self = this, $writer = nil;

            if ($truthy(self.format_state['$[]']("direction"))) {
              return nil
              } else {
              
              
              $writer = ["direction", direction];
              $send(self.format_state, '[]=', Opal.to_a($writer));
              $writer[$rb_minus($writer["length"], 1)];;
              return (self.text = self.$process_text(self.original_text));
            }
          }, TMP_Fragment_default_direction$eq_20.$$arity = 1);
          
          Opal.defn(self, '$include_trailing_white_space!', TMP_Fragment_include_trailing_white_space$B_21 = function() {
            var self = this;

            
            self.format_state.$delete("exclude_trailing_white_space");
            return (self.text = self.$process_text(self.original_text));
          }, TMP_Fragment_include_trailing_white_space$B_21.$$arity = 0);
          
          Opal.defn(self, '$space_count', TMP_Fragment_space_count_22 = function $$space_count() {
            var self = this;

            return self.text.$count(" ")
          }, TMP_Fragment_space_count_22.$$arity = 0);
          
          Opal.defn(self, '$callback_objects', TMP_Fragment_callback_objects_23 = function $$callback_objects() {
            var self = this, callback = nil;

            
            callback = self.format_state['$[]']("callback");
            if ($truthy(callback['$nil?']())) {
              return []
            } else if ($truthy(callback['$is_a?'](Opal.const_get_relative($nesting, 'Array')))) {
              return callback
              } else {
              return [callback]
            };
          }, TMP_Fragment_callback_objects_23.$$arity = 0);
          
          Opal.defn(self, '$right', TMP_Fragment_right_24 = function $$right() {
            var self = this;

            return $rb_plus(self.$left(), self.$width())
          }, TMP_Fragment_right_24.$$arity = 0);
          
          Opal.defn(self, '$top', TMP_Fragment_top_25 = function $$top() {
            var self = this;

            return $rb_plus(self.$baseline(), self.$ascender())
          }, TMP_Fragment_top_25.$$arity = 0);
          
          Opal.defn(self, '$bottom', TMP_Fragment_bottom_26 = function $$bottom() {
            var self = this;

            return $rb_minus(self.$baseline(), self.$descender())
          }, TMP_Fragment_bottom_26.$$arity = 0);
          
          Opal.defn(self, '$top_left', TMP_Fragment_top_left_27 = function $$top_left() {
            var self = this;

            return [self.$left(), self.$top()]
          }, TMP_Fragment_top_left_27.$$arity = 0);
          
          Opal.defn(self, '$top_right', TMP_Fragment_top_right_28 = function $$top_right() {
            var self = this;

            return [self.$right(), self.$top()]
          }, TMP_Fragment_top_right_28.$$arity = 0);
          
          Opal.defn(self, '$bottom_right', TMP_Fragment_bottom_right_29 = function $$bottom_right() {
            var self = this;

            return [self.$right(), self.$bottom()]
          }, TMP_Fragment_bottom_right_29.$$arity = 0);
          
          Opal.defn(self, '$bottom_left', TMP_Fragment_bottom_left_30 = function $$bottom_left() {
            var self = this;

            return [self.$left(), self.$bottom()]
          }, TMP_Fragment_bottom_left_30.$$arity = 0);
          
          Opal.defn(self, '$absolute_left', TMP_Fragment_absolute_left_31 = function $$absolute_left() {
            var self = this;

            return self.$absolute_bounding_box()['$[]'](0)
          }, TMP_Fragment_absolute_left_31.$$arity = 0);
          
          Opal.defn(self, '$absolute_right', TMP_Fragment_absolute_right_32 = function $$absolute_right() {
            var self = this;

            return self.$absolute_bounding_box()['$[]'](2)
          }, TMP_Fragment_absolute_right_32.$$arity = 0);
          
          Opal.defn(self, '$absolute_top', TMP_Fragment_absolute_top_33 = function $$absolute_top() {
            var self = this;

            return self.$absolute_bounding_box()['$[]'](3)
          }, TMP_Fragment_absolute_top_33.$$arity = 0);
          
          Opal.defn(self, '$absolute_bottom', TMP_Fragment_absolute_bottom_34 = function $$absolute_bottom() {
            var self = this;

            return self.$absolute_bounding_box()['$[]'](1)
          }, TMP_Fragment_absolute_bottom_34.$$arity = 0);
          
          Opal.defn(self, '$absolute_top_left', TMP_Fragment_absolute_top_left_35 = function $$absolute_top_left() {
            var self = this;

            return [self.$absolute_left(), self.$absolute_top()]
          }, TMP_Fragment_absolute_top_left_35.$$arity = 0);
          
          Opal.defn(self, '$absolute_top_right', TMP_Fragment_absolute_top_right_36 = function $$absolute_top_right() {
            var self = this;

            return [self.$absolute_right(), self.$absolute_top()]
          }, TMP_Fragment_absolute_top_right_36.$$arity = 0);
          
          Opal.defn(self, '$absolute_bottom_left', TMP_Fragment_absolute_bottom_left_37 = function $$absolute_bottom_left() {
            var self = this;

            return [self.$absolute_left(), self.$absolute_bottom()]
          }, TMP_Fragment_absolute_bottom_left_37.$$arity = 0);
          
          Opal.defn(self, '$absolute_bottom_right', TMP_Fragment_absolute_bottom_right_38 = function $$absolute_bottom_right() {
            var self = this;

            return [self.$absolute_right(), self.$absolute_bottom()]
          }, TMP_Fragment_absolute_bottom_right_38.$$arity = 0);
          self.$private();
          
          Opal.defn(self, '$process_text', TMP_Fragment_process_text_39 = function $$process_text(text) {
            var self = this, string = nil, $case = nil;

            
            string = self.$strip_zero_width_spaces(text);
            if ($truthy(self['$exclude_trailing_white_space?']())) {
              
              string = string.$rstrip();
              if ($truthy(self['$soft_hyphens_need_processing?'](string))) {
                string = $rb_plus(self.$process_soft_hyphens(string['$[]']($range(0, -2, false))), string['$[]']($range(-1, -1, false)))};
            } else if ($truthy(self['$soft_hyphens_need_processing?'](string))) {
              string = self.$process_soft_hyphens(string)};
            return (function() {$case = self.$direction();
            if ("rtl"['$===']($case)) {return string.$reverse()}
            else {return string}})();
          }, TMP_Fragment_process_text_39.$$arity = 1);
          
          Opal.defn(self, '$exclude_trailing_white_space?', TMP_Fragment_exclude_trailing_white_space$q_40 = function() {
            var self = this;

            return self.format_state['$[]']("exclude_trailing_white_space")
          }, TMP_Fragment_exclude_trailing_white_space$q_40.$$arity = 0);
          
          Opal.defn(self, '$soft_hyphens_need_processing?', TMP_Fragment_soft_hyphens_need_processing$q_41 = function(string) {
            var $a, self = this;

            return ($truthy($a = $rb_gt(string.$length(), 0)) ? self.$normalized_soft_hyphen() : $a)
          }, TMP_Fragment_soft_hyphens_need_processing$q_41.$$arity = 1);
          
          Opal.defn(self, '$normalized_soft_hyphen', TMP_Fragment_normalized_soft_hyphen_42 = function $$normalized_soft_hyphen() {
            var self = this;

            return self.format_state['$[]']("normalized_soft_hyphen")
          }, TMP_Fragment_normalized_soft_hyphen_42.$$arity = 0);
          
          Opal.defn(self, '$process_soft_hyphens', TMP_Fragment_process_soft_hyphens_43 = function $$process_soft_hyphens(string) {
            var self = this;

            
            if ($truthy(string.$encoding()['$!='](self.$normalized_soft_hyphen().$encoding()))) {
              string.$force_encoding(self.$normalized_soft_hyphen().$encoding())};
            return string.$gsub(self.$normalized_soft_hyphen(), "");
          }, TMP_Fragment_process_soft_hyphens_43.$$arity = 1);
          return (Opal.defn(self, '$strip_zero_width_spaces', TMP_Fragment_strip_zero_width_spaces_44 = function $$strip_zero_width_spaces(string) {
            var self = this;

            if (string.$encoding()['$=='](Opal.const_get_qualified(Opal.const_get_qualified('::', 'Encoding'), 'UTF_8'))) {
              return string.$gsub(Opal.const_get_qualified(Opal.const_get_qualified(Opal.const_get_relative($nesting, 'Prawn'), 'Text'), 'ZWSP'), "")
              } else {
              return string
            }
          }, TMP_Fragment_strip_zero_width_spaces_44.$$arity = 1), nil) && 'strip_zero_width_spaces';
        })($nesting[0], null, $nesting)
      })($nesting[0], $nesting)
    })($nesting[0], $nesting)
  })($nesting[0], $nesting)
};

/* Generated by Opal 0.11.0 */
Opal.modules["prawn/text/formatted"] = function(Opal) {
  var self = Opal.top, $nesting = [], nil = Opal.nil, $breaker = Opal.breaker, $slice = Opal.slice;

  
  self.$require("prawn/text/formatted"+ '/../' + "formatted/wrap");
  self.$require("prawn/text/formatted"+ '/../' + "formatted/box");
  self.$require("prawn/text/formatted"+ '/../' + "formatted/parser");
  return self.$require("prawn/text/formatted"+ '/../' + "formatted/fragment");
};

/* Generated by Opal 0.11.0 */
Opal.modules["prawn/text/box"] = function(Opal) {
  function $rb_minus(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs - rhs : lhs['$-'](rhs);
  }
  var self = Opal.top, $nesting = [], nil = Opal.nil, $breaker = Opal.breaker, $slice = Opal.slice, $module = Opal.module, $send = Opal.send, $truthy = Opal.truthy, $hash2 = Opal.hash2, $klass = Opal.klass;

  Opal.add_stubs(['$dup', '$[]=', '$-', '$delete', '$is_a?', '$format', '$text_formatter', '$new', '$render', '$join', '$collect', '$[]']);
  
  self.$require("prawn/text/box"+ '/../' + "formatted/box");
  return (function($base, $parent_nesting) {
    var $Prawn, self = $Prawn = $module($base, 'Prawn');

    var def = self.$$proto, $nesting = [self].concat($parent_nesting);

    (function($base, $parent_nesting) {
      var $Text, self = $Text = $module($base, 'Text');

      var def = self.$$proto, $nesting = [self].concat($parent_nesting), TMP_Text_text_box_1;

      
      
      Opal.defn(self, '$text_box', TMP_Text_text_box_1 = function $$text_box(string, options) {
        var self = this, $writer = nil, box = nil, p = nil, array = nil;

        if (options == null) {
          options = $hash2([], {});
        }
        
        options = options.$dup();
        
        $writer = ["document", self];
        $send(options, '[]=', Opal.to_a($writer));
        $writer[$rb_minus($writer["length"], 1)];;
        box = (function() {if ($truthy((p = options.$delete("inline_format")))) {
          
          if ($truthy(p['$is_a?'](Opal.const_get_relative($nesting, 'Array')))) {
            } else {
            p = []
          };
          array = $send(self.$text_formatter(), 'format', [string].concat(Opal.to_a(p)));
          return Opal.const_get_qualified(Opal.const_get_qualified(Opal.const_get_relative($nesting, 'Text'), 'Formatted'), 'Box').$new(array, options);
          } else {
          return Opal.const_get_qualified(Opal.const_get_relative($nesting, 'Text'), 'Box').$new(string, options)
        }; return nil; })();
        return box.$render();
      }, TMP_Text_text_box_1.$$arity = -2);
      (function($base, $super, $parent_nesting) {
        function $Box(){};
        var self = $Box = $klass($base, $super, 'Box', $Box);

        var def = self.$$proto, $nesting = [self].concat($parent_nesting), TMP_Box_initialize_2, TMP_Box_render_3;

        
        
        Opal.defn(self, '$initialize', TMP_Box_initialize_2 = function $$initialize(string, options) {
          var self = this, $iter = TMP_Box_initialize_2.$$p, $yield = $iter || nil;

          if (options == null) {
            options = $hash2([], {});
          }
          if ($iter) TMP_Box_initialize_2.$$p = null;
          return $send(self, Opal.find_super_dispatcher(self, 'initialize', TMP_Box_initialize_2, false), [[$hash2(["text"], {"text": string})], options], null)
        }, TMP_Box_initialize_2.$$arity = -2);
        return (Opal.defn(self, '$render', TMP_Box_render_3 = function $$render(flags) {
          var TMP_4, self = this, $iter = TMP_Box_render_3.$$p, $yield = $iter || nil, leftover = nil;

          if (flags == null) {
            flags = $hash2([], {});
          }
          if ($iter) TMP_Box_render_3.$$p = null;
          
          leftover = $send(self, Opal.find_super_dispatcher(self, 'render', TMP_Box_render_3, false), [flags], null);
          return $send(leftover, 'collect', [], (TMP_4 = function(hash){var self = TMP_4.$$s || this;
if (hash == null) hash = nil;
          return hash['$[]']("text")}, TMP_4.$$s = self, TMP_4.$$arity = 1, TMP_4)).$join();
        }, TMP_Box_render_3.$$arity = -1), nil) && 'render';
      })($nesting[0], Opal.const_get_qualified(Opal.const_get_qualified(Opal.const_get_qualified(Opal.const_get_relative($nesting, 'Prawn'), 'Text'), 'Formatted'), 'Box'), $nesting);
    })($nesting[0], $nesting)
  })($nesting[0], $nesting);
};

/* Generated by Opal 0.11.0 */
Opal.modules["prawn/text"] = function(Opal) {
  function $rb_minus(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs - rhs : lhs['$-'](rhs);
  }
  function $rb_plus(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs + rhs : lhs['$+'](rhs);
  }
  function $rb_gt(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs > rhs : lhs['$>'](rhs);
  }
  function $rb_lt(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs < rhs : lhs['$<'](rhs);
  }
  var self = Opal.top, $nesting = [], nil = Opal.nil, $breaker = Opal.breaker, $slice = Opal.slice, $module = Opal.module, $truthy = Opal.truthy, $send = Opal.send, $hash2 = Opal.hash2;

  Opal.add_stubs(['$require', '$include', '$pack', '$nil?', '$dup', '$[]', '$is_a?', '$delete', '$format', '$text_formatter', '$formatted_text', '$inspect_options_for_text', '$map', '$merge', '$each', '$array_paragraphs', '$draw_indented_formatted_line', '$move_past_bottom', '$fill_formatted_text_box', '$draw_remaining_formatted_text_on_new_pages', '$inspect_options_for_draw_text', '$to_s', '$save_font', '$process_text_options', '$normalize_encoding!', '$font', '$font_size', '$draw_text!', '$unicode?', '$hide_m17n_warning', '$class', '$ascii_only?', '$warn', '$hide_m17n_warning=', '$-', '$map_to_absolute', '$add_text_content', '$height_of_formatted', '$fail', '$process_final_gap_option', '$new', '$render', '$height', '$+', '$line_gap', '$leading', '$private', '$>', '$length', '$==', '$fetch', '$text_direction', '$indent', '$merge_text_box_positioning_options', '$nothing_printed?', '$everything_printed?', '$y', '$y=', '$stretchy?', '$absolute_bottom', '$[]=', '$width', '$bounds', '$left_side', '$absolute_left', '$default_kerning?', '$verify_options', '$process_indent_paragraphs_option', '$<']);
  
  self.$require("zlib");
  self.$require("pdf/core/text");
  self.$require("prawn/text"+ '/../' + "text/formatted");
  self.$require("prawn/text"+ '/../' + "text/box");
  return (function($base, $parent_nesting) {
    var $Prawn, self = $Prawn = $module($base, 'Prawn');

    var def = self.$$proto, $nesting = [self].concat($parent_nesting);

    (function($base, $parent_nesting) {
      var $Text, self = $Text = $module($base, 'Text');

      var def = self.$$proto, $nesting = [self].concat($parent_nesting), TMP_Text_text_1, TMP_Text_formatted_text_4, TMP_Text_draw_text_7, TMP_Text_draw_text$B_8, TMP_Text_height_of_9, TMP_Text_height_of_formatted_10, TMP_Text_draw_remaining_formatted_text_on_new_pages_11, TMP_Text_draw_indented_formatted_line_13, TMP_Text_fill_formatted_text_box_14, TMP_Text_merge_text_box_positioning_options_15, TMP_Text_inspect_options_for_draw_text_16, TMP_Text_inspect_options_for_text_17, TMP_Text_process_final_gap_option_18, TMP_Text_process_indent_paragraphs_option_19, TMP_Text_move_text_position_20;

      
      self.$include(Opal.const_get_qualified(Opal.const_get_qualified(Opal.const_get_relative($nesting, 'PDF'), 'Core'), 'Text'));
      self.$include(Opal.const_get_qualified(Opal.const_get_qualified(Opal.const_get_relative($nesting, 'Prawn'), 'Text'), 'Formatted'));
      Opal.const_set(Opal.const_get_qualified(Opal.const_get_relative($nesting, 'Prawn'), 'Text'), 'NBSP', "");
      Opal.const_set(Opal.const_get_qualified(Opal.const_get_relative($nesting, 'Prawn'), 'Text'), 'ZWSP', [8203].$pack("U"));
      Opal.const_set(Opal.const_get_qualified(Opal.const_get_relative($nesting, 'Prawn'), 'Text'), 'SHY', "");
      
      Opal.defn(self, '$text', TMP_Text_text_1 = function $$text(string, options) {
        var self = this, p = nil, array = nil;

        if (options == null) {
          options = $hash2([], {});
        }
        
        if ($truthy(string['$nil?']())) {
          return false};
        options = options.$dup();
        if ($truthy((p = options['$[]']("inline_format")))) {
          
          if ($truthy(p['$is_a?'](Opal.const_get_relative($nesting, 'Array')))) {
            } else {
            p = []
          };
          options.$delete("inline_format");
          array = $send(self.$text_formatter(), 'format', [string].concat(Opal.to_a(p)));
          } else {
          array = [$hash2(["text"], {"text": string})]
        };
        return self.$formatted_text(array, options);
      }, TMP_Text_text_1.$$arity = -2);
      
      Opal.defn(self, '$formatted_text', TMP_Text_formatted_text_4 = function $$formatted_text(array, options) {
        var TMP_2, TMP_3, self = this, color = nil, remaining_text = nil;
        if (self.indent_paragraphs == null) self.indent_paragraphs = nil;

        if (options == null) {
          options = $hash2([], {});
        }
        
        options = self.$inspect_options_for_text(options.$dup());
        if ($truthy((color = options.$delete("color")))) {
          array = $send(array, 'map', [], (TMP_2 = function(fragment){var self = TMP_2.$$s || this;
if (fragment == null) fragment = nil;
          if ($truthy(fragment['$[]']("color"))) {
              return fragment
              } else {
              return fragment.$merge($hash2(["color"], {"color": color}))
            }}, TMP_2.$$s = self, TMP_2.$$arity = 1, TMP_2))};
        if ($truthy(self.indent_paragraphs)) {
          return $send(self.$text_formatter().$array_paragraphs(array), 'each', [], (TMP_3 = function(paragraph){var self = TMP_3.$$s || this, remaining_text = nil;
            if (self.no_text_printed == null) self.no_text_printed = nil;
            if (self.all_text_printed == null) self.all_text_printed = nil;
            if (self.bounding_box == null) self.bounding_box = nil;
if (paragraph == null) paragraph = nil;
          
            remaining_text = self.$draw_indented_formatted_line(paragraph, options);
            if ($truthy(self.no_text_printed)) {
              if ($truthy(self.all_text_printed)) {
                } else {
                
                self.bounding_box.$move_past_bottom();
                remaining_text = self.$draw_indented_formatted_line(paragraph, options);
              }};
            remaining_text = self.$fill_formatted_text_box(remaining_text, options);
            return self.$draw_remaining_formatted_text_on_new_pages(remaining_text, options);}, TMP_3.$$s = self, TMP_3.$$arity = 1, TMP_3))
          } else {
          
          remaining_text = self.$fill_formatted_text_box(array, options);
          return self.$draw_remaining_formatted_text_on_new_pages(remaining_text, options);
        };
      }, TMP_Text_formatted_text_4.$$arity = -2);
      
      Opal.defn(self, '$draw_text', TMP_Text_draw_text_7 = function $$draw_text(text, options) {
        var TMP_5, self = this;

        
        options = self.$inspect_options_for_draw_text(options.$dup());
        text = text.$to_s().$dup();
        return $send(self, 'save_font', [], (TMP_5 = function(){var self = TMP_5.$$s || this, TMP_6;

        
          self.$process_text_options(options);
          self.$font()['$normalize_encoding!'](text);
          return $send(self, 'font_size', [options['$[]']("size")], (TMP_6 = function(){var self = TMP_6.$$s || this;

          return self['$draw_text!'](text, options)}, TMP_6.$$s = self, TMP_6.$$arity = 0, TMP_6));}, TMP_5.$$s = self, TMP_5.$$arity = 0, TMP_5));
      }, TMP_Text_draw_text_7.$$arity = 2);
      
      Opal.defn(self, '$draw_text!', TMP_Text_draw_text$B_8 = function(text, options) {
        var $a, $b, self = this, $writer = nil, x = nil, y = nil;

        
        if ($truthy(($truthy($a = ($truthy($b = self.$font()['$unicode?']()) ? $b : self.$font().$class().$hide_m17n_warning())) ? $a : text['$ascii_only?']()))) {
          } else {
          
          self.$warn("" + "PDF's built-in fonts have very limited support for " + "internationalized text.\nIf you need full UTF-8 support, " + "consider using a TTF font instead.\n\nTo disable this " + "warning, add the following line to your code:\n" + "Prawn::Font::AFM.hide_m17n_warning = true\n");
          
          $writer = [true];
          $send(self.$font().$class(), 'hide_m17n_warning=', Opal.to_a($writer));
          $writer[$rb_minus($writer["length"], 1)];;
        };
        $b = self.$map_to_absolute(options['$[]']("at")), $a = Opal.to_ary($b), (x = ($a[0] == null ? nil : $a[0])), (y = ($a[1] == null ? nil : $a[1])), $b;
        return self.$add_text_content(text, x, y, options);
      }, TMP_Text_draw_text$B_8.$$arity = 2);
      
      Opal.defn(self, '$height_of', TMP_Text_height_of_9 = function $$height_of(string, options) {
        var self = this;

        if (options == null) {
          options = $hash2([], {});
        }
        return self.$height_of_formatted([$hash2(["text"], {"text": string})], options)
      }, TMP_Text_height_of_9.$$arity = -2);
      
      Opal.defn(self, '$height_of_formatted', TMP_Text_height_of_formatted_10 = function $$height_of_formatted(array, options) {
        var self = this, box = nil, height = nil;
        if (self.final_gap == null) self.final_gap = nil;

        if (options == null) {
          options = $hash2([], {});
        }
        
        if ($truthy(options['$[]']("indent_paragraphs"))) {
          self.$fail(Opal.const_get_relative($nesting, 'NotImplementedError'), "" + ":indent_paragraphs option not available" + "with height_of")};
        self.$process_final_gap_option(options);
        box = Opal.const_get_qualified(Opal.const_get_qualified(Opal.const_get_relative($nesting, 'Text'), 'Formatted'), 'Box').$new(array, options.$merge($hash2(["height", "document"], {"height": 100000000, "document": self})));
        box.$render($hash2(["dry_run"], {"dry_run": true}));
        height = box.$height();
        if ($truthy(self.final_gap)) {
          height = $rb_plus(height, $rb_plus(box.$line_gap(), box.$leading()))};
        return height;
      }, TMP_Text_height_of_formatted_10.$$arity = -2);
      self.$private();
      
      Opal.defn(self, '$draw_remaining_formatted_text_on_new_pages', TMP_Text_draw_remaining_formatted_text_on_new_pages_11 = function $$draw_remaining_formatted_text_on_new_pages(remaining_text, options) {
        var $a, self = this, previous_remaining_text = nil;
        if (self.bounding_box == null) self.bounding_box = nil;

        while ($truthy($rb_gt(remaining_text.$length(), 0))) {
          
          self.bounding_box.$move_past_bottom();
          previous_remaining_text = remaining_text;
          remaining_text = self.$fill_formatted_text_box(remaining_text, options);
          if (remaining_text['$=='](previous_remaining_text)) {
            break;};
        }
      }, TMP_Text_draw_remaining_formatted_text_on_new_pages_11.$$arity = 2);
      
      Opal.defn(self, '$draw_indented_formatted_line', TMP_Text_draw_indented_formatted_line_13 = function $$draw_indented_formatted_line(string, options) {
        var TMP_12, self = this, gap = nil;
        if (self.indent_paragraphs == null) self.indent_paragraphs = nil;

        
        if (options.$fetch("direction", self.$text_direction())['$==']("ltr")) {
          gap = [self.indent_paragraphs, 0]
          } else {
          gap = [0, self.indent_paragraphs]
        };
        return $send(self, 'indent', Opal.to_a(gap), (TMP_12 = function(){var self = TMP_12.$$s || this;

        return self.$fill_formatted_text_box(string, options.$dup().$merge($hash2(["single_line"], {"single_line": true})))}, TMP_12.$$s = self, TMP_12.$$arity = 0, TMP_12));
      }, TMP_Text_draw_indented_formatted_line_13.$$arity = 2);
      
      Opal.defn(self, '$fill_formatted_text_box', TMP_Text_fill_formatted_text_box_14 = function $$fill_formatted_text_box(text, options) {
        var self = this, box = nil, remaining_text = nil, $writer = nil;
        if (self.final_gap == null) self.final_gap = nil;

        
        self.$merge_text_box_positioning_options(options);
        box = Opal.const_get_qualified(Opal.const_get_qualified(Opal.const_get_relative($nesting, 'Text'), 'Formatted'), 'Box').$new(text, options);
        remaining_text = box.$render();
        self.no_text_printed = box['$nothing_printed?']();
        self.all_text_printed = box['$everything_printed?']();
        
        $writer = [$rb_minus(self.$y(), box.$height())];
        $send(self, 'y=', Opal.to_a($writer));
        $writer[$rb_minus($writer["length"], 1)];;
        if ($truthy(self.final_gap)) {
          
          $writer = [$rb_minus(self.$y(), $rb_plus(box.$line_gap(), box.$leading()))];
          $send(self, 'y=', Opal.to_a($writer));
          $writer[$rb_minus($writer["length"], 1)];};
        return remaining_text;
      }, TMP_Text_fill_formatted_text_box_14.$$arity = 2);
      
      Opal.defn(self, '$merge_text_box_positioning_options', TMP_Text_merge_text_box_positioning_options_15 = function $$merge_text_box_positioning_options(options) {
        var self = this, bottom = nil, $writer = nil;
        if (self.bounding_box == null) self.bounding_box = nil;
        if (self.margin_box == null) self.margin_box = nil;

        
        bottom = (function() {if ($truthy(self.bounding_box['$stretchy?']())) {
          return self.margin_box.$absolute_bottom()
          } else {
          return self.bounding_box.$absolute_bottom()
        }; return nil; })();
        
        $writer = ["height", $rb_minus(self.$y(), bottom)];
        $send(options, '[]=', Opal.to_a($writer));
        $writer[$rb_minus($writer["length"], 1)];;
        
        $writer = ["width", self.$bounds().$width()];
        $send(options, '[]=', Opal.to_a($writer));
        $writer[$rb_minus($writer["length"], 1)];;
        
        $writer = ["at", [$rb_minus(self.bounding_box.$left_side(), self.bounding_box.$absolute_left()), $rb_minus(self.$y(), self.bounding_box.$absolute_bottom())]];
        $send(options, '[]=', Opal.to_a($writer));
        return $writer[$rb_minus($writer["length"], 1)];;
      }, TMP_Text_merge_text_box_positioning_options_15.$$arity = 1);
      
      Opal.defn(self, '$inspect_options_for_draw_text', TMP_Text_inspect_options_for_draw_text_16 = function $$inspect_options_for_draw_text(options) {
        var self = this, $writer = nil, valid_options = nil;

        
        if ($truthy(options['$[]']("at")['$nil?']())) {
          self.$fail(Opal.const_get_relative($nesting, 'ArgumentError'), "The :at option is required for draw_text")
        } else if ($truthy(options['$[]']("align"))) {
          self.$fail(Opal.const_get_relative($nesting, 'ArgumentError'), "The :align option does not work with draw_text")};
        if ($truthy(options['$[]']("kerning")['$nil?']())) {
          
          $writer = ["kerning", self['$default_kerning?']()];
          $send(options, '[]=', Opal.to_a($writer));
          $writer[$rb_minus($writer["length"], 1)];};
        valid_options = $rb_plus(Opal.const_get_qualified(Opal.const_get_qualified(Opal.const_get_qualified(Opal.const_get_relative($nesting, 'PDF'), 'Core'), 'Text'), 'VALID_OPTIONS'), ["at", "rotate"]);
        Opal.const_get_relative($nesting, 'Prawn').$verify_options(valid_options, options);
        return options;
      }, TMP_Text_inspect_options_for_draw_text_16.$$arity = 1);
      
      Opal.defn(self, '$inspect_options_for_text', TMP_Text_inspect_options_for_text_17 = function $$inspect_options_for_text(options) {
        var self = this, $writer = nil;

        
        if ($truthy(options['$[]']("at"))) {
          self.$fail(Opal.const_get_relative($nesting, 'ArgumentError'), "" + ":at is no longer a valid option with text." + "use draw_text or text_box instead")};
        self.$process_final_gap_option(options);
        self.$process_indent_paragraphs_option(options);
        
        $writer = ["document", self];
        $send(options, '[]=', Opal.to_a($writer));
        $writer[$rb_minus($writer["length"], 1)];;
        return options;
      }, TMP_Text_inspect_options_for_text_17.$$arity = 1);
      
      Opal.defn(self, '$process_final_gap_option', TMP_Text_process_final_gap_option_18 = function $$process_final_gap_option(options) {
        var $a, self = this;

        
        self.final_gap = ($truthy($a = options['$[]']("final_gap")['$nil?']()) ? $a : options['$[]']("final_gap"));
        return options.$delete("final_gap");
      }, TMP_Text_process_final_gap_option_18.$$arity = 1);
      
      Opal.defn(self, '$process_indent_paragraphs_option', TMP_Text_process_indent_paragraphs_option_19 = function $$process_indent_paragraphs_option(options) {
        var self = this;

        
        self.indent_paragraphs = options['$[]']("indent_paragraphs");
        return options.$delete("indent_paragraphs");
      }, TMP_Text_process_indent_paragraphs_option_19.$$arity = 1);
      
      Opal.defn(self, '$move_text_position', TMP_Text_move_text_position_20 = function $$move_text_position(dy) {
        var self = this, bottom = nil, $writer = nil;
        if (self.bounding_box == null) self.bounding_box = nil;
        if (self.margin_box == null) self.margin_box = nil;

        
        bottom = (function() {if ($truthy(self.bounding_box['$stretchy?']())) {
          return self.margin_box.$absolute_bottom()
          } else {
          return self.bounding_box.$absolute_bottom()
        }; return nil; })();
        if ($truthy($rb_lt($rb_minus(self.$y(), dy), bottom))) {
          self.bounding_box.$move_past_bottom()};
        
        $writer = [$rb_minus(self.$y(), dy)];
        $send(self, 'y=', Opal.to_a($writer));
        return $writer[$rb_minus($writer["length"], 1)];;
      }, TMP_Text_move_text_position_20.$$arity = 1);
    })($nesting[0], $nesting)
  })($nesting[0], $nesting);
};

/* Generated by Opal 0.11.0 */
Opal.modules["prawn/graphics/blend_mode"] = function(Opal) {
  function $rb_minus(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs - rhs : lhs['$-'](rhs);
  }
  var self = Opal.top, $nesting = [], nil = Opal.nil, $breaker = Opal.breaker, $slice = Opal.slice, $module = Opal.module, $truthy = Opal.truthy, $hash2 = Opal.hash2, $send = Opal.send, $hash = Opal.hash;

  Opal.add_stubs(['$min_version', '$renderer', '$save_graphics_state', '$add_content', '$blend_mode_dictionary_name', '$restore_graphics_state', '$private', '$join', '$Array', '$blend_mode_dictionary_registry', '$[]', '$ref!', '$[]=', '$-', '$merge!', '$ext_gstates', '$page']);
  return (function($base, $parent_nesting) {
    var $Prawn, self = $Prawn = $module($base, 'Prawn');

    var def = self.$$proto, $nesting = [self].concat($parent_nesting);

    (function($base, $parent_nesting) {
      var $Graphics, self = $Graphics = $module($base, 'Graphics');

      var def = self.$$proto, $nesting = [self].concat($parent_nesting);

      (function($base, $parent_nesting) {
        var $BlendMode, self = $BlendMode = $module($base, 'BlendMode');

        var def = self.$$proto, $nesting = [self].concat($parent_nesting), TMP_BlendMode_blend_mode_1, TMP_BlendMode_blend_mode_dictionary_registry_2, TMP_BlendMode_blend_mode_dictionary_name_3;

        
        
        Opal.defn(self, '$blend_mode', TMP_BlendMode_blend_mode_1 = function $$blend_mode(blend_mode) {
          var self = this, $iter = TMP_BlendMode_blend_mode_1.$$p, $yield = $iter || nil;

          if (blend_mode == null) {
            blend_mode = "Normal";
          }
          if ($iter) TMP_BlendMode_blend_mode_1.$$p = null;
          
          self.$renderer().$min_version(1.4);
          if (($yield !== nil)) {
            self.$save_graphics_state()};
          self.$renderer().$add_content("" + "/" + (self.$blend_mode_dictionary_name(blend_mode)) + " gs");
          if (($yield !== nil)) {
            
            Opal.yieldX($yield, []);
            return self.$restore_graphics_state();
            } else {
            return nil
          };
        }, TMP_BlendMode_blend_mode_1.$$arity = -1);
        self.$private();
        
        Opal.defn(self, '$blend_mode_dictionary_registry', TMP_BlendMode_blend_mode_dictionary_registry_2 = function $$blend_mode_dictionary_registry() {
          var $a, self = this;
          if (self.blend_mode_dictionary_registry == null) self.blend_mode_dictionary_registry = nil;

          return (self.blend_mode_dictionary_registry = ($truthy($a = self.blend_mode_dictionary_registry) ? $a : $hash2([], {})))
        }, TMP_BlendMode_blend_mode_dictionary_registry_2.$$arity = 0);
        
        Opal.defn(self, '$blend_mode_dictionary_name', TMP_BlendMode_blend_mode_dictionary_name_3 = function $$blend_mode_dictionary_name(blend_mode) {
          var $a, self = this, key = nil, dictionary_name = nil, dictionary = nil, $logical_op_recvr_tmp_8 = nil, $writer = nil;

          
          key = self.$Array(blend_mode).$join("");
          dictionary_name = "" + "BM" + (key);
          dictionary = (($logical_op_recvr_tmp_8 = self.$blend_mode_dictionary_registry()), ($truthy($a = $logical_op_recvr_tmp_8['$[]'](dictionary_name)) ? $a : (($writer = [dictionary_name, self['$ref!']($hash2(["Type", "BM"], {"Type": "ExtGState", "BM": blend_mode}))]), $send($logical_op_recvr_tmp_8, '[]=', Opal.to_a($writer)), $writer[$rb_minus($writer["length"], 1)])));
          self.$page().$ext_gstates()['$merge!']($hash(dictionary_name, dictionary));
          return dictionary_name;
        }, TMP_BlendMode_blend_mode_dictionary_name_3.$$arity = 1);
      })($nesting[0], $nesting)
    })($nesting[0], $nesting)
  })($nesting[0], $nesting)
};

/* Generated by Opal 0.11.0 */
Opal.modules["prawn/graphics/color"] = function(Opal) {
  function $rb_minus(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs - rhs : lhs['$-'](rhs);
  }
  function $rb_divide(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs / rhs : lhs['$/'](rhs);
  }
  var self = Opal.top, $nesting = [], nil = Opal.nil, $breaker = Opal.breaker, $slice = Opal.slice, $module = Opal.module, $truthy = Opal.truthy, $send = Opal.send, $range = Opal.range, $hash2 = Opal.hash2;

  Opal.add_stubs(['$empty?', '$current_fill_color', '$process_color', '$current_fill_color=', '$-', '$set_fill_color', '$alias_method', '$current_stroke_color', '$current_stroke_color=', '$set_stroke_color', '$module_function', '$join', '$map', '$%', '$[]', '$to_i', '$private', '$size', '$===', '$fail', '$length', '$inspect', '$color_type', '$hex2rgb', '$/', '$normalize_color', '$==', '$current_color_space', '$!', '$in_stamp_stream?', '$page', '$state', '$set_current_color_space', '$include?', '$add_content', '$renderer', '$set_color_space', '$color_space', '$color_to_s', '$write_color', '$set_color', '$graphic_state', '$nil?', '$save_graphics_state', '$[]=', '$fill_color', '$fill_color=', '$stroke_color', '$stroke_color=']);
  return (function($base, $parent_nesting) {
    var $Prawn, self = $Prawn = $module($base, 'Prawn');

    var def = self.$$proto, $nesting = [self].concat($parent_nesting);

    (function($base, $parent_nesting) {
      var $Graphics, self = $Graphics = $module($base, 'Graphics');

      var def = self.$$proto, $nesting = [self].concat($parent_nesting);

      (function($base, $parent_nesting) {
        var $Color, self = $Color = $module($base, 'Color');

        var def = self.$$proto, $nesting = [self].concat($parent_nesting), TMP_Color_fill_color_1, TMP_Color_stroke_color_2, TMP_Color_rgb2hex_4, TMP_Color_hex2rgb_6, TMP_Color_process_color_7, TMP_Color_color_type_8, TMP_Color_normalize_color_9, TMP_Color_color_to_s_11, TMP_Color_color_space_12, TMP_Color_set_color_space_13, TMP_Color_set_color_14, TMP_Color_set_fill_color_15, TMP_Color_set_stroke_color_16, TMP_Color_update_colors_17, TMP_Color_current_color_space_18, TMP_Color_set_current_color_space_19, TMP_Color_current_fill_color_20, TMP_Color_current_fill_color$eq_21, TMP_Color_current_stroke_color_22, TMP_Color_current_stroke_color$eq_23, TMP_Color_write_fill_color_24, TMP_Color_write_stroke_color_25, TMP_Color_write_color_26;

        
        
        Opal.defn(self, '$fill_color', TMP_Color_fill_color_1 = function $$fill_color($a_rest) {
          var self = this, color, $writer = nil;

          var $args_len = arguments.length, $rest_len = $args_len - 0;
          if ($rest_len < 0) { $rest_len = 0; }
          color = new Array($rest_len);
          for (var $arg_idx = 0; $arg_idx < $args_len; $arg_idx++) {
            color[$arg_idx - 0] = arguments[$arg_idx];
          }
          
          if ($truthy(color['$empty?']())) {
            return self.$current_fill_color()};
          
          $writer = [$send(self, 'process_color', Opal.to_a(color))];
          $send(self, 'current_fill_color=', Opal.to_a($writer));
          $writer[$rb_minus($writer["length"], 1)];;
          return self.$set_fill_color();
        }, TMP_Color_fill_color_1.$$arity = -1);
        self.$alias_method("fill_color=", "fill_color");
        
        Opal.defn(self, '$stroke_color', TMP_Color_stroke_color_2 = function $$stroke_color($a_rest) {
          var self = this, color, $writer = nil;

          var $args_len = arguments.length, $rest_len = $args_len - 0;
          if ($rest_len < 0) { $rest_len = 0; }
          color = new Array($rest_len);
          for (var $arg_idx = 0; $arg_idx < $args_len; $arg_idx++) {
            color[$arg_idx - 0] = arguments[$arg_idx];
          }
          
          if ($truthy(color['$empty?']())) {
            return self.$current_stroke_color()};
          color = $send(self, 'process_color', Opal.to_a(color));
          
          $writer = [color];
          $send(self, 'current_stroke_color=', Opal.to_a($writer));
          $writer[$rb_minus($writer["length"], 1)];;
          return self.$set_stroke_color(color);
        }, TMP_Color_stroke_color_2.$$arity = -1);
        self.$alias_method("stroke_color=", "stroke_color");
        self.$module_function();
        
        Opal.defn(self, '$rgb2hex', TMP_Color_rgb2hex_4 = function $$rgb2hex(rgb) {
          var TMP_3, self = this;

          return $send(rgb, 'map', [], (TMP_3 = function(e){var self = TMP_3.$$s || this;
if (e == null) e = nil;
          return "%02x"['$%'](e)}, TMP_3.$$s = self, TMP_3.$$arity = 1, TMP_3)).$join()
        }, TMP_Color_rgb2hex_4.$$arity = 1);
        
        Opal.defn(self, '$hex2rgb', TMP_Color_hex2rgb_6 = function $$hex2rgb(hex) {
          var $a, TMP_5, self = this, r = nil, g = nil, b = nil;

          
          $a = [hex['$[]']($range(0, 1, false)), hex['$[]']($range(2, 3, false)), hex['$[]']($range(4, 5, false))], (r = $a[0]), (g = $a[1]), (b = $a[2]), $a;
          return $send([r, g, b], 'map', [], (TMP_5 = function(e){var self = TMP_5.$$s || this;
if (e == null) e = nil;
          return e.$to_i(16)}, TMP_5.$$s = self, TMP_5.$$arity = 1, TMP_5));
        }, TMP_Color_hex2rgb_6.$$arity = 1);
        self.$private();
        
        Opal.defn(self, '$process_color', TMP_Color_process_color_7 = function $$process_color($a_rest) {
          var self = this, color, $case = nil;

          var $args_len = arguments.length, $rest_len = $args_len - 0;
          if ($rest_len < 0) { $rest_len = 0; }
          color = new Array($rest_len);
          for (var $arg_idx = 0; $arg_idx < $args_len; $arg_idx++) {
            color[$arg_idx - 0] = arguments[$arg_idx];
          }
          return (function() {$case = color.$size();
          if ((1)['$===']($case)) {return color['$[]'](0)}
          else if ((4)['$===']($case)) {return color}
          else {return self.$fail(Opal.const_get_relative($nesting, 'ArgumentError'), "wrong number of arguments supplied")}})()
        }, TMP_Color_process_color_7.$$arity = -1);
        
        Opal.defn(self, '$color_type', TMP_Color_color_type_8 = function $$color_type(color) {
          var self = this, $case = nil;

          return (function() {$case = color;
          if (Opal.const_get_relative($nesting, 'String')['$===']($case)) {return "RGB"}
          else if (Opal.const_get_relative($nesting, 'Array')['$===']($case)) {return (function() {$case = color.$length();
          if ((3)['$===']($case)) {return "RGB"}
          else if ((4)['$===']($case)) {return "CMYK"}
          else {return self.$fail(Opal.const_get_relative($nesting, 'ArgumentError'), "" + "Unknown type of color: " + (color.$inspect()))}})()}
          else { return nil }})()
        }, TMP_Color_color_type_8.$$arity = 1);
        
        Opal.defn(self, '$normalize_color', TMP_Color_normalize_color_9 = function $$normalize_color(color) {
          var $a, $b, self = this, $case = nil, r = nil, g = nil, b = nil, c = nil, m = nil, y = nil, k = nil;

          return (function() {$case = self.$color_type(color);
          if ("RGB"['$===']($case)) {
          $b = self.$hex2rgb(color), $a = Opal.to_ary($b), (r = ($a[0] == null ? nil : $a[0])), (g = ($a[1] == null ? nil : $a[1])), (b = ($a[2] == null ? nil : $a[2])), $b;
          return [$rb_divide(r, 255.0), $rb_divide(g, 255.0), $rb_divide(b, 255.0)];}
          else if ("CMYK"['$===']($case)) {
          $a = [].concat(Opal.to_a(color)), (c = ($a[0] == null ? nil : $a[0])), (m = ($a[1] == null ? nil : $a[1])), (y = ($a[2] == null ? nil : $a[2])), (k = ($a[3] == null ? nil : $a[3])), $a;
          return [$rb_divide(c, 100.0), $rb_divide(m, 100.0), $rb_divide(y, 100.0), $rb_divide(k, 100.0)];}
          else { return nil }})()
        }, TMP_Color_normalize_color_9.$$arity = 1);
        
        Opal.defn(self, '$color_to_s', TMP_Color_color_to_s_11 = function $$color_to_s(color) {
          var TMP_10, self = this;

          return $send(self.$normalize_color(color), 'map', [], (TMP_10 = function(c){var self = TMP_10.$$s || this;
if (c == null) c = nil;
          return "%.3f"['$%'](c)}, TMP_10.$$s = self, TMP_10.$$arity = 1, TMP_10)).$join(" ")
        }, TMP_Color_color_to_s_11.$$arity = 1);
        
        Opal.defn(self, '$color_space', TMP_Color_color_space_12 = function $$color_space(color) {
          var self = this, $case = nil;

          return (function() {$case = self.$color_type(color);
          if ("RGB"['$===']($case)) {return "DeviceRGB"}
          else if ("CMYK"['$===']($case)) {return "DeviceCMYK"}
          else { return nil }})()
        }, TMP_Color_color_space_12.$$arity = 1);
        Opal.const_set($nesting[0], 'COLOR_SPACES', ["DeviceRGB", "DeviceCMYK", "Pattern"]);
        
        Opal.defn(self, '$set_color_space', TMP_Color_set_color_space_13 = function $$set_color_space(type, color_space) {
          var $a, self = this, operator = nil, $case = nil;

          
          if ($truthy((($a = self.$current_color_space(type)['$=='](color_space)) ? self.$state().$page()['$in_stamp_stream?']()['$!']() : self.$current_color_space(type)['$=='](color_space)))) {
            return nil};
          self.$set_current_color_space(color_space, type);
          if ($truthy(Opal.const_get_relative($nesting, 'COLOR_SPACES')['$include?'](color_space))) {
            } else {
            self.$fail(Opal.const_get_relative($nesting, 'ArgumentError'), "" + "unknown color space: '" + (color_space) + "'")
          };
          operator = (function() {$case = type;
          if ("fill"['$===']($case)) {return "cs"}
          else if ("stroke"['$===']($case)) {return "CS"}
          else {return self.$fail(Opal.const_get_relative($nesting, 'ArgumentError'), "" + "unknown type '" + (type) + "'")}})();
          return self.$renderer().$add_content("" + "/" + (color_space) + " " + (operator));
        }, TMP_Color_set_color_space_13.$$arity = 2);
        
        Opal.defn(self, '$set_color', TMP_Color_set_color_14 = function $$set_color(type, color, options) {
          var self = this, operator = nil, $case = nil;

          if (options == null) {
            options = $hash2([], {});
          }
          
          operator = (function() {$case = type;
          if ("fill"['$===']($case)) {return "scn"}
          else if ("stroke"['$===']($case)) {return "SCN"}
          else {return self.$fail(Opal.const_get_relative($nesting, 'ArgumentError'), "" + "unknown type '" + (type) + "'")}})();
          if ($truthy(options['$[]']("pattern"))) {
            
            self.$set_color_space(type, "Pattern");
            return self.$renderer().$add_content("" + "/" + (color) + " " + (operator));
            } else {
            
            self.$set_color_space(type, self.$color_space(color));
            color = self.$color_to_s(color);
            return self.$write_color(color, operator);
          };
        }, TMP_Color_set_color_14.$$arity = -3);
        
        Opal.defn(self, '$set_fill_color', TMP_Color_set_fill_color_15 = function $$set_fill_color(color) {
          var $a, self = this;

          if (color == null) {
            color = nil;
          }
          return self.$set_color("fill", ($truthy($a = color) ? $a : self.$current_fill_color()))
        }, TMP_Color_set_fill_color_15.$$arity = -1);
        
        Opal.defn(self, '$set_stroke_color', TMP_Color_set_stroke_color_16 = function $$set_stroke_color(color) {
          var $a, self = this;

          if (color == null) {
            color = nil;
          }
          return self.$set_color("stroke", ($truthy($a = color) ? $a : self.$current_stroke_color()))
        }, TMP_Color_set_stroke_color_16.$$arity = -1);
        
        Opal.defn(self, '$update_colors', TMP_Color_update_colors_17 = function $$update_colors() {
          var self = this;

          
          self.$set_fill_color();
          return self.$set_stroke_color();
        }, TMP_Color_update_colors_17.$$arity = 0);
        self.$private();
        
        Opal.defn(self, '$current_color_space', TMP_Color_current_color_space_18 = function $$current_color_space(type) {
          var self = this;

          return self.$graphic_state().$color_space()['$[]'](type)
        }, TMP_Color_current_color_space_18.$$arity = 1);
        
        Opal.defn(self, '$set_current_color_space', TMP_Color_set_current_color_space_19 = function $$set_current_color_space(color_space, type) {
          var self = this, $writer = nil;

          
          if ($truthy(self.$graphic_state()['$nil?']())) {
            self.$save_graphics_state()};
          
          $writer = [type, color_space];
          $send(self.$graphic_state().$color_space(), '[]=', Opal.to_a($writer));
          return $writer[$rb_minus($writer["length"], 1)];;
        }, TMP_Color_set_current_color_space_19.$$arity = 2);
        
        Opal.defn(self, '$current_fill_color', TMP_Color_current_fill_color_20 = function $$current_fill_color() {
          var self = this;

          return self.$graphic_state().$fill_color()
        }, TMP_Color_current_fill_color_20.$$arity = 0);
        
        Opal.defn(self, '$current_fill_color=', TMP_Color_current_fill_color$eq_21 = function(color) {
          var self = this, $writer = nil;

          
          $writer = [color];
          $send(self.$graphic_state(), 'fill_color=', Opal.to_a($writer));
          return $writer[$rb_minus($writer["length"], 1)];
        }, TMP_Color_current_fill_color$eq_21.$$arity = 1);
        
        Opal.defn(self, '$current_stroke_color', TMP_Color_current_stroke_color_22 = function $$current_stroke_color() {
          var self = this;

          return self.$graphic_state().$stroke_color()
        }, TMP_Color_current_stroke_color_22.$$arity = 0);
        
        Opal.defn(self, '$current_stroke_color=', TMP_Color_current_stroke_color$eq_23 = function(color) {
          var self = this, $writer = nil;

          
          $writer = [color];
          $send(self.$graphic_state(), 'stroke_color=', Opal.to_a($writer));
          return $writer[$rb_minus($writer["length"], 1)];
        }, TMP_Color_current_stroke_color$eq_23.$$arity = 1);
        
        Opal.defn(self, '$write_fill_color', TMP_Color_write_fill_color_24 = function $$write_fill_color() {
          var self = this;

          return self.$write_color(self.$current_fill_color(), "scn")
        }, TMP_Color_write_fill_color_24.$$arity = 0);
        
        Opal.defn(self, '$write_stroke_color', TMP_Color_write_stroke_color_25 = function $$write_stroke_color() {
          var self = this;

          return self.$write_color(self.$current_fill_color(), "SCN")
        }, TMP_Color_write_stroke_color_25.$$arity = 0);
        
        Opal.defn(self, '$write_color', TMP_Color_write_color_26 = function $$write_color(color, operator) {
          var self = this;

          return self.$renderer().$add_content("" + (color) + " " + (operator))
        }, TMP_Color_write_color_26.$$arity = 2);
      })($nesting[0], $nesting)
    })($nesting[0], $nesting)
  })($nesting[0], $nesting)
};

/* Generated by Opal 0.11.0 */
Opal.modules["prawn/graphics/dash"] = function(Opal) {
  function $rb_minus(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs - rhs : lhs['$-'](rhs);
  }
  var self = Opal.top, $nesting = [], nil = Opal.nil, $breaker = Opal.breaker, $slice = Opal.slice, $module = Opal.module, $truthy = Opal.truthy, $send = Opal.send, $hash2 = Opal.hash2;

  Opal.add_stubs(['$nil?', '$current_dash_state', '$==', '$kind_of?', '$any?', '$fail', '$[]', '$current_dash_state=', '$-', '$write_stroke_dash', '$alias_method', '$undashed_setting', '$!=', '$private', '$add_content', '$renderer', '$dash_setting', '$dash=', '$graphic_state', '$dash']);
  return (function($base, $parent_nesting) {
    var $Prawn, self = $Prawn = $module($base, 'Prawn');

    var def = self.$$proto, $nesting = [self].concat($parent_nesting);

    (function($base, $parent_nesting) {
      var $Graphics, self = $Graphics = $module($base, 'Graphics');

      var def = self.$$proto, $nesting = [self].concat($parent_nesting);

      (function($base, $parent_nesting) {
        var $Dash, self = $Dash = $module($base, 'Dash');

        var def = self.$$proto, $nesting = [self].concat($parent_nesting), TMP_Dash_dash_2, TMP_Dash_undash_3, TMP_Dash_dashed$q_4, TMP_Dash_write_stroke_dash_5, TMP_Dash_undashed_setting_6, TMP_Dash_current_dash_state$eq_7, TMP_Dash_current_dash_state_8, TMP_Dash_dash_setting_9;

        
        
        Opal.defn(self, '$dash', TMP_Dash_dash_2 = function $$dash(length, options) {
          var $a, $b, TMP_1, self = this, $writer = nil;

          if (length == null) {
            length = nil;
          }
          if (options == null) {
            options = $hash2([], {});
          }
          
          if ($truthy(length['$nil?']())) {
            return self.$current_dash_state()};
          if ($truthy(($truthy($a = length['$=='](0)) ? $a : ($truthy($b = length['$kind_of?'](Opal.const_get_relative($nesting, 'Array'))) ? $send(length, 'any?', [], (TMP_1 = function(e){var self = TMP_1.$$s || this;
if (e == null) e = nil;
          return e['$=='](0)}, TMP_1.$$s = self, TMP_1.$$arity = 1, TMP_1)) : $b)))) {
            self.$fail(Opal.const_get_relative($nesting, 'ArgumentError'), "Zero length dashes are invalid. Call #undash to disable dashes.")};
          
          $writer = [$hash2(["dash", "space", "phase"], {"dash": length, "space": (function() {if ($truthy(length['$kind_of?'](Opal.const_get_relative($nesting, 'Array')))) {
            return nil
            } else {
            return ($truthy($a = options['$[]']("space")) ? $a : length)
          }; return nil; })(), "phase": ($truthy($a = options['$[]']("phase")) ? $a : 0)})];
          $send(self, 'current_dash_state=', Opal.to_a($writer));
          $writer[$rb_minus($writer["length"], 1)];;
          return self.$write_stroke_dash();
        }, TMP_Dash_dash_2.$$arity = -1);
        self.$alias_method("dash=", "dash");
        
        Opal.defn(self, '$undash', TMP_Dash_undash_3 = function $$undash() {
          var self = this, $writer = nil;

          
          
          $writer = [self.$undashed_setting()];
          $send(self, 'current_dash_state=', Opal.to_a($writer));
          $writer[$rb_minus($writer["length"], 1)];;
          return self.$write_stroke_dash();
        }, TMP_Dash_undash_3.$$arity = 0);
        
        Opal.defn(self, '$dashed?', TMP_Dash_dashed$q_4 = function() {
          var self = this;

          return self.$current_dash_state()['$!='](self.$undashed_setting())
        }, TMP_Dash_dashed$q_4.$$arity = 0);
        self.$private();
        
        Opal.defn(self, '$write_stroke_dash', TMP_Dash_write_stroke_dash_5 = function $$write_stroke_dash() {
          var self = this;

          return self.$renderer().$add_content(self.$dash_setting())
        }, TMP_Dash_write_stroke_dash_5.$$arity = 0);
        
        Opal.defn(self, '$undashed_setting', TMP_Dash_undashed_setting_6 = function $$undashed_setting() {
          var self = this;

          return $hash2(["dash", "space", "phase"], {"dash": nil, "space": nil, "phase": 0})
        }, TMP_Dash_undashed_setting_6.$$arity = 0);
        
        Opal.defn(self, '$current_dash_state=', TMP_Dash_current_dash_state$eq_7 = function(dash_options) {
          var self = this, $writer = nil;

          
          $writer = [dash_options];
          $send(self.$graphic_state(), 'dash=', Opal.to_a($writer));
          return $writer[$rb_minus($writer["length"], 1)];
        }, TMP_Dash_current_dash_state$eq_7.$$arity = 1);
        
        Opal.defn(self, '$current_dash_state', TMP_Dash_current_dash_state_8 = function $$current_dash_state() {
          var self = this;

          return self.$graphic_state().$dash()
        }, TMP_Dash_current_dash_state_8.$$arity = 0);
        
        Opal.defn(self, '$dash_setting', TMP_Dash_dash_setting_9 = function $$dash_setting() {
          var self = this;

          return self.$graphic_state().$dash_setting()
        }, TMP_Dash_dash_setting_9.$$arity = 0);
      })($nesting[0], $nesting)
    })($nesting[0], $nesting)
  })($nesting[0], $nesting)
};

/* Generated by Opal 0.11.0 */
Opal.modules["prawn/graphics/cap_style"] = function(Opal) {
  function $rb_minus(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs - rhs : lhs['$-'](rhs);
  }
  var self = Opal.top, $nesting = [], nil = Opal.nil, $breaker = Opal.breaker, $slice = Opal.slice, $module = Opal.module, $hash2 = Opal.hash2, $truthy = Opal.truthy, $send = Opal.send;

  Opal.add_stubs(['$nil?', '$current_cap_style', '$current_cap_style=', '$-', '$write_stroke_cap_style', '$alias_method', '$private', '$cap_style', '$graphic_state', '$cap_style=', '$add_content', '$renderer', '$[]']);
  return (function($base, $parent_nesting) {
    var $Prawn, self = $Prawn = $module($base, 'Prawn');

    var def = self.$$proto, $nesting = [self].concat($parent_nesting);

    (function($base, $parent_nesting) {
      var $Graphics, self = $Graphics = $module($base, 'Graphics');

      var def = self.$$proto, $nesting = [self].concat($parent_nesting);

      (function($base, $parent_nesting) {
        var $CapStyle, self = $CapStyle = $module($base, 'CapStyle');

        var def = self.$$proto, $nesting = [self].concat($parent_nesting), TMP_CapStyle_cap_style_1, TMP_CapStyle_current_cap_style_2, TMP_CapStyle_current_cap_style$eq_3, TMP_CapStyle_write_stroke_cap_style_4;

        
        Opal.const_set($nesting[0], 'CAP_STYLES', $hash2(["butt", "round", "projecting_square"], {"butt": 0, "round": 1, "projecting_square": 2}));
        
        Opal.defn(self, '$cap_style', TMP_CapStyle_cap_style_1 = function $$cap_style(style) {
          var $a, self = this, $writer = nil;

          if (style == null) {
            style = nil;
          }
          
          if ($truthy(style['$nil?']())) {
            return ($truthy($a = self.$current_cap_style()) ? $a : "butt")};
          
          $writer = [style];
          $send(self, 'current_cap_style=', Opal.to_a($writer));
          $writer[$rb_minus($writer["length"], 1)];;
          return self.$write_stroke_cap_style();
        }, TMP_CapStyle_cap_style_1.$$arity = -1);
        self.$alias_method("cap_style=", "cap_style");
        self.$private();
        
        Opal.defn(self, '$current_cap_style', TMP_CapStyle_current_cap_style_2 = function $$current_cap_style() {
          var self = this;

          return self.$graphic_state().$cap_style()
        }, TMP_CapStyle_current_cap_style_2.$$arity = 0);
        
        Opal.defn(self, '$current_cap_style=', TMP_CapStyle_current_cap_style$eq_3 = function(style) {
          var self = this, $writer = nil;

          
          $writer = [style];
          $send(self.$graphic_state(), 'cap_style=', Opal.to_a($writer));
          return $writer[$rb_minus($writer["length"], 1)];
        }, TMP_CapStyle_current_cap_style$eq_3.$$arity = 1);
        
        Opal.defn(self, '$write_stroke_cap_style', TMP_CapStyle_write_stroke_cap_style_4 = function $$write_stroke_cap_style() {
          var self = this;

          return self.$renderer().$add_content("" + (Opal.const_get_relative($nesting, 'CAP_STYLES')['$[]'](self.$current_cap_style())) + " J")
        }, TMP_CapStyle_write_stroke_cap_style_4.$$arity = 0);
      })($nesting[0], $nesting)
    })($nesting[0], $nesting)
  })($nesting[0], $nesting)
};

/* Generated by Opal 0.11.0 */
Opal.modules["prawn/graphics/join_style"] = function(Opal) {
  function $rb_minus(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs - rhs : lhs['$-'](rhs);
  }
  var self = Opal.top, $nesting = [], nil = Opal.nil, $breaker = Opal.breaker, $slice = Opal.slice, $module = Opal.module, $hash2 = Opal.hash2, $truthy = Opal.truthy, $send = Opal.send;

  Opal.add_stubs(['$nil?', '$current_join_style', '$current_join_style=', '$-', '$write_stroke_join_style', '$alias_method', '$private', '$join_style', '$graphic_state', '$join_style=', '$add_content', '$renderer', '$[]']);
  return (function($base, $parent_nesting) {
    var $Prawn, self = $Prawn = $module($base, 'Prawn');

    var def = self.$$proto, $nesting = [self].concat($parent_nesting);

    (function($base, $parent_nesting) {
      var $Graphics, self = $Graphics = $module($base, 'Graphics');

      var def = self.$$proto, $nesting = [self].concat($parent_nesting);

      (function($base, $parent_nesting) {
        var $JoinStyle, self = $JoinStyle = $module($base, 'JoinStyle');

        var def = self.$$proto, $nesting = [self].concat($parent_nesting), TMP_JoinStyle_join_style_1, TMP_JoinStyle_current_join_style_2, TMP_JoinStyle_current_join_style$eq_3, TMP_JoinStyle_write_stroke_join_style_4;

        
        Opal.const_set($nesting[0], 'JOIN_STYLES', $hash2(["miter", "round", "bevel"], {"miter": 0, "round": 1, "bevel": 2}));
        
        Opal.defn(self, '$join_style', TMP_JoinStyle_join_style_1 = function $$join_style(style) {
          var $a, self = this, $writer = nil;

          if (style == null) {
            style = nil;
          }
          
          if ($truthy(style['$nil?']())) {
            return ($truthy($a = self.$current_join_style()) ? $a : "miter")};
          
          $writer = [style];
          $send(self, 'current_join_style=', Opal.to_a($writer));
          $writer[$rb_minus($writer["length"], 1)];;
          return self.$write_stroke_join_style();
        }, TMP_JoinStyle_join_style_1.$$arity = -1);
        self.$alias_method("join_style=", "join_style");
        self.$private();
        
        Opal.defn(self, '$current_join_style', TMP_JoinStyle_current_join_style_2 = function $$current_join_style() {
          var self = this;

          return self.$graphic_state().$join_style()
        }, TMP_JoinStyle_current_join_style_2.$$arity = 0);
        
        Opal.defn(self, '$current_join_style=', TMP_JoinStyle_current_join_style$eq_3 = function(style) {
          var self = this, $writer = nil;

          
          $writer = [style];
          $send(self.$graphic_state(), 'join_style=', Opal.to_a($writer));
          return $writer[$rb_minus($writer["length"], 1)];
        }, TMP_JoinStyle_current_join_style$eq_3.$$arity = 1);
        
        Opal.defn(self, '$write_stroke_join_style', TMP_JoinStyle_write_stroke_join_style_4 = function $$write_stroke_join_style() {
          var self = this;

          return self.$renderer().$add_content("" + (Opal.const_get_relative($nesting, 'JOIN_STYLES')['$[]'](self.$current_join_style())) + " j")
        }, TMP_JoinStyle_write_stroke_join_style_4.$$arity = 0);
      })($nesting[0], $nesting)
    })($nesting[0], $nesting)
  })($nesting[0], $nesting)
};

/* Generated by Opal 0.11.0 */
Opal.modules["prawn/graphics/transparency"] = function(Opal) {
  function $rb_plus(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs + rhs : lhs['$+'](rhs);
  }
  function $rb_minus(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs - rhs : lhs['$-'](rhs);
  }
  var self = Opal.top, $nesting = [], nil = Opal.nil, $breaker = Opal.breaker, $slice = Opal.slice, $module = Opal.module, $truthy = Opal.truthy, $hash2 = Opal.hash2, $send = Opal.send, $hash = Opal.hash;

  Opal.add_stubs(['$min_version', '$renderer', '$min', '$max', '$save_graphics_state', '$add_content', '$opacity_dictionary_name', '$restore_graphics_state', '$private', '$+', '$length', '$opacity_dictionary_registry', '$[]', '$ref!', '$next_opacity_dictionary_id', '$[]=', '$-', '$merge!', '$ext_gstates', '$page']);
  return (function($base, $parent_nesting) {
    var $Prawn, self = $Prawn = $module($base, 'Prawn');

    var def = self.$$proto, $nesting = [self].concat($parent_nesting);

    (function($base, $parent_nesting) {
      var $Graphics, self = $Graphics = $module($base, 'Graphics');

      var def = self.$$proto, $nesting = [self].concat($parent_nesting);

      (function($base, $parent_nesting) {
        var $Transparency, self = $Transparency = $module($base, 'Transparency');

        var def = self.$$proto, $nesting = [self].concat($parent_nesting), TMP_Transparency_transparent_1, TMP_Transparency_opacity_dictionary_registry_2, TMP_Transparency_next_opacity_dictionary_id_3, TMP_Transparency_opacity_dictionary_name_4;

        
        
        Opal.defn(self, '$transparent', TMP_Transparency_transparent_1 = function $$transparent(opacity, stroke_opacity) {
          var self = this, $iter = TMP_Transparency_transparent_1.$$p, block = $iter || nil;

          if (stroke_opacity == null) {
            stroke_opacity = opacity;
          }
          if ($iter) TMP_Transparency_transparent_1.$$p = null;
          
          self.$renderer().$min_version(1.4);
          opacity = [[opacity, 0.0].$max(), 1.0].$min();
          stroke_opacity = [[stroke_opacity, 0.0].$max(), 1.0].$min();
          self.$save_graphics_state();
          self.$renderer().$add_content("" + "/" + (self.$opacity_dictionary_name(opacity, stroke_opacity)) + " gs");
          Opal.yieldX(block, []);
          return self.$restore_graphics_state();
        }, TMP_Transparency_transparent_1.$$arity = -2);
        self.$private();
        
        Opal.defn(self, '$opacity_dictionary_registry', TMP_Transparency_opacity_dictionary_registry_2 = function $$opacity_dictionary_registry() {
          var $a, self = this;
          if (self.opacity_dictionary_registry == null) self.opacity_dictionary_registry = nil;

          return (self.opacity_dictionary_registry = ($truthy($a = self.opacity_dictionary_registry) ? $a : $hash2([], {})))
        }, TMP_Transparency_opacity_dictionary_registry_2.$$arity = 0);
        
        Opal.defn(self, '$next_opacity_dictionary_id', TMP_Transparency_next_opacity_dictionary_id_3 = function $$next_opacity_dictionary_id() {
          var self = this;

          return $rb_plus(self.$opacity_dictionary_registry().$length(), 1)
        }, TMP_Transparency_next_opacity_dictionary_id_3.$$arity = 0);
        
        Opal.defn(self, '$opacity_dictionary_name', TMP_Transparency_opacity_dictionary_name_4 = function $$opacity_dictionary_name(opacity, stroke_opacity) {
          var self = this, key = nil, dictionary = nil, dictionary_name = nil, $writer = nil;

          
          key = "" + (opacity) + "_" + (stroke_opacity);
          if ($truthy(self.$opacity_dictionary_registry()['$[]'](key))) {
            
            dictionary = self.$opacity_dictionary_registry()['$[]'](key)['$[]']("obj");
            dictionary_name = self.$opacity_dictionary_registry()['$[]'](key)['$[]']("name");
            } else {
            
            dictionary = self['$ref!']($hash2(["Type", "CA", "ca"], {"Type": "ExtGState", "CA": stroke_opacity, "ca": opacity}));
            dictionary_name = "" + "Tr" + (self.$next_opacity_dictionary_id());
            
            $writer = [key, $hash2(["name", "obj"], {"name": dictionary_name, "obj": dictionary})];
            $send(self.$opacity_dictionary_registry(), '[]=', Opal.to_a($writer));
            $writer[$rb_minus($writer["length"], 1)];;
          };
          self.$page().$ext_gstates()['$merge!']($hash(dictionary_name, dictionary));
          return dictionary_name;
        }, TMP_Transparency_opacity_dictionary_name_4.$$arity = 2);
      })($nesting[0], $nesting)
    })($nesting[0], $nesting)
  })($nesting[0], $nesting)
};

/* Generated by Opal 0.11.0 */
Opal.modules["prawn/graphics/transformation"] = function(Opal) {
  function $rb_plus(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs + rhs : lhs['$+'](rhs);
  }
  function $rb_minus(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs - rhs : lhs['$-'](rhs);
  }
  function $rb_times(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs * rhs : lhs['$*'](rhs);
  }
  var self = Opal.top, $nesting = [], nil = Opal.nil, $breaker = Opal.breaker, $slice = Opal.slice, $module = Opal.module, $truthy = Opal.truthy, $send = Opal.send, $hash2 = Opal.hash2;

  Opal.add_stubs(['$verify_options', '$degree_to_rad', '$cos', '$sin', '$nil?', '$[]', '$transformation_matrix', '$-@', '$to_proc', '$fail', '$+', '$absolute_left', '$bounds', '$absolute_bottom', '$-', '$*', '$translate', '$join', '$map', '$%', '$save_graphics_state', '$add_to_transformation_stack', '$add_content', '$renderer', '$restore_graphics_state']);
  return (function($base, $parent_nesting) {
    var $Prawn, self = $Prawn = $module($base, 'Prawn');

    var def = self.$$proto, $nesting = [self].concat($parent_nesting);

    (function($base, $parent_nesting) {
      var $Graphics, self = $Graphics = $module($base, 'Graphics');

      var def = self.$$proto, $nesting = [self].concat($parent_nesting);

      (function($base, $parent_nesting) {
        var $Transformation, self = $Transformation = $module($base, 'Transformation');

        var def = self.$$proto, $nesting = [self].concat($parent_nesting), TMP_Transformation_rotate_1, TMP_Transformation_translate_3, TMP_Transformation_scale_4, TMP_Transformation_transformation_matrix_7;

        
        
        Opal.defn(self, '$rotate', TMP_Transformation_rotate_1 = function $$rotate(angle, options) {
          var TMP_2, self = this, $iter = TMP_Transformation_rotate_1.$$p, block = $iter || nil, rad = nil, cos = nil, sin = nil, x = nil, y = nil, x_prime = nil, y_prime = nil;

          if (options == null) {
            options = $hash2([], {});
          }
          if ($iter) TMP_Transformation_rotate_1.$$p = null;
          
          Opal.const_get_relative($nesting, 'Prawn').$verify_options("origin", options);
          rad = self.$degree_to_rad(angle);
          cos = Opal.const_get_relative($nesting, 'Math').$cos(rad);
          sin = Opal.const_get_relative($nesting, 'Math').$sin(rad);
          if ($truthy(options['$[]']("origin")['$nil?']())) {
            return $send(self, 'transformation_matrix', [cos, sin, sin['$-@'](), cos, 0, 0], block.$to_proc())
            } else {
            
            if ((block !== nil)) {
              } else {
              self.$fail(Opal.const_get_qualified(Opal.const_get_qualified(Opal.const_get_relative($nesting, 'Prawn'), 'Errors'), 'BlockRequired'))
            };
            x = $rb_plus(options['$[]']("origin")['$[]'](0), self.$bounds().$absolute_left());
            y = $rb_plus(options['$[]']("origin")['$[]'](1), self.$bounds().$absolute_bottom());
            x_prime = $rb_minus($rb_times(x, cos), $rb_times(y, sin));
            y_prime = $rb_plus($rb_times(x, sin), $rb_times(y, cos));
            return $send(self, 'translate', [$rb_minus(x, x_prime), $rb_minus(y, y_prime)], (TMP_2 = function(){var self = TMP_2.$$s || this;

            return $send(self, 'transformation_matrix', [cos, sin, sin['$-@'](), cos, 0, 0], block.$to_proc())}, TMP_2.$$s = self, TMP_2.$$arity = 0, TMP_2));
          };
        }, TMP_Transformation_rotate_1.$$arity = -2);
        
        Opal.defn(self, '$translate', TMP_Transformation_translate_3 = function $$translate(x, y) {
          var self = this, $iter = TMP_Transformation_translate_3.$$p, block = $iter || nil;

          if ($iter) TMP_Transformation_translate_3.$$p = null;
          return $send(self, 'transformation_matrix', [1, 0, 0, 1, x, y], block.$to_proc())
        }, TMP_Transformation_translate_3.$$arity = 2);
        
        Opal.defn(self, '$scale', TMP_Transformation_scale_4 = function $$scale(factor, options) {
          var TMP_5, self = this, $iter = TMP_Transformation_scale_4.$$p, block = $iter || nil, x = nil, y = nil, x_prime = nil, y_prime = nil;

          if (options == null) {
            options = $hash2([], {});
          }
          if ($iter) TMP_Transformation_scale_4.$$p = null;
          
          Opal.const_get_relative($nesting, 'Prawn').$verify_options("origin", options);
          if ($truthy(options['$[]']("origin")['$nil?']())) {
            return $send(self, 'transformation_matrix', [factor, 0, 0, factor, 0, 0], block.$to_proc())
            } else {
            
            if ((block !== nil)) {
              } else {
              self.$fail(Opal.const_get_qualified(Opal.const_get_qualified(Opal.const_get_relative($nesting, 'Prawn'), 'Errors'), 'BlockRequired'))
            };
            x = $rb_plus(options['$[]']("origin")['$[]'](0), self.$bounds().$absolute_left());
            y = $rb_plus(options['$[]']("origin")['$[]'](1), self.$bounds().$absolute_bottom());
            x_prime = $rb_times(factor, x);
            y_prime = $rb_times(factor, y);
            return $send(self, 'translate', [$rb_minus(x, x_prime), $rb_minus(y, y_prime)], (TMP_5 = function(){var self = TMP_5.$$s || this;

            return $send(self, 'transformation_matrix', [factor, 0, 0, factor, 0, 0], block.$to_proc())}, TMP_5.$$s = self, TMP_5.$$arity = 0, TMP_5));
          };
        }, TMP_Transformation_scale_4.$$arity = -2);
        
        Opal.defn(self, '$transformation_matrix', TMP_Transformation_transformation_matrix_7 = function $$transformation_matrix(a, b, c, d, e, f) {
          var TMP_6, self = this, $iter = TMP_Transformation_transformation_matrix_7.$$p, $yield = $iter || nil, values = nil;

          if ($iter) TMP_Transformation_transformation_matrix_7.$$p = null;
          
          values = $send([a, b, c, d, e, f], 'map', [], (TMP_6 = function(x){var self = TMP_6.$$s || this;
if (x == null) x = nil;
          return "%.5f"['$%'](x)}, TMP_6.$$s = self, TMP_6.$$arity = 1, TMP_6)).$join(" ");
          if (($yield !== nil)) {
            self.$save_graphics_state()};
          self.$add_to_transformation_stack(a, b, c, d, e, f);
          self.$renderer().$add_content("" + (values) + " cm");
          if (($yield !== nil)) {
            
            Opal.yieldX($yield, []);
            return self.$restore_graphics_state();
            } else {
            return nil
          };
        }, TMP_Transformation_transformation_matrix_7.$$arity = 6);
      })($nesting[0], $nesting)
    })($nesting[0], $nesting)
  })($nesting[0], $nesting)
};

/* Generated by Opal 0.11.0 */
Opal.modules["prawn/graphics/patterns"] = function(Opal) {
  function $rb_minus(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs - rhs : lhs['$-'](rhs);
  }
  var self = Opal.top, $nesting = [], nil = Opal.nil, $breaker = Opal.breaker, $slice = Opal.slice, $module = Opal.module, $send = Opal.send, $truthy = Opal.truthy, $hash2 = Opal.hash2;

  Opal.add_stubs(['$set_gradient', '$private', '$is_a?', '$last', '$pop', '$resources', '$page', '$[]', '$[]=', '$-', '$gradient_registry_key', '$gradient_registry', '$gradient', '$===', '$fail', '$set_color_space', '$add_content', '$renderer', '$gradient_coordinates', '$hash', '$!=', '$length', '$inspect', '$nil?', '$current_transformation_matrix_with_translation', '$warn', '$freeze', '$dup', '$normalize_color', '$color_type', '$process_color', '$ref!', '$==', '$color_space', '$map_to_absolute']);
  return (function($base, $parent_nesting) {
    var $Prawn, self = $Prawn = $module($base, 'Prawn');

    var def = self.$$proto, $nesting = [self].concat($parent_nesting);

    (function($base, $parent_nesting) {
      var $Graphics, self = $Graphics = $module($base, 'Graphics');

      var def = self.$$proto, $nesting = [self].concat($parent_nesting);

      (function($base, $parent_nesting) {
        var $Patterns, self = $Patterns = $module($base, 'Patterns');

        var def = self.$$proto, $nesting = [self].concat($parent_nesting), TMP_Patterns_fill_gradient_1, TMP_Patterns_stroke_gradient_2, TMP_Patterns_set_gradient_3, TMP_Patterns_gradient_registry_key_4, TMP_Patterns_gradient_registry_5, TMP_Patterns_gradient_6, TMP_Patterns_gradient_coordinates_7;

        
        
        Opal.defn(self, '$fill_gradient', TMP_Patterns_fill_gradient_1 = function $$fill_gradient($a_rest) {
          var self = this, args;

          var $args_len = arguments.length, $rest_len = $args_len - 0;
          if ($rest_len < 0) { $rest_len = 0; }
          args = new Array($rest_len);
          for (var $arg_idx = 0; $arg_idx < $args_len; $arg_idx++) {
            args[$arg_idx - 0] = arguments[$arg_idx];
          }
          return $send(self, 'set_gradient', ["fill"].concat(Opal.to_a(args)))
        }, TMP_Patterns_fill_gradient_1.$$arity = -1);
        
        Opal.defn(self, '$stroke_gradient', TMP_Patterns_stroke_gradient_2 = function $$stroke_gradient($a_rest) {
          var self = this, args;

          var $args_len = arguments.length, $rest_len = $args_len - 0;
          if ($rest_len < 0) { $rest_len = 0; }
          args = new Array($rest_len);
          for (var $arg_idx = 0; $arg_idx < $args_len; $arg_idx++) {
            args[$arg_idx - 0] = arguments[$arg_idx];
          }
          return $send(self, 'set_gradient', ["stroke"].concat(Opal.to_a(args)))
        }, TMP_Patterns_stroke_gradient_2.$$arity = -1);
        self.$private();
        
        Opal.defn(self, '$set_gradient', TMP_Patterns_set_gradient_3 = function $$set_gradient(type, $a_rest) {
          var $b, self = this, grad, opts = nil, patterns = nil, $logical_op_recvr_tmp_9 = nil, $writer = nil, registry_key = nil, shading = nil, operator = nil, $case = nil;

          var $args_len = arguments.length, $rest_len = $args_len - 1;
          if ($rest_len < 0) { $rest_len = 0; }
          grad = new Array($rest_len);
          for (var $arg_idx = 1; $arg_idx < $args_len; $arg_idx++) {
            grad[$arg_idx - 1] = arguments[$arg_idx];
          }
          
          opts = (function() {if ($truthy(grad.$last()['$is_a?'](Opal.const_get_relative($nesting, 'Hash')))) {
            return grad.$pop()
            } else {
            return $hash2([], {})
          }; return nil; })();
          patterns = (($logical_op_recvr_tmp_9 = self.$page().$resources()), ($truthy($b = $logical_op_recvr_tmp_9['$[]']("Pattern")) ? $b : (($writer = ["Pattern", $hash2([], {})]), $send($logical_op_recvr_tmp_9, '[]=', Opal.to_a($writer)), $writer[$rb_minus($writer["length"], 1)])));
          registry_key = self.$gradient_registry_key(grad, opts);
          if ($truthy(patterns['$[]']("" + "SP" + (registry_key)))) {
            shading = patterns['$[]']("" + "SP" + (registry_key))
            } else {
            
            if ($truthy((shading = self.$gradient_registry()['$[]'](registry_key)))) {
              } else {
              
              shading = self.$gradient(grad, opts);
              
              $writer = [registry_key, shading];
              $send(self.$gradient_registry(), '[]=', Opal.to_a($writer));
              $writer[$rb_minus($writer["length"], 1)];;
            };
            
            $writer = ["" + "SP" + (registry_key), shading];
            $send(patterns, '[]=', Opal.to_a($writer));
            $writer[$rb_minus($writer["length"], 1)];;
          };
          operator = (function() {$case = type;
          if ("fill"['$===']($case)) {return "scn"}
          else if ("stroke"['$===']($case)) {return "SCN"}
          else {return self.$fail(Opal.const_get_relative($nesting, 'ArgumentError'), "" + "unknown type '" + (type) + "'")}})();
          self.$set_color_space(type, "Pattern");
          return self.$renderer().$add_content("" + "/SP" + (registry_key) + " " + (operator));
        }, TMP_Patterns_set_gradient_3.$$arity = -2);
        
        Opal.defn(self, '$gradient_registry_key', TMP_Patterns_gradient_registry_key_4 = function $$gradient_registry_key(gradient, opts) {
          var $a, $b, self = this, _x1 = nil, _y1 = nil, x2 = nil, y2 = nil, transformation = nil;

          
          $b = self.$gradient_coordinates(gradient, opts), $a = Opal.to_ary($b), (_x1 = ($a[0] == null ? nil : $a[0])), (_y1 = ($a[1] == null ? nil : $a[1])), (x2 = ($a[2] == null ? nil : $a[2])), (y2 = ($a[3] == null ? nil : $a[3])), (transformation = ($a[4] == null ? nil : $a[4])), $b;
          return (function() {if ($truthy(gradient['$[]'](1)['$is_a?'](Opal.const_get_relative($nesting, 'Array')))) {
            return [transformation, x2, y2, gradient['$[]'](2), gradient['$[]'](3)]
            } else {
            return [transformation, x2, y2, gradient['$[]'](1), gradient['$[]'](3), gradient['$[]'](4), gradient['$[]'](5)]
          }; return nil; })().$hash();
        }, TMP_Patterns_gradient_registry_key_4.$$arity = 2);
        
        Opal.defn(self, '$gradient_registry', TMP_Patterns_gradient_registry_5 = function $$gradient_registry() {
          var $a, self = this;
          if (self.gradient_registry == null) self.gradient_registry = nil;

          return (self.gradient_registry = ($truthy($a = self.gradient_registry) ? $a : $hash2([], {})))
        }, TMP_Patterns_gradient_registry_5.$$arity = 0);
        
        Opal.defn(self, '$gradient', TMP_Patterns_gradient_6 = function $$gradient(args, opts) {
          var $a, $b, self = this, color1 = nil, color2 = nil, shader = nil, x1 = nil, y1 = nil, x2 = nil, y2 = nil, transformation = nil, coords = nil, shading = nil;

          
          if ($truthy(($truthy($a = args.$length()['$!='](4)) ? args.$length()['$!='](6) : $a))) {
            self.$fail(Opal.const_get_relative($nesting, 'ArgumentError'), "" + "Unknown type of gradient: " + (args.$inspect()))};
          if ($truthy(($truthy($a = opts['$[]']("apply_transformations")['$nil?']()) ? self.$current_transformation_matrix_with_translation(0, 0)['$!=']([1, 0, 0, 1, 0, 0]) : $a))) {
            self.$warn("Gradients in Prawn 2.x and lower are not correctly positioned when a transformation has been made to the document.  Pass 'apply_transformations: true' to correctly transform the gradient, or see https://github.com/prawnpdf/prawn/wiki/Gradient-Transformations for more information.")};
          color1 = self.$normalize_color(args['$[]'](-2)).$dup().$freeze();
          color2 = self.$normalize_color(args['$[]'](-1)).$dup().$freeze();
          if ($truthy(self.$color_type(color1)['$!='](self.$color_type(color2)))) {
            self.$fail(Opal.const_get_relative($nesting, 'ArgumentError'), "" + "Both colors must be of the same color space: " + (color1.$inspect()) + " and " + (color2.$inspect()))};
          self.$process_color(color1);
          self.$process_color(color2);
          shader = self['$ref!']($hash2(["FunctionType", "Domain", "C0", "C1", "N"], {"FunctionType": 2, "Domain": [0.0, 1.0], "C0": color1, "C1": color2, "N": 1.0}));
          $b = self.$gradient_coordinates(args, opts), $a = Opal.to_ary($b), (x1 = ($a[0] == null ? nil : $a[0])), (y1 = ($a[1] == null ? nil : $a[1])), (x2 = ($a[2] == null ? nil : $a[2])), (y2 = ($a[3] == null ? nil : $a[3])), (transformation = ($a[4] == null ? nil : $a[4])), $b;
          if (args.$length()['$=='](4)) {
            coords = [0, 0, $rb_minus(x2, x1), $rb_minus(y2, y1)]
            } else {
            coords = [0, 0, args['$[]'](1), $rb_minus(x2, x1), $rb_minus(y2, y1), args['$[]'](3)]
          };
          shading = self['$ref!']($hash2(["ShadingType", "ColorSpace", "Coords", "Function", "Extend"], {"ShadingType": (function() {if (args.$length()['$=='](4)) {
            return 2
            } else {
            return 3
          }; return nil; })(), "ColorSpace": self.$color_space(color1), "Coords": coords, "Function": shader, "Extend": [true, true]}));
          return self['$ref!']($hash2(["PatternType", "Shading", "Matrix"], {"PatternType": 2, "Shading": shading, "Matrix": transformation}));
        }, TMP_Patterns_gradient_6.$$arity = 2);
        
        Opal.defn(self, '$gradient_coordinates', TMP_Patterns_gradient_coordinates_7 = function $$gradient_coordinates(args, opts) {
          var $a, $b, self = this, x1 = nil, y1 = nil, x2 = nil, y2 = nil, transformation = nil;

          
          $b = self.$map_to_absolute(args['$[]'](0)), $a = Opal.to_ary($b), (x1 = ($a[0] == null ? nil : $a[0])), (y1 = ($a[1] == null ? nil : $a[1])), $b;
          $b = self.$map_to_absolute(args['$[]']((function() {if (args.$length()['$=='](4)) {
            return 1
            } else {
            return 2
          }; return nil; })())), $a = Opal.to_ary($b), (x2 = ($a[0] == null ? nil : $a[0])), (y2 = ($a[1] == null ? nil : $a[1])), $b;
          transformation = (function() {if ($truthy(opts['$[]']("apply_transformations"))) {
            return self.$current_transformation_matrix_with_translation(x1, y1)
            } else {
            return [1, 0, 0, 1, x1, y1]
          }; return nil; })();
          return [x1, y1, x2, y2, transformation];
        }, TMP_Patterns_gradient_coordinates_7.$$arity = 2);
      })($nesting[0], $nesting)
    })($nesting[0], $nesting)
  })($nesting[0], $nesting)
};

/* Generated by Opal 0.11.0 */
Opal.modules["prawn/graphics"] = function(Opal) {
  function $rb_minus(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs - rhs : lhs['$-'](rhs);
  }
  function $rb_plus(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs + rhs : lhs['$+'](rhs);
  }
  function $rb_times(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs * rhs : lhs['$*'](rhs);
  }
  function $rb_divide(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs / rhs : lhs['$/'](rhs);
  }
  var self = Opal.top, $nesting = [], nil = Opal.nil, $breaker = Opal.breaker, $slice = Opal.slice, $module = Opal.module, $truthy = Opal.truthy, $send = Opal.send, $hash2 = Opal.hash2, $range = Opal.range;

  Opal.add_stubs(['$include', '$real_params', '$map_to_absolute', '$add_content', '$renderer', '$[]', '$fail', '$flat_map', '$<<', '$-', '$rounded_polygon', '$+', '$current_line_width=', '$write_line_width', '$line_width=', '$current_line_width', '$flatten', '$move_to', '$line_to', '$y', '$absolute_bottom', '$bounds', '$line', '$horizontal_line', '$left', '$right', '$curve_to', '$*', '$/', '$sqrt', '$ellipse', '$each', '$point_on_line', '$size', '$times', '$rounded_vertex', '$stroke_rectangle', '$top_left', '$width', '$height', '$merge', '$to_i', '$verify_options', '$save_graphics_state', '$fill_color', '$stroke_color', '$dash', '$stroke_horizontal_line', '$stroke_vertical_line', '$undash', '$fill_circle', '$step', '$draw_text', '$==', '$product', '$class_eval', '$private', '$line_width', '$graphic_state', '$absolute_left', '$replace', '$**']);
  
  self.$require("prawn/graphics"+ '/../' + "graphics/blend_mode");
  self.$require("prawn/graphics"+ '/../' + "graphics/color");
  self.$require("prawn/graphics"+ '/../' + "graphics/dash");
  self.$require("prawn/graphics"+ '/../' + "graphics/cap_style");
  self.$require("prawn/graphics"+ '/../' + "graphics/join_style");
  self.$require("prawn/graphics"+ '/../' + "graphics/transparency");
  self.$require("prawn/graphics"+ '/../' + "graphics/transformation");
  self.$require("prawn/graphics"+ '/../' + "graphics/patterns");
  return (function($base, $parent_nesting) {
    var $Prawn, self = $Prawn = $module($base, 'Prawn');

    var def = self.$$proto, $nesting = [self].concat($parent_nesting);

    (function($base, $parent_nesting) {
      var $Graphics, self = $Graphics = $module($base, 'Graphics');

      var def = self.$$proto, $nesting = [self].concat($parent_nesting), TMP_Graphics_move_to_1, TMP_Graphics_line_to_2, TMP_Graphics_curve_to_4, TMP_Graphics_rectangle_5, TMP_Graphics_rounded_rectangle_6, TMP_Graphics_line_width$eq_7, TMP_Graphics_line_width_8, TMP_Graphics_line_9, TMP_Graphics_horizontal_line_10, TMP_Graphics_horizontal_rule_11, TMP_Graphics_vertical_line_12, TMP_Graphics_curve_13, TMP_Graphics_circle_14, TMP_Graphics_ellipse_15, TMP_Graphics_polygon_17, TMP_Graphics_rounded_polygon_19, TMP_Graphics_rounded_vertex_20, TMP_Graphics_stroke_21, TMP_Graphics_close_and_stroke_22, TMP_Graphics_stroke_bounds_23, TMP_Graphics_stroke_axis_27, TMP_Graphics_fill_28, TMP_Graphics_fill_and_stroke_29, TMP_Graphics_close_path_30, TMP_Graphics_31, TMP_Graphics_current_line_width_32, TMP_Graphics_current_line_width$eq_33, TMP_Graphics_write_line_width_34, TMP_Graphics_map_to_absolute_35, TMP_Graphics_map_to_absolute$B_36, TMP_Graphics_degree_to_rad_37, TMP_Graphics_point_on_line_38, ops = nil, shapes = nil;

      
      self.$include(Opal.const_get_relative($nesting, 'BlendMode'));
      self.$include(Opal.const_get_relative($nesting, 'Color'));
      self.$include(Opal.const_get_relative($nesting, 'Dash'));
      self.$include(Opal.const_get_relative($nesting, 'CapStyle'));
      self.$include(Opal.const_get_relative($nesting, 'JoinStyle'));
      self.$include(Opal.const_get_relative($nesting, 'Transparency'));
      self.$include(Opal.const_get_relative($nesting, 'Transformation'));
      self.$include(Opal.const_get_relative($nesting, 'Patterns'));
      
      Opal.defn(self, '$move_to', TMP_Graphics_move_to_1 = function $$move_to($a_rest) {
        var self = this, point, xy = nil;

        var $args_len = arguments.length, $rest_len = $args_len - 0;
        if ($rest_len < 0) { $rest_len = 0; }
        point = new Array($rest_len);
        for (var $arg_idx = 0; $arg_idx < $args_len; $arg_idx++) {
          point[$arg_idx - 0] = arguments[$arg_idx];
        }
        
        xy = Opal.const_get_qualified(Opal.const_get_relative($nesting, 'PDF'), 'Core').$real_params(self.$map_to_absolute(point));
        return self.$renderer().$add_content("" + (xy) + " m");
      }, TMP_Graphics_move_to_1.$$arity = -1);
      
      Opal.defn(self, '$line_to', TMP_Graphics_line_to_2 = function $$line_to($a_rest) {
        var self = this, point, xy = nil;

        var $args_len = arguments.length, $rest_len = $args_len - 0;
        if ($rest_len < 0) { $rest_len = 0; }
        point = new Array($rest_len);
        for (var $arg_idx = 0; $arg_idx < $args_len; $arg_idx++) {
          point[$arg_idx - 0] = arguments[$arg_idx];
        }
        
        xy = Opal.const_get_qualified(Opal.const_get_relative($nesting, 'PDF'), 'Core').$real_params(self.$map_to_absolute(point));
        return self.$renderer().$add_content("" + (xy) + " l");
      }, TMP_Graphics_line_to_2.$$arity = -1);
      
      Opal.defn(self, '$curve_to', TMP_Graphics_curve_to_4 = function $$curve_to(dest, options) {
        var $a, TMP_3, self = this, curve_points = nil;

        if (options == null) {
          options = $hash2([], {});
        }
        
        ($truthy($a = options['$[]']("bounds")) ? $a : self.$fail(Opal.const_get_qualified(Opal.const_get_qualified(Opal.const_get_relative($nesting, 'Prawn'), 'Errors'), 'InvalidGraphicsPath'), "" + "Bounding points for bezier curve must be specified " + "as :bounds => [[x1,y1],[x2,y2]]"));
        curve_points = Opal.const_get_qualified(Opal.const_get_relative($nesting, 'PDF'), 'Core').$real_params($send(options['$[]']("bounds")['$<<'](dest), 'flat_map', [], (TMP_3 = function(e){var self = TMP_3.$$s || this;
if (e == null) e = nil;
        return self.$map_to_absolute(e)}, TMP_3.$$s = self, TMP_3.$$arity = 1, TMP_3)));
        return self.$renderer().$add_content("" + (curve_points) + " c");
      }, TMP_Graphics_curve_to_4.$$arity = -2);
      
      Opal.defn(self, '$rectangle', TMP_Graphics_rectangle_5 = function $$rectangle(point, width, height) {
        var $a, $b, self = this, x = nil, y = nil, box = nil;

        
        $b = self.$map_to_absolute(point), $a = Opal.to_ary($b), (x = ($a[0] == null ? nil : $a[0])), (y = ($a[1] == null ? nil : $a[1])), $b;
        box = Opal.const_get_qualified(Opal.const_get_relative($nesting, 'PDF'), 'Core').$real_params([x, $rb_minus(y, height), width, height]);
        return self.$renderer().$add_content("" + (box) + " re");
      }, TMP_Graphics_rectangle_5.$$arity = 3);
      
      Opal.defn(self, '$rounded_rectangle', TMP_Graphics_rounded_rectangle_6 = function $$rounded_rectangle(point, width, height, radius) {
        var $a, $b, self = this, x = nil, y = nil;

        
        $b = point, $a = Opal.to_ary($b), (x = ($a[0] == null ? nil : $a[0])), (y = ($a[1] == null ? nil : $a[1])), $b;
        return self.$rounded_polygon(radius, point, [$rb_plus(x, width), y], [$rb_plus(x, width), $rb_minus(y, height)], [x, $rb_minus(y, height)]);
      }, TMP_Graphics_rounded_rectangle_6.$$arity = 4);
      
      Opal.defn(self, '$line_width=', TMP_Graphics_line_width$eq_7 = function(width) {
        var self = this, $writer = nil;

        
        
        $writer = [width];
        $send(self, 'current_line_width=', Opal.to_a($writer));
        $writer[$rb_minus($writer["length"], 1)];;
        return self.$write_line_width();
      }, TMP_Graphics_line_width$eq_7.$$arity = 1);
      
      Opal.defn(self, '$line_width', TMP_Graphics_line_width_8 = function $$line_width(width) {
        var self = this, $writer = nil;

        if (width == null) {
          width = nil;
        }
        if ($truthy(width)) {
          
          $writer = [width];
          $send(self, 'line_width=', Opal.to_a($writer));
          return $writer[$rb_minus($writer["length"], 1)];
          } else {
          return self.$current_line_width()
        }
      }, TMP_Graphics_line_width_8.$$arity = -1);
      
      Opal.defn(self, '$line', TMP_Graphics_line_9 = function $$line($a_rest) {
        var $b, $c, self = this, points, x0 = nil, y0 = nil, x1 = nil, y1 = nil;

        var $args_len = arguments.length, $rest_len = $args_len - 0;
        if ($rest_len < 0) { $rest_len = 0; }
        points = new Array($rest_len);
        for (var $arg_idx = 0; $arg_idx < $args_len; $arg_idx++) {
          points[$arg_idx - 0] = arguments[$arg_idx];
        }
        
        $c = points.$flatten(), $b = Opal.to_ary($c), (x0 = ($b[0] == null ? nil : $b[0])), (y0 = ($b[1] == null ? nil : $b[1])), (x1 = ($b[2] == null ? nil : $b[2])), (y1 = ($b[3] == null ? nil : $b[3])), $c;
        self.$move_to(x0, y0);
        return self.$line_to(x1, y1);
      }, TMP_Graphics_line_9.$$arity = -1);
      
      Opal.defn(self, '$horizontal_line', TMP_Graphics_horizontal_line_10 = function $$horizontal_line(x1, x2, options) {
        var self = this, y1 = nil;

        if (options == null) {
          options = $hash2([], {});
        }
        
        if ($truthy(options['$[]']("at"))) {
          y1 = options['$[]']("at")
          } else {
          y1 = $rb_minus(self.$y(), self.$bounds().$absolute_bottom())
        };
        return self.$line(x1, y1, x2, y1);
      }, TMP_Graphics_horizontal_line_10.$$arity = -3);
      
      Opal.defn(self, '$horizontal_rule', TMP_Graphics_horizontal_rule_11 = function $$horizontal_rule() {
        var self = this;

        return self.$horizontal_line(self.$bounds().$left(), self.$bounds().$right())
      }, TMP_Graphics_horizontal_rule_11.$$arity = 0);
      
      Opal.defn(self, '$vertical_line', TMP_Graphics_vertical_line_12 = function $$vertical_line(y1, y2, params) {
        var self = this;

        return self.$line(params['$[]']("at"), y1, params['$[]']("at"), y2)
      }, TMP_Graphics_vertical_line_12.$$arity = 3);
      
      Opal.defn(self, '$curve', TMP_Graphics_curve_13 = function $$curve(origin, dest, options) {
        var self = this;

        if (options == null) {
          options = $hash2([], {});
        }
        
        $send(self, 'move_to', Opal.to_a(origin));
        return self.$curve_to(dest, options);
      }, TMP_Graphics_curve_13.$$arity = -3);
      Opal.const_set($nesting[0], 'KAPPA', $rb_times(4.0, $rb_divide($rb_minus(Opal.const_get_relative($nesting, 'Math').$sqrt(2), 1.0), 3.0)));
      
      Opal.defn(self, '$circle', TMP_Graphics_circle_14 = function $$circle(center, radius) {
        var self = this;

        return self.$ellipse(center, radius, radius)
      }, TMP_Graphics_circle_14.$$arity = 2);
      
      Opal.defn(self, '$ellipse', TMP_Graphics_ellipse_15 = function $$ellipse(point, r1, r2) {
        var $a, $b, self = this, x = nil, y = nil, l1 = nil, l2 = nil;

        if (r2 == null) {
          r2 = r1;
        }
        
        $b = point, $a = Opal.to_ary($b), (x = ($a[0] == null ? nil : $a[0])), (y = ($a[1] == null ? nil : $a[1])), $b;
        l1 = $rb_times(r1, Opal.const_get_relative($nesting, 'KAPPA'));
        l2 = $rb_times(r2, Opal.const_get_relative($nesting, 'KAPPA'));
        self.$move_to($rb_plus(x, r1), y);
        self.$curve_to([x, $rb_plus(y, r2)], $hash2(["bounds"], {"bounds": [[$rb_plus(x, r1), $rb_plus(y, l2)], [$rb_plus(x, l1), $rb_plus(y, r2)]]}));
        self.$curve_to([$rb_minus(x, r1), y], $hash2(["bounds"], {"bounds": [[$rb_minus(x, l1), $rb_plus(y, r2)], [$rb_minus(x, r1), $rb_plus(y, l2)]]}));
        self.$curve_to([x, $rb_minus(y, r2)], $hash2(["bounds"], {"bounds": [[$rb_minus(x, r1), $rb_minus(y, l2)], [$rb_minus(x, l1), $rb_minus(y, r2)]]}));
        self.$curve_to([$rb_plus(x, r1), y], $hash2(["bounds"], {"bounds": [[$rb_plus(x, l1), $rb_minus(y, r2)], [$rb_plus(x, r1), $rb_minus(y, l2)]]}));
        return self.$move_to(x, y);
      }, TMP_Graphics_ellipse_15.$$arity = -3);
      
      Opal.defn(self, '$polygon', TMP_Graphics_polygon_17 = function $$polygon($a_rest) {
        var TMP_16, self = this, points;

        var $args_len = arguments.length, $rest_len = $args_len - 0;
        if ($rest_len < 0) { $rest_len = 0; }
        points = new Array($rest_len);
        for (var $arg_idx = 0; $arg_idx < $args_len; $arg_idx++) {
          points[$arg_idx - 0] = arguments[$arg_idx];
        }
        
        self.$move_to(points['$[]'](0));
        $send(points['$[]']($range(1, -1, false))['$<<'](points['$[]'](0)), 'each', [], (TMP_16 = function(point){var self = TMP_16.$$s || this;
if (point == null) point = nil;
        return $send(self, 'line_to', Opal.to_a(point))}, TMP_16.$$s = self, TMP_16.$$arity = 1, TMP_16));
        return self.$renderer().$add_content("h");
      }, TMP_Graphics_polygon_17.$$arity = -1);
      
      Opal.defn(self, '$rounded_polygon', TMP_Graphics_rounded_polygon_19 = function $$rounded_polygon(radius, $a_rest) {
        var TMP_18, self = this, points, sides = nil;

        var $args_len = arguments.length, $rest_len = $args_len - 1;
        if ($rest_len < 0) { $rest_len = 0; }
        points = new Array($rest_len);
        for (var $arg_idx = 1; $arg_idx < $args_len; $arg_idx++) {
          points[$arg_idx - 1] = arguments[$arg_idx];
        }
        
        self.$move_to(self.$point_on_line(radius, points['$[]'](1), points['$[]'](0)));
        sides = points.$size();
        points['$<<'](points['$[]'](0))['$<<'](points['$[]'](1));
        $send(sides, 'times', [], (TMP_18 = function(i){var self = TMP_18.$$s || this;
if (i == null) i = nil;
        return self.$rounded_vertex(radius, points['$[]'](i), points['$[]']($rb_plus(i, 1)), points['$[]']($rb_plus(i, 2)))}, TMP_18.$$s = self, TMP_18.$$arity = 1, TMP_18));
        return self.$renderer().$add_content("h");
      }, TMP_Graphics_rounded_polygon_19.$$arity = -2);
      
      Opal.defn(self, '$rounded_vertex', TMP_Graphics_rounded_vertex_20 = function $$rounded_vertex(radius, $a_rest) {
        var self = this, points, radial_point_1 = nil, bezier_point_1 = nil, radial_point_2 = nil, bezier_point_2 = nil;

        var $args_len = arguments.length, $rest_len = $args_len - 1;
        if ($rest_len < 0) { $rest_len = 0; }
        points = new Array($rest_len);
        for (var $arg_idx = 1; $arg_idx < $args_len; $arg_idx++) {
          points[$arg_idx - 1] = arguments[$arg_idx];
        }
        
        radial_point_1 = self.$point_on_line(radius, points['$[]'](0), points['$[]'](1));
        bezier_point_1 = self.$point_on_line($rb_minus(radius, $rb_times(radius, Opal.const_get_relative($nesting, 'KAPPA'))), points['$[]'](0), points['$[]'](1));
        radial_point_2 = self.$point_on_line(radius, points['$[]'](2), points['$[]'](1));
        bezier_point_2 = self.$point_on_line($rb_minus(radius, $rb_times(radius, Opal.const_get_relative($nesting, 'KAPPA'))), points['$[]'](2), points['$[]'](1));
        self.$line_to(radial_point_1);
        return self.$curve_to(radial_point_2, $hash2(["bounds"], {"bounds": [bezier_point_1, bezier_point_2]}));
      }, TMP_Graphics_rounded_vertex_20.$$arity = -2);
      
      Opal.defn(self, '$stroke', TMP_Graphics_stroke_21 = function $$stroke() {
        var self = this, $iter = TMP_Graphics_stroke_21.$$p, $yield = $iter || nil;

        if ($iter) TMP_Graphics_stroke_21.$$p = null;
        
        if (($yield !== nil)) {
          Opal.yieldX($yield, [])};
        return self.$renderer().$add_content("S");
      }, TMP_Graphics_stroke_21.$$arity = 0);
      
      Opal.defn(self, '$close_and_stroke', TMP_Graphics_close_and_stroke_22 = function $$close_and_stroke() {
        var self = this, $iter = TMP_Graphics_close_and_stroke_22.$$p, $yield = $iter || nil;

        if ($iter) TMP_Graphics_close_and_stroke_22.$$p = null;
        
        if (($yield !== nil)) {
          Opal.yieldX($yield, [])};
        return self.$renderer().$add_content("s");
      }, TMP_Graphics_close_and_stroke_22.$$arity = 0);
      
      Opal.defn(self, '$stroke_bounds', TMP_Graphics_stroke_bounds_23 = function $$stroke_bounds() {
        var self = this;

        return self.$stroke_rectangle(self.$bounds().$top_left(), self.$bounds().$width(), self.$bounds().$height())
      }, TMP_Graphics_stroke_bounds_23.$$arity = 0);
      
      Opal.defn(self, '$stroke_axis', TMP_Graphics_stroke_axis_27 = function $$stroke_axis(options) {
        var $a, TMP_24, self = this;

        if (options == null) {
          options = $hash2([], {});
        }
        
        options = $hash2(["at", "height", "width", "step_length", "negative_axes_length", "color"], {"at": [0, 0], "height": $rb_minus(self.$bounds().$height().$to_i(), ($truthy($a = options['$[]']("at")) ? $a : [0, 0])['$[]'](1)), "width": $rb_minus(self.$bounds().$width().$to_i(), ($truthy($a = options['$[]']("at")) ? $a : [0, 0])['$[]'](0)), "step_length": 100, "negative_axes_length": 20, "color": "000000"}).$merge(options);
        Opal.const_get_relative($nesting, 'Prawn').$verify_options(["at", "width", "height", "step_length", "negative_axes_length", "color"], options);
        return $send(self, 'save_graphics_state', [], (TMP_24 = function(){var self = TMP_24.$$s || this, TMP_25, TMP_26;

        
          self.$fill_color(options['$[]']("color"));
          self.$stroke_color(options['$[]']("color"));
          self.$dash(1, $hash2(["space"], {"space": 4}));
          self.$stroke_horizontal_line($rb_minus(options['$[]']("at")['$[]'](0), options['$[]']("negative_axes_length")), $rb_plus(options['$[]']("at")['$[]'](0), options['$[]']("width")), $hash2(["at"], {"at": options['$[]']("at")['$[]'](1)}));
          self.$stroke_vertical_line($rb_minus(options['$[]']("at")['$[]'](1), options['$[]']("negative_axes_length")), $rb_plus(options['$[]']("at")['$[]'](1), options['$[]']("height")), $hash2(["at"], {"at": options['$[]']("at")['$[]'](0)}));
          self.$undash();
          self.$fill_circle(options['$[]']("at"), 1);
          $send(Opal.Range.$new(options['$[]']("step_length"), options['$[]']("width"), false), 'step', [options['$[]']("step_length")], (TMP_25 = function(point){var self = TMP_25.$$s || this;
if (point == null) point = nil;
          
            self.$fill_circle([$rb_plus(options['$[]']("at")['$[]'](0), point), options['$[]']("at")['$[]'](1)], 1);
            return self.$draw_text(point, $hash2(["at", "size"], {"at": [$rb_minus($rb_plus(options['$[]']("at")['$[]'](0), point), 5), $rb_minus(options['$[]']("at")['$[]'](1), 10)], "size": 7}));}, TMP_25.$$s = self, TMP_25.$$arity = 1, TMP_25));
          return $send(Opal.Range.$new(options['$[]']("step_length"), options['$[]']("height"), false), 'step', [options['$[]']("step_length")], (TMP_26 = function(point){var self = TMP_26.$$s || this;
if (point == null) point = nil;
          
            self.$fill_circle([options['$[]']("at")['$[]'](0), $rb_plus(options['$[]']("at")['$[]'](1), point)], 1);
            return self.$draw_text(point, $hash2(["at", "size"], {"at": [$rb_minus(options['$[]']("at")['$[]'](0), 17), $rb_minus($rb_plus(options['$[]']("at")['$[]'](1), point), 2)], "size": 7}));}, TMP_26.$$s = self, TMP_26.$$arity = 1, TMP_26));}, TMP_24.$$s = self, TMP_24.$$arity = 0, TMP_24));
      }, TMP_Graphics_stroke_axis_27.$$arity = -1);
      
      Opal.defn(self, '$fill', TMP_Graphics_fill_28 = function $$fill(options) {
        var self = this, $iter = TMP_Graphics_fill_28.$$p, $yield = $iter || nil;

        if (options == null) {
          options = $hash2([], {});
        }
        if ($iter) TMP_Graphics_fill_28.$$p = null;
        
        if (($yield !== nil)) {
          Opal.yieldX($yield, [])};
        return self.$renderer().$add_content((function() {if (options['$[]']("fill_rule")['$==']("even_odd")) {
          return "f*"
          } else {
          return "f"
        }; return nil; })());
      }, TMP_Graphics_fill_28.$$arity = -1);
      
      Opal.defn(self, '$fill_and_stroke', TMP_Graphics_fill_and_stroke_29 = function $$fill_and_stroke(options) {
        var self = this, $iter = TMP_Graphics_fill_and_stroke_29.$$p, $yield = $iter || nil;

        if (options == null) {
          options = $hash2([], {});
        }
        if ($iter) TMP_Graphics_fill_and_stroke_29.$$p = null;
        
        if (($yield !== nil)) {
          Opal.yieldX($yield, [])};
        return self.$renderer().$add_content((function() {if (options['$[]']("fill_rule")['$==']("even_odd")) {
          return "b*"
          } else {
          return "b"
        }; return nil; })());
      }, TMP_Graphics_fill_and_stroke_29.$$arity = -1);
      
      Opal.defn(self, '$close_path', TMP_Graphics_close_path_30 = function $$close_path() {
        var self = this;

        return self.$renderer().$add_content("h")
      }, TMP_Graphics_close_path_30.$$arity = 0);
      ops = ["fill", "stroke", "fill_and_stroke"];
      shapes = ["line_to", "curve_to", "rectangle", "rounded_rectangle", "line", "horizontal_line", "horizontal_rule", "vertical_line", "curve", "circle_at", "circle", "ellipse_at", "ellipse", "polygon", "rounded_polygon", "rounded_vertex"];
      $send(ops.$product(shapes), 'each', [], (TMP_Graphics_31 = function(operation, shape){var self = TMP_Graphics_31.$$s || this;
if (operation == null) operation = nil;if (shape == null) shape = nil;
      return self.$class_eval("" + "def " + (operation) + "_" + (shape) + "(*args); " + (shape) + "(*args); " + (operation) + "; end")}, TMP_Graphics_31.$$s = self, TMP_Graphics_31.$$arity = 2, TMP_Graphics_31));
      self.$private();
      
      Opal.defn(self, '$current_line_width', TMP_Graphics_current_line_width_32 = function $$current_line_width() {
        var self = this;

        return self.$graphic_state().$line_width()
      }, TMP_Graphics_current_line_width_32.$$arity = 0);
      
      Opal.defn(self, '$current_line_width=', TMP_Graphics_current_line_width$eq_33 = function(width) {
        var self = this, $writer = nil;

        
        $writer = [width];
        $send(self.$graphic_state(), 'line_width=', Opal.to_a($writer));
        return $writer[$rb_minus($writer["length"], 1)];
      }, TMP_Graphics_current_line_width$eq_33.$$arity = 1);
      
      Opal.defn(self, '$write_line_width', TMP_Graphics_write_line_width_34 = function $$write_line_width() {
        var self = this;

        return self.$renderer().$add_content("" + (self.$current_line_width()) + " w")
      }, TMP_Graphics_write_line_width_34.$$arity = 0);
      
      Opal.defn(self, '$map_to_absolute', TMP_Graphics_map_to_absolute_35 = function $$map_to_absolute($a_rest) {
        var $b, $c, self = this, point, x = nil, y = nil;
        if (self.bounding_box == null) self.bounding_box = nil;

        var $args_len = arguments.length, $rest_len = $args_len - 0;
        if ($rest_len < 0) { $rest_len = 0; }
        point = new Array($rest_len);
        for (var $arg_idx = 0; $arg_idx < $args_len; $arg_idx++) {
          point[$arg_idx - 0] = arguments[$arg_idx];
        }
        
        $c = point.$flatten(), $b = Opal.to_ary($c), (x = ($b[0] == null ? nil : $b[0])), (y = ($b[1] == null ? nil : $b[1])), $c;
        return [$rb_plus(self.bounding_box.$absolute_left(), x), $rb_plus(self.bounding_box.$absolute_bottom(), y)];
      }, TMP_Graphics_map_to_absolute_35.$$arity = -1);
      
      Opal.defn(self, '$map_to_absolute!', TMP_Graphics_map_to_absolute$B_36 = function(point) {
        var self = this;

        return point.$replace(self.$map_to_absolute(point))
      }, TMP_Graphics_map_to_absolute$B_36.$$arity = 1);
      
      Opal.defn(self, '$degree_to_rad', TMP_Graphics_degree_to_rad_37 = function $$degree_to_rad(angle) {
        var self = this;

        return $rb_divide($rb_times(angle, Opal.const_get_qualified(Opal.const_get_relative($nesting, 'Math'), 'PI')), 180)
      }, TMP_Graphics_degree_to_rad_37.$$arity = 1);
      
      Opal.defn(self, '$point_on_line', TMP_Graphics_point_on_line_38 = function $$point_on_line(distance_from_end, $a_rest) {
        var $b, $c, self = this, points, x0 = nil, y0 = nil, x1 = nil, y1 = nil, length = nil, p = nil, xr = nil, yr = nil;

        var $args_len = arguments.length, $rest_len = $args_len - 1;
        if ($rest_len < 0) { $rest_len = 0; }
        points = new Array($rest_len);
        for (var $arg_idx = 1; $arg_idx < $args_len; $arg_idx++) {
          points[$arg_idx - 1] = arguments[$arg_idx];
        }
        
        $c = points.$flatten(), $b = Opal.to_ary($c), (x0 = ($b[0] == null ? nil : $b[0])), (y0 = ($b[1] == null ? nil : $b[1])), (x1 = ($b[2] == null ? nil : $b[2])), (y1 = ($b[3] == null ? nil : $b[3])), $c;
        length = Opal.const_get_relative($nesting, 'Math').$sqrt($rb_plus($rb_minus(x1, x0)['$**'](2), $rb_minus(y1, y0)['$**'](2)));
        p = $rb_divide($rb_minus(length, distance_from_end), length);
        xr = $rb_plus(x0, $rb_times(p, $rb_minus(x1, x0)));
        yr = $rb_plus(y0, $rb_times(p, $rb_minus(y1, y0)));
        return [xr, yr];
      }, TMP_Graphics_point_on_line_38.$$arity = -2);
    })($nesting[0], $nesting)
  })($nesting[0], $nesting);
};

/* Generated by Opal 0.11.0 */
Opal.modules["prawn/images"] = function(Opal) {
  function $rb_minus(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs - rhs : lhs['$-'](rhs);
  }
  function $rb_divide(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs / rhs : lhs['$/'](rhs);
  }
  function $rb_plus(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs + rhs : lhs['$+'](rhs);
  }
  function $rb_lt(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs < rhs : lhs['$<'](rhs);
  }
  var self = Opal.top, $nesting = [], nil = Opal.nil, $breaker = Opal.breaker, $slice = Opal.slice, $module = Opal.module, $hash2 = Opal.hash2, $truthy = Opal.truthy, $send = Opal.send, $hash = Opal.hash;

  Opal.add_stubs(['$require', '$verify_options', '$build_image_object', '$embed_image', '$verify_and_open_image', '$read', '$hexdigest', '$[]', '$image_registry', '$new', '$find', '$image_handler', '$respond_to?', '$min_version', '$renderer', '$min_pdf_version', '$build_pdf_object', '$[]=', '$-', '$calc_image_dimensions', '$map_to_absolute', '$image_position', '$move_text_position', '$next_image_id', '$merge!', '$xobjects', '$page', '$state', '$real_params', '$add_content', '$private', '$rewind', '$binmode', '$file?', '$fail', '$open', '$===', '$absolute_top', '$bounds', '$/', '$height', '$+', '$absolute_bottom', '$determine_y_with_page_flow', '$left_side', '$width', '$right_side', '$overruns_page?', '$move_past_bottom', '$y', '$<', '$reference_bounds']);
  
  self.$require("digest/sha1".$force_encoding("ASCII-8BIT"));
  self.$require("pathname".$force_encoding("ASCII-8BIT"));
  return (function($base, $parent_nesting) {
    var $Prawn, self = $Prawn = $module($base, 'Prawn');

    var def = self.$$proto, $nesting = [self].concat($parent_nesting);

    (function($base, $parent_nesting) {
      var $Images, self = $Images = $module($base, 'Images');

      var def = self.$$proto, $nesting = [self].concat($parent_nesting), TMP_Images_image_1, TMP_Images_build_image_object_2, TMP_Images_embed_image_3, TMP_Images_verify_and_open_image_4, TMP_Images_image_position_5, TMP_Images_determine_y_with_page_flow_6, TMP_Images_overruns_page$q_7, TMP_Images_image_registry_8, TMP_Images_next_image_id_9;

      
      
      Opal.defn(self, '$image', TMP_Images_image_1 = function $$image(file, options) {
        var $a, $b, self = this, pdf_obj = nil, info = nil;

        if (options == null) {
          options = $hash2([], {});
        }
        
        Opal.const_get_relative($nesting, 'Prawn').$verify_options(["at", "position", "vposition", "height", "width", "scale", "fit"], options);
        $b = self.$build_image_object(file), $a = Opal.to_ary($b), (pdf_obj = ($a[0] == null ? nil : $a[0])), (info = ($a[1] == null ? nil : $a[1])), $b;
        self.$embed_image(pdf_obj, info, options);
        return info;
      }, TMP_Images_image_1.$$arity = -2);
      
      Opal.defn(self, '$build_image_object', TMP_Images_build_image_object_2 = function $$build_image_object(file) {
        var self = this, io = nil, image_content = nil, image_sha1 = nil, info = nil, image_obj = nil, $writer = nil;

        
        io = self.$verify_and_open_image(file);
        image_content = io.$read();
        image_sha1 = Opal.const_get_qualified(Opal.const_get_relative($nesting, 'Digest'), 'SHA1').$hexdigest(image_content);
        if ($truthy(self.$image_registry()['$[]'](image_sha1))) {
          
          info = self.$image_registry()['$[]'](image_sha1)['$[]']("info");
          image_obj = self.$image_registry()['$[]'](image_sha1)['$[]']("obj");
          } else {
          
          info = Opal.const_get_relative($nesting, 'Prawn').$image_handler().$find(image_content).$new(image_content);
          if ($truthy(info['$respond_to?']("min_pdf_version"))) {
            self.$renderer().$min_version(info.$min_pdf_version())};
          image_obj = info.$build_pdf_object(self);
          
          $writer = [image_sha1, $hash2(["obj", "info"], {"obj": image_obj, "info": info})];
          $send(self.$image_registry(), '[]=', Opal.to_a($writer));
          $writer[$rb_minus($writer["length"], 1)];;
        };
        return [image_obj, info];
      }, TMP_Images_build_image_object_2.$$arity = 1);
      
      Opal.defn(self, '$embed_image', TMP_Images_embed_image_3 = function $$embed_image(pdf_obj, info, options) {
        var $a, $b, self = this, w = nil, h = nil, x = nil, y = nil, label = nil, cm_params = nil;

        
        $b = info.$calc_image_dimensions(options), $a = Opal.to_ary($b), (w = ($a[0] == null ? nil : $a[0])), (h = ($a[1] == null ? nil : $a[1])), $b;
        if ($truthy(options['$[]']("at"))) {
          $b = self.$map_to_absolute(options['$[]']("at")), $a = Opal.to_ary($b), (x = ($a[0] == null ? nil : $a[0])), (y = ($a[1] == null ? nil : $a[1])), $b
          } else {
          
          $b = self.$image_position(w, h, options), $a = Opal.to_ary($b), (x = ($a[0] == null ? nil : $a[0])), (y = ($a[1] == null ? nil : $a[1])), $b;
          self.$move_text_position(h);
        };
        label = "" + "I" + (self.$next_image_id());
        self.$state().$page().$xobjects()['$merge!']($hash(label, pdf_obj));
        cm_params = Opal.const_get_qualified(Opal.const_get_relative($nesting, 'PDF'), 'Core').$real_params([w, 0, 0, h, x, $rb_minus(y, h)]);
        return self.$renderer().$add_content("" + "\nq\n" + (cm_params) + " cm\n/" + (label) + " Do\nQ");
      }, TMP_Images_embed_image_3.$$arity = 3);
      self.$private();
      
      Opal.defn(self, '$verify_and_open_image', TMP_Images_verify_and_open_image_4 = function $$verify_and_open_image(io_or_path) {
        var self = this, io = nil;

        
        if ($truthy(io_or_path['$respond_to?']("rewind"))) {
          
          io = io_or_path;
          io.$rewind();
          if ($truthy(io['$respond_to?']("binmode"))) {
            io.$binmode()};
          return io;};
        io_or_path = Opal.const_get_relative($nesting, 'Pathname').$new(io_or_path);
        if ($truthy(io_or_path['$file?']())) {
          } else {
          self.$fail(Opal.const_get_relative($nesting, 'ArgumentError'), "" + (io_or_path) + " not found")
        };
        io = io_or_path.$open("rb".$force_encoding("ASCII-8BIT"));
        return io;
      }, TMP_Images_verify_and_open_image_4.$$arity = 1);
      
      Opal.defn(self, '$image_position', TMP_Images_image_position_5 = function $$image_position(w, h, options) {
        var $a, self = this, $writer = nil, y = nil, $case = nil, x = nil;

        
        ($truthy($a = options['$[]']("position")) ? $a : (($writer = ["position", "left"]), $send(options, '[]=', Opal.to_a($writer)), $writer[$rb_minus($writer["length"], 1)]));
        y = (function() {$case = options['$[]']("vposition");
        if ("top"['$===']($case)) {return self.$bounds().$absolute_top()}
        else if ("center"['$===']($case)) {return $rb_minus(self.$bounds().$absolute_top(), $rb_divide($rb_minus(self.$bounds().$height(), h), 2.0))}
        else if ("bottom"['$===']($case)) {return $rb_plus(self.$bounds().$absolute_bottom(), h)}
        else if (Opal.const_get_relative($nesting, 'Numeric')['$===']($case)) {return $rb_minus(self.$bounds().$absolute_top(), options['$[]']("vposition"))}
        else {return self.$determine_y_with_page_flow(h)}})();
        x = (function() {$case = options['$[]']("position");
        if ("left"['$===']($case)) {return self.$bounds().$left_side()}
        else if ("center"['$===']($case)) {return $rb_plus(self.$bounds().$left_side(), $rb_divide($rb_minus(self.$bounds().$width(), w), 2.0))}
        else if ("right"['$===']($case)) {return $rb_minus(self.$bounds().$right_side(), w)}
        else if (Opal.const_get_relative($nesting, 'Numeric')['$===']($case)) {return $rb_plus(options['$[]']("position"), self.$bounds().$left_side())}
        else { return nil }})();
        return [x, y];
      }, TMP_Images_image_position_5.$$arity = 3);
      
      Opal.defn(self, '$determine_y_with_page_flow', TMP_Images_determine_y_with_page_flow_6 = function $$determine_y_with_page_flow(h) {
        var self = this;

        
        if ($truthy(self['$overruns_page?'](h))) {
          self.$bounds().$move_past_bottom()};
        return self.$y();
      }, TMP_Images_determine_y_with_page_flow_6.$$arity = 1);
      
      Opal.defn(self, '$overruns_page?', TMP_Images_overruns_page$q_7 = function(h) {
        var self = this;

        return $rb_lt($rb_minus(self.$y(), h), self.$reference_bounds().$absolute_bottom())
      }, TMP_Images_overruns_page$q_7.$$arity = 1);
      
      Opal.defn(self, '$image_registry', TMP_Images_image_registry_8 = function $$image_registry() {
        var $a, self = this;
        if (self.image_registry == null) self.image_registry = nil;

        return (self.image_registry = ($truthy($a = self.image_registry) ? $a : $hash2([], {})))
      }, TMP_Images_image_registry_8.$$arity = 0);
      
      Opal.defn(self, '$next_image_id', TMP_Images_next_image_id_9 = function $$next_image_id() {
        var $a, self = this;
        if (self.image_counter == null) self.image_counter = nil;

        
        self.image_counter = ($truthy($a = self.image_counter) ? $a : 0);
        return (self.image_counter = $rb_plus(self.image_counter, 1));
      }, TMP_Images_next_image_id_9.$$arity = 0);
    })($nesting[0], $nesting)
  })($nesting[0], $nesting);
};

/* Generated by Opal 0.11.0 */
Opal.modules["prawn/images/image"] = function(Opal) {
  function $rb_divide(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs / rhs : lhs['$/'](rhs);
  }
  function $rb_times(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs * rhs : lhs['$*'](rhs);
  }
  function $rb_gt(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs > rhs : lhs['$>'](rhs);
  }
  function $rb_minus(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs - rhs : lhs['$-'](rhs);
  }
  var self = Opal.top, $nesting = [], nil = Opal.nil, $breaker = Opal.breaker, $slice = Opal.slice, $module = Opal.module, $klass = Opal.klass, $truthy = Opal.truthy, $send = Opal.send;

  Opal.add_stubs(['$require', '$[]', '$width', '$height', '$!', '$/', '$to_f', '$*', '$>', '$scaled_width=', '$-', '$scaled_height=']);
  
  self.$require("digest/sha1");
  return (function($base, $parent_nesting) {
    var $Prawn, self = $Prawn = $module($base, 'Prawn');

    var def = self.$$proto, $nesting = [self].concat($parent_nesting);

    (function($base, $parent_nesting) {
      var $Images, self = $Images = $module($base, 'Images');

      var def = self.$$proto, $nesting = [self].concat($parent_nesting);

      (function($base, $super, $parent_nesting) {
        function $Image(){};
        var self = $Image = $klass($base, $super, 'Image', $Image);

        var def = self.$$proto, $nesting = [self].concat($parent_nesting), TMP_Image_calc_image_dimensions_1;

        return (Opal.defn(self, '$calc_image_dimensions', TMP_Image_calc_image_dimensions_1 = function $$calc_image_dimensions(options) {
          var $a, $b, self = this, w = nil, h = nil, wp = nil, hp = nil, bw = nil, bh = nil, bp = nil, ip = nil, $writer = nil;

          
          w = ($truthy($a = options['$[]']("width")) ? $a : self.$width());
          h = ($truthy($a = options['$[]']("height")) ? $a : self.$height());
          if ($truthy(($truthy($a = options['$[]']("width")) ? options['$[]']("height")['$!']() : $a))) {
            
            wp = $rb_divide(w, self.$width().$to_f());
            w = $rb_times(self.$width(), wp);
            h = $rb_times(self.$height(), wp);
          } else if ($truthy(($truthy($a = options['$[]']("height")) ? options['$[]']("width")['$!']() : $a))) {
            
            hp = $rb_divide(h, self.$height().$to_f());
            w = $rb_times(self.$width(), hp);
            h = $rb_times(self.$height(), hp);
          } else if ($truthy(options['$[]']("scale"))) {
            
            w = $rb_times(self.$width(), options['$[]']("scale"));
            h = $rb_times(self.$height(), options['$[]']("scale"));
          } else if ($truthy(options['$[]']("fit"))) {
            
            $b = options['$[]']("fit"), $a = Opal.to_ary($b), (bw = ($a[0] == null ? nil : $a[0])), (bh = ($a[1] == null ? nil : $a[1])), $b;
            bp = $rb_divide(bw, bh.$to_f());
            ip = $rb_divide(self.$width(), self.$height().$to_f());
            if ($truthy($rb_gt(ip, bp))) {
              
              w = bw;
              h = $rb_divide(bw, ip);
              } else {
              
              h = bh;
              w = $rb_times(bh, ip);
            };};
          
          $writer = [w];
          $send(self, 'scaled_width=', Opal.to_a($writer));
          $writer[$rb_minus($writer["length"], 1)];;
          
          $writer = [h];
          $send(self, 'scaled_height=', Opal.to_a($writer));
          $writer[$rb_minus($writer["length"], 1)];;
          return [w, h];
        }, TMP_Image_calc_image_dimensions_1.$$arity = 1), nil) && 'calc_image_dimensions'
      })($nesting[0], null, $nesting)
    })($nesting[0], $nesting)
  })($nesting[0], $nesting);
};

/* Generated by Opal 0.11.0 */
Opal.modules["prawn/images/jpg"] = function(Opal) {
  function $rb_minus(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs - rhs : lhs['$-'](rhs);
  }
  var self = Opal.top, $nesting = [], nil = Opal.nil, $breaker = Opal.breaker, $slice = Opal.slice, $module = Opal.module, $klass = Opal.klass, $send = Opal.send, $truthy = Opal.truthy, $hash2 = Opal.hash2;

  Opal.add_stubs(['$require', '$attr_reader', '$attr_accessor', '$==', '$unpack', '$[]', '$new', '$binmode', '$seek', '$loop', '$read', '$!=', '$fail', '$include?', '$-', '$channels', '$===', '$ref!', '$bits', '$width', '$height', '$[]=', '$data', '$<<', '$stream', '$filters']);
  
  self.$require("stringio".$force_encoding("ASCII-8BIT"));
  return (function($base, $parent_nesting) {
    var $Prawn, self = $Prawn = $module($base, 'Prawn');

    var def = self.$$proto, $nesting = [self].concat($parent_nesting);

    (function($base, $parent_nesting) {
      var $Images, self = $Images = $module($base, 'Images');

      var def = self.$$proto, $nesting = [self].concat($parent_nesting);

      (function($base, $super, $parent_nesting) {
        function $JPG(){};
        var self = $JPG = $klass($base, $super, 'JPG', $JPG);

        var def = self.$$proto, $nesting = [self].concat($parent_nesting), TMP_JPG_can_render$q_1, TMP_JPG_initialize_3, TMP_JPG_build_pdf_object_4;

        def.data = nil;
        
        self.$attr_reader("width", "height", "bits", "channels");
        self.$attr_accessor("scaled_width", "scaled_height");
        Opal.const_set($nesting[0], 'JPEG_SOF_BLOCKS', [192, 193, 194, 195, 197, 198, 199, 201, 202, 203, 205, 206, 207]);
        Opal.defs(self, '$can_render?', TMP_JPG_can_render$q_1 = function(image_blob) {
          var self = this;

          return image_blob['$[]'](0, 3).$unpack("C*".$force_encoding("ASCII-8BIT"))['$==']([255, 216, 255])
        }, TMP_JPG_can_render$q_1.$$arity = 1);
        
        Opal.defn(self, '$initialize', TMP_JPG_initialize_3 = function $$initialize(data) {
          var TMP_2, self = this, d = nil, c_marker = nil;

          
          self.data = data;
          d = Opal.const_get_relative($nesting, 'StringIO').$new(self.data);
          d.$binmode();
          c_marker = 255;
          d.$seek(2);
          return (function(){var $brk = Opal.new_brk(); try {return $send(self, 'loop', [], (TMP_2 = function(){var self = TMP_2.$$s || this, $a, $b, marker = nil, code = nil, length = nil;

          
            $b = d.$read(4).$unpack("CCn".$force_encoding("ASCII-8BIT")), $a = Opal.to_ary($b), (marker = ($a[0] == null ? nil : $a[0])), (code = ($a[1] == null ? nil : $a[1])), (length = ($a[2] == null ? nil : $a[2])), $b;
            if ($truthy(marker['$!='](c_marker))) {
              self.$fail("JPEG marker not found!".$force_encoding("ASCII-8BIT"))};
            if ($truthy(Opal.const_get_relative($nesting, 'JPEG_SOF_BLOCKS')['$include?'](code))) {
              
              $b = d.$read(6).$unpack("CnnC".$force_encoding("ASCII-8BIT")), $a = Opal.to_ary($b), (self.bits = ($a[0] == null ? nil : $a[0])), (self.height = ($a[1] == null ? nil : $a[1])), (self.width = ($a[2] == null ? nil : $a[2])), (self.channels = ($a[3] == null ? nil : $a[3])), $b;
              
              Opal.brk(nil, $brk);};
            return d.$seek($rb_minus(length, 2), Opal.const_get_qualified(Opal.const_get_relative($nesting, 'IO'), 'SEEK_CUR'));}, TMP_2.$$s = self, TMP_2.$$brk = $brk, TMP_2.$$arity = 0, TMP_2))
          } catch (err) { if (err === $brk) { return err.$v } else { throw err } }})();
        }, TMP_JPG_initialize_3.$$arity = 1);
        return (Opal.defn(self, '$build_pdf_object', TMP_JPG_build_pdf_object_4 = function $$build_pdf_object(document) {
          var self = this, color_space = nil, $case = nil, obj = nil, $writer = nil;

          
          color_space = (function() {$case = self.$channels();
          if ((1)['$===']($case)) {return "DeviceGray"}
          else if ((3)['$===']($case)) {return "DeviceRGB"}
          else if ((4)['$===']($case)) {return "DeviceCMYK"}
          else {return self.$fail(Opal.const_get_relative($nesting, 'ArgumentError'), "JPG uses an unsupported number of channels".$force_encoding("ASCII-8BIT"))}})();
          obj = document['$ref!']($hash2(["Type", "Subtype", "ColorSpace", "BitsPerComponent", "Width", "Height"], {"Type": "XObject", "Subtype": "Image", "ColorSpace": color_space, "BitsPerComponent": self.$bits(), "Width": self.$width(), "Height": self.$height()}));
          if (color_space['$==']("DeviceCMYK")) {
            
            $writer = ["Decode", [1.0, 0.0, 1.0, 0.0, 1.0, 0.0, 1.0, 0.0]];
            $send(obj.$data(), '[]=', Opal.to_a($writer));
            $writer[$rb_minus($writer["length"], 1)];};
          obj.$stream()['$<<'](self.data);
          obj.$stream().$filters()['$<<']("DCTDecode");
          return obj;
        }, TMP_JPG_build_pdf_object_4.$$arity = 1), nil) && 'build_pdf_object';
      })($nesting[0], Opal.const_get_relative($nesting, 'Image'), $nesting)
    })($nesting[0], $nesting)
  })($nesting[0], $nesting);
};

/* Generated by Opal 0.11.0 */
Opal.modules["enumerator"] = function(Opal) {
  var self = Opal.top, $nesting = [], nil = Opal.nil, $breaker = Opal.breaker, $slice = Opal.slice;

  return nil
};

/* Generated by Opal 0.11.0 */
Opal.modules["prawn/images/png"] = function(Opal) {
  function $rb_minus(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs - rhs : lhs['$-'](rhs);
  }
  function $rb_plus(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs + rhs : lhs['$+'](rhs);
  }
  function $rb_divide(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs / rhs : lhs['$/'](rhs);
  }
  function $rb_gt(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs > rhs : lhs['$>'](rhs);
  }
  function $rb_times(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs * rhs : lhs['$*'](rhs);
  }
  var self = Opal.top, $nesting = [], nil = Opal.nil, $breaker = Opal.breaker, $slice = Opal.slice, $module = Opal.module, $klass = Opal.klass, $hash2 = Opal.hash2, $send = Opal.send, $truthy = Opal.truthy;

  Opal.add_stubs(['$require', '$attr_reader', '$attr_accessor', '$==', '$unpack', '$[]', '$new', '$dup', '$read', '$loop', '$===', '$<<', '$[]=', '$-', '$first', '$seek', '$+', '$pos', '$inflate', '$color_type', '$alpha_channel?', '$generate_alpha_channel', '$split_image_data', '$any?', '$!=', '$compression_method', '$fail', '$filter_method', '$interlace_method', '$split_alpha_channel!', '$colors', '$png', '$ref!', '$height', '$width', '$bits', '$img_data', '$filters', '$stream', '$empty?', '$palette', '$data', '$/', '$size', '$transparency', '$flatten', '$collect', '$alpha_channel', '$>', '$private', '$*', '$bytesize', '$binmode', '$pack', '$times', '$getbyte', '$putc', '$write', '$upto']);
  
  self.$require("stringio".$force_encoding("ASCII-8BIT"));
  self.$require("enumerator".$force_encoding("ASCII-8BIT"));
  return (function($base, $parent_nesting) {
    var $Prawn, self = $Prawn = $module($base, 'Prawn');

    var def = self.$$proto, $nesting = [self].concat($parent_nesting);

    (function($base, $parent_nesting) {
      var $Images, self = $Images = $module($base, 'Images');

      var def = self.$$proto, $nesting = [self].concat($parent_nesting);

      (function($base, $super, $parent_nesting) {
        function $PNG(){};
        var self = $PNG = $klass($base, $super, 'PNG', $PNG);

        var def = self.$$proto, $nesting = [self].concat($parent_nesting), TMP_PNG_can_render$q_1, TMP_PNG_initialize_3, TMP_PNG_colors_4, TMP_PNG_split_alpha_channel$B_5, TMP_PNG_alpha_channel$q_6, TMP_PNG_build_pdf_object_8, TMP_PNG_min_pdf_version_9, TMP_PNG_split_image_data_12, TMP_PNG_generate_alpha_channel_16;

        def.img_data = def.transparency = def.alpha_channel = nil;
        
        self.$attr_reader("palette", "img_data", "transparency");
        self.$attr_reader("width", "height", "bits");
        self.$attr_reader("color_type", "compression_method", "filter_method");
        self.$attr_reader("interlace_method", "alpha_channel");
        self.$attr_accessor("scaled_width", "scaled_height");
        Opal.defs(self, '$can_render?', TMP_PNG_can_render$q_1 = function(image_blob) {
          var self = this;

          return image_blob['$[]'](0, 8).$unpack("C*".$force_encoding("ASCII-8BIT"))['$==']([137, 80, 78, 71, 13, 10, 26, 10])
        }, TMP_PNG_can_render$q_1.$$arity = 1);
        
        Opal.defn(self, '$initialize', TMP_PNG_initialize_3 = function $$initialize(data) {
          var TMP_2, self = this;

          
          data = Opal.const_get_relative($nesting, 'StringIO').$new(data.$dup());
          data.$read(8);
          self.palette = "".$force_encoding("ASCII-8BIT");
          self.img_data = "".$force_encoding("ASCII-8BIT");
          self.transparency = $hash2([], {});
          (function(){var $brk = Opal.new_brk(); try {return $send(self, 'loop', [], (TMP_2 = function(){var self = TMP_2.$$s || this, chunk_size = nil, section = nil, $case = nil, values = nil, $writer = nil, grayval = nil;
            if (self.palette == null) self.palette = nil;
            if (self.img_data == null) self.img_data = nil;
            if (self.color_type == null) self.color_type = nil;
            if (self.transparency == null) self.transparency = nil;

          
            chunk_size = data.$read(4).$unpack("N".$force_encoding("ASCII-8BIT"))['$[]'](0);
            section = data.$read(4);
            $case = section;
            if ("IHDR".$force_encoding("ASCII-8BIT")['$===']($case)) {
            values = data.$read(chunk_size).$unpack("NNCCCCC".$force_encoding("ASCII-8BIT"));
            self.width = values['$[]'](0);
            self.height = values['$[]'](1);
            self.bits = values['$[]'](2);
            self.color_type = values['$[]'](3);
            self.compression_method = values['$[]'](4);
            self.filter_method = values['$[]'](5);
            self.interlace_method = values['$[]'](6);}
            else if ("PLTE".$force_encoding("ASCII-8BIT")['$===']($case)) {self.palette['$<<'](data.$read(chunk_size))}
            else if ("IDAT".$force_encoding("ASCII-8BIT")['$===']($case)) {self.img_data['$<<'](data.$read(chunk_size))}
            else if ("tRNS".$force_encoding("ASCII-8BIT")['$===']($case)) {
            self.transparency = $hash2([], {});
            $case = self.color_type;
            if ((3)['$===']($case)) {
            $writer = ["palette", data.$read(chunk_size).$unpack("C*".$force_encoding("ASCII-8BIT"))];
            $send(self.transparency, '[]=', Opal.to_a($writer));
            $writer[$rb_minus($writer["length"], 1)];}
            else if ((0)['$===']($case)) {
            grayval = data.$read(chunk_size).$unpack("n".$force_encoding("ASCII-8BIT")).$first();
            
            $writer = ["grayscale", grayval];
            $send(self.transparency, '[]=', Opal.to_a($writer));
            $writer[$rb_minus($writer["length"], 1)];;}
            else if ((2)['$===']($case)) {
            $writer = ["rgb", data.$read(chunk_size).$unpack("nnn".$force_encoding("ASCII-8BIT"))];
            $send(self.transparency, '[]=', Opal.to_a($writer));
            $writer[$rb_minus($writer["length"], 1)];};}
            else if ("IEND".$force_encoding("ASCII-8BIT")['$===']($case)) {
            Opal.brk(nil, $brk)}
            else {data.$seek($rb_plus(data.$pos(), chunk_size))};
            return data.$read(4);}, TMP_2.$$s = self, TMP_2.$$brk = $brk, TMP_2.$$arity = 0, TMP_2))
          } catch (err) { if (err === $brk) { return err.$v } else { throw err } }})();
          return (self.img_data = Opal.const_get_qualified(Opal.const_get_relative($nesting, 'Zlib'), 'Inflate').$inflate(self.img_data));
        }, TMP_PNG_initialize_3.$$arity = 1);
        
        Opal.defn(self, '$colors', TMP_PNG_colors_4 = function $$colors() {
          var self = this, $case = nil;

          return (function() {$case = self.$color_type();
          if ((0)['$===']($case) || (3)['$===']($case) || (4)['$===']($case)) {return 1}
          else if ((2)['$===']($case) || (6)['$===']($case)) {return 3}
          else { return nil }})()
        }, TMP_PNG_colors_4.$$arity = 0);
        
        Opal.defn(self, '$split_alpha_channel!', TMP_PNG_split_alpha_channel$B_5 = function() {
          var self = this;

          if ($truthy(self['$alpha_channel?']())) {
            if (self.$color_type()['$=='](3)) {
              return self.$generate_alpha_channel()
              } else {
              return self.$split_image_data()
            }
            } else {
            return nil
          }
        }, TMP_PNG_split_alpha_channel$B_5.$$arity = 0);
        
        Opal.defn(self, '$alpha_channel?', TMP_PNG_alpha_channel$q_6 = function() {
          var $a, self = this;

          
          if ($truthy(($truthy($a = self.$color_type()['$=='](4)) ? $a : self.$color_type()['$=='](6)))) {
            return true};
          if (self.$color_type()['$=='](3)) {
            return self.transparency['$any?']()};
          return false;
        }, TMP_PNG_alpha_channel$q_6.$$arity = 0);
        
        Opal.defn(self, '$build_pdf_object', TMP_PNG_build_pdf_object_8 = function $$build_pdf_object(document) {
          var TMP_7, self = this, $case = nil, color = nil, obj = nil, $writer = nil, palette_obj = nil, val = nil, rgb = nil, smask_obj = nil;

          
          if ($truthy(self.$compression_method()['$!='](0))) {
            self.$fail(Opal.const_get_qualified(Opal.const_get_relative($nesting, 'Errors'), 'UnsupportedImageType'), "PNG uses an unsupported compression method".$force_encoding("ASCII-8BIT"))};
          if ($truthy(self.$filter_method()['$!='](0))) {
            self.$fail(Opal.const_get_qualified(Opal.const_get_relative($nesting, 'Errors'), 'UnsupportedImageType'), "PNG uses an unsupported filter method".$force_encoding("ASCII-8BIT"))};
          if ($truthy(self.$interlace_method()['$!='](0))) {
            self.$fail(Opal.const_get_qualified(Opal.const_get_relative($nesting, 'Errors'), 'UnsupportedImageType'), "PNG uses unsupported interlace method".$force_encoding("ASCII-8BIT"))};
          self['$split_alpha_channel!']();
          $case = self.$colors();
          if ((1)['$===']($case)) {color = "DeviceGray"}
          else if ((3)['$===']($case)) {color = "DeviceRGB"}
          else {self.$fail(Opal.const_get_qualified(Opal.const_get_relative($nesting, 'Errors'), 'UnsupportedImageType'), "" + "PNG uses an unsupported number of colors (" + (self.$png().$colors()) + ")")};
          obj = document['$ref!']($hash2(["Type", "Subtype", "Height", "Width", "BitsPerComponent"], {"Type": "XObject", "Subtype": "Image", "Height": self.$height(), "Width": self.$width(), "BitsPerComponent": self.$bits()}));
          obj['$<<'](self.$img_data());
          obj.$stream().$filters()['$<<']($hash2(["FlateDecode"], {"FlateDecode": $hash2(["Predictor", "Colors", "BitsPerComponent", "Columns"], {"Predictor": 15, "Colors": self.$colors(), "BitsPerComponent": self.$bits(), "Columns": self.$width()})}));
          if ($truthy(self.$palette()['$empty?']())) {
            
            $writer = ["ColorSpace", color];
            $send(obj.$data(), '[]=', Opal.to_a($writer));
            $writer[$rb_minus($writer["length"], 1)];
            } else {
            
            palette_obj = document['$ref!']($hash2([], {}));
            palette_obj['$<<'](self.$palette());
            
            $writer = ["ColorSpace", ["Indexed", "DeviceRGB", $rb_minus($rb_divide(self.$palette().$size(), 3), 1), palette_obj]];
            $send(obj.$data(), '[]=', Opal.to_a($writer));
            $writer[$rb_minus($writer["length"], 1)];;
          };
          if ($truthy(self.$transparency()['$[]']("grayscale"))) {
            
            val = self.$transparency()['$[]']("grayscale");
            
            $writer = ["Mask", [val, val]];
            $send(obj.$data(), '[]=', Opal.to_a($writer));
            $writer[$rb_minus($writer["length"], 1)];;
          } else if ($truthy(self.$transparency()['$[]']("rgb"))) {
            
            rgb = self.$transparency()['$[]']("rgb");
            
            $writer = ["Mask", $send(rgb, 'collect', [], (TMP_7 = function(x){var self = TMP_7.$$s || this;
if (x == null) x = nil;
            return [x, x]}, TMP_7.$$s = self, TMP_7.$$arity = 1, TMP_7)).$flatten()];
            $send(obj.$data(), '[]=', Opal.to_a($writer));
            $writer[$rb_minus($writer["length"], 1)];;};
          if ($truthy(self['$alpha_channel?']())) {
            
            smask_obj = document['$ref!']($hash2(["Type", "Subtype", "Height", "Width", "BitsPerComponent", "ColorSpace", "Decode"], {"Type": "XObject", "Subtype": "Image", "Height": self.$height(), "Width": self.$width(), "BitsPerComponent": self.$bits(), "ColorSpace": "DeviceGray", "Decode": [0, 1]}));
            smask_obj.$stream()['$<<'](self.$alpha_channel());
            smask_obj.$stream().$filters()['$<<']($hash2(["FlateDecode"], {"FlateDecode": $hash2(["Predictor", "Colors", "BitsPerComponent", "Columns"], {"Predictor": 15, "Colors": 1, "BitsPerComponent": self.$bits(), "Columns": self.$width()})}));
            
            $writer = ["SMask", smask_obj];
            $send(obj.$data(), '[]=', Opal.to_a($writer));
            $writer[$rb_minus($writer["length"], 1)];;};
          return obj;
        }, TMP_PNG_build_pdf_object_8.$$arity = 1);
        
        Opal.defn(self, '$min_pdf_version', TMP_PNG_min_pdf_version_9 = function $$min_pdf_version() {
          var self = this;

          if ($truthy($rb_gt(self.$bits(), 8))) {
            return 1.5
          } else if ($truthy(self['$alpha_channel?']())) {
            return 1.4
            } else {
            return 1.0
          }
        }, TMP_PNG_min_pdf_version_9.$$arity = 0);
        self.$private();
        
        Opal.defn(self, '$split_image_data', TMP_PNG_split_image_data_12 = function $$split_image_data() {
          var TMP_10, self = this, alpha_bytes = nil, color_bytes = nil, scanline_length = nil, scanlines = nil, pixels = nil, data = nil, color_data = nil, color = nil, alpha = nil;

          
          alpha_bytes = $rb_divide(self.$bits(), 8);
          color_bytes = $rb_divide($rb_times(self.$colors(), self.$bits()), 8);
          scanline_length = $rb_plus($rb_times($rb_plus(color_bytes, alpha_bytes), self.$width()), 1);
          scanlines = $rb_divide(self.img_data.$bytesize(), scanline_length);
          pixels = $rb_times(self.$width(), self.$height());
          data = Opal.const_get_relative($nesting, 'StringIO').$new(self.img_data);
          data.$binmode();
          color_data = $rb_times([0].$pack("C".$force_encoding("ASCII-8BIT")), $rb_plus($rb_times(pixels, color_bytes), scanlines));
          color = Opal.const_get_relative($nesting, 'StringIO').$new(color_data);
          color.$binmode();
          self.alpha_channel = $rb_times([0].$pack("C".$force_encoding("ASCII-8BIT")), $rb_plus($rb_times(pixels, alpha_bytes), scanlines));
          alpha = Opal.const_get_relative($nesting, 'StringIO').$new(self.alpha_channel);
          alpha.$binmode();
          $send(scanlines, 'times', [], (TMP_10 = function(line){var self = TMP_10.$$s || this, TMP_11, filter = nil;
if (line == null) line = nil;
          
            data.$seek($rb_times(line, scanline_length));
            filter = data.$getbyte();
            color.$putc(filter);
            alpha.$putc(filter);
            return $send(self.$width(), 'times', [], (TMP_11 = function(){var self = TMP_11.$$s || this;

            
              color.$write(data.$read(color_bytes));
              return alpha.$write(data.$read(alpha_bytes));}, TMP_11.$$s = self, TMP_11.$$arity = 0, TMP_11));}, TMP_10.$$s = self, TMP_10.$$arity = 1, TMP_10));
          return (self.img_data = color_data);
        }, TMP_PNG_split_image_data_12.$$arity = 0);
        return (Opal.defn(self, '$generate_alpha_channel', TMP_PNG_generate_alpha_channel_16 = function $$generate_alpha_channel() {
          var TMP_13, TMP_14, self = this, alpha_palette = nil, scanline_length = nil, scanlines = nil, pixels = nil, data = nil, alpha = nil;

          
          alpha_palette = Opal.const_get_relative($nesting, 'Hash').$new(255);
          $send((0), 'upto', [$rb_divide(self.$palette().$bytesize(), 3)], (TMP_13 = function(n){var self = TMP_13.$$s || this, $a, $writer = nil;
            if (self.transparency == null) self.transparency = nil;
if (n == null) n = nil;
          
            $writer = [n, ($truthy($a = self.transparency['$[]']("palette")['$[]'](n)) ? $a : 255)];
            $send(alpha_palette, '[]=', Opal.to_a($writer));
            return $writer[$rb_minus($writer["length"], 1)];}, TMP_13.$$s = self, TMP_13.$$arity = 1, TMP_13));
          scanline_length = $rb_plus(self.$width(), 1);
          scanlines = $rb_divide(self.img_data.$bytesize(), scanline_length);
          pixels = $rb_times(self.$width(), self.$height());
          data = Opal.const_get_relative($nesting, 'StringIO').$new(self.img_data);
          data.$binmode();
          self.alpha_channel = $rb_times([0].$pack("C".$force_encoding("ASCII-8BIT")), $rb_plus(pixels, scanlines));
          alpha = Opal.const_get_relative($nesting, 'StringIO').$new(self.alpha_channel);
          alpha.$binmode();
          return $send(scanlines, 'times', [], (TMP_14 = function(line){var self = TMP_14.$$s || this, TMP_15, filter = nil;
if (line == null) line = nil;
          
            data.$seek($rb_times(line, scanline_length));
            filter = data.$getbyte();
            alpha.$putc(filter);
            return $send(self.$width(), 'times', [], (TMP_15 = function(){var self = TMP_15.$$s || this, color = nil;

            
              color = data.$read(1).$unpack("C".$force_encoding("ASCII-8BIT")).$first();
              return alpha.$putc(alpha_palette['$[]'](color));}, TMP_15.$$s = self, TMP_15.$$arity = 0, TMP_15));}, TMP_14.$$s = self, TMP_14.$$arity = 1, TMP_14));
        }, TMP_PNG_generate_alpha_channel_16.$$arity = 0), nil) && 'generate_alpha_channel';
      })($nesting[0], Opal.const_get_relative($nesting, 'Image'), $nesting)
    })($nesting[0], $nesting)
  })($nesting[0], $nesting);
};

/* Generated by Opal 0.11.0 */
Opal.modules["prawn/stamp"] = function(Opal) {
  function $rb_plus(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs + rhs : lhs['$+'](rhs);
  }
  function $rb_minus(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs - rhs : lhs['$-'](rhs);
  }
  var self = Opal.top, $nesting = [], nil = Opal.nil, $breaker = Opal.breaker, $slice = Opal.slice, $module = Opal.module, $hash = Opal.hash, $send = Opal.send, $truthy = Opal.truthy, $hash2 = Opal.hash2;

  Opal.add_stubs(['$stamp_dictionary', '$add_content', '$renderer', '$update_annotation_references', '$[]', '$data', '$merge!', '$xobjects', '$page', '$state', '$translate', '$stamp', '$create_stamp_dictionary', '$stamp_stream', '$to_proc', '$private', '$+', '$length', '$stamp_dictionary_registry', '$empty?', '$fail', '$nil?', '$ref!', '$dimensions', '$next_stamp_dictionary_id', '$[]=', '$-', '$any?', '$dictionary', '$|', '$update_colors', '$write_line_width', '$write_stroke_cap_style', '$write_stroke_join_style', '$write_stroke_dash']);
  return (function($base, $parent_nesting) {
    var $Prawn, self = $Prawn = $module($base, 'Prawn');

    var def = self.$$proto, $nesting = [self].concat($parent_nesting);

    (function($base, $parent_nesting) {
      var $Stamp, self = $Stamp = $module($base, 'Stamp');

      var def = self.$$proto, $nesting = [self].concat($parent_nesting), TMP_Stamp_stamp_1, TMP_Stamp_stamp_at_3, TMP_Stamp_create_stamp_4, TMP_Stamp_stamp_dictionary_registry_5, TMP_Stamp_next_stamp_dictionary_id_6, TMP_Stamp_stamp_dictionary_7, TMP_Stamp_create_stamp_dictionary_8, TMP_Stamp_update_annotation_references_9, TMP_Stamp_freeze_stamp_graphics_10;

      
      
      Opal.defn(self, '$stamp', TMP_Stamp_stamp_1 = function $$stamp(name) {
        var $a, $b, self = this, dictionary_name = nil, dictionary = nil;

        
        $b = self.$stamp_dictionary(name), $a = Opal.to_ary($b), (dictionary_name = ($a[0] == null ? nil : $a[0])), (dictionary = ($a[1] == null ? nil : $a[1])), $b;
        self.$renderer().$add_content("" + "/" + (dictionary_name) + " Do");
        self.$update_annotation_references(dictionary.$data()['$[]']("Annots"));
        return self.$state().$page().$xobjects()['$merge!']($hash(dictionary_name, dictionary));
      }, TMP_Stamp_stamp_1.$$arity = 1);
      
      Opal.defn(self, '$stamp_at', TMP_Stamp_stamp_at_3 = function $$stamp_at(name, point) {
        var TMP_2, self = this;

        return $send(self, 'translate', [point['$[]'](0), point['$[]'](1)], (TMP_2 = function(){var self = TMP_2.$$s || this;

        return self.$stamp(name)}, TMP_2.$$s = self, TMP_2.$$arity = 0, TMP_2))
      }, TMP_Stamp_stamp_at_3.$$arity = 2);
      
      Opal.defn(self, '$create_stamp', TMP_Stamp_create_stamp_4 = function $$create_stamp(name) {
        var self = this, $iter = TMP_Stamp_create_stamp_4.$$p, block = $iter || nil, dictionary = nil;

        if ($iter) TMP_Stamp_create_stamp_4.$$p = null;
        
        dictionary = self.$create_stamp_dictionary(name);
        return $send(self.$state().$page(), 'stamp_stream', [dictionary], block.$to_proc());
      }, TMP_Stamp_create_stamp_4.$$arity = 1);
      self.$private();
      
      Opal.defn(self, '$stamp_dictionary_registry', TMP_Stamp_stamp_dictionary_registry_5 = function $$stamp_dictionary_registry() {
        var $a, self = this;
        if (self.stamp_dictionary_registry == null) self.stamp_dictionary_registry = nil;

        return (self.stamp_dictionary_registry = ($truthy($a = self.stamp_dictionary_registry) ? $a : $hash2([], {})))
      }, TMP_Stamp_stamp_dictionary_registry_5.$$arity = 0);
      
      Opal.defn(self, '$next_stamp_dictionary_id', TMP_Stamp_next_stamp_dictionary_id_6 = function $$next_stamp_dictionary_id() {
        var self = this;

        return $rb_plus(self.$stamp_dictionary_registry().$length(), 1)
      }, TMP_Stamp_next_stamp_dictionary_id_6.$$arity = 0);
      
      Opal.defn(self, '$stamp_dictionary', TMP_Stamp_stamp_dictionary_7 = function $$stamp_dictionary(name) {
        var self = this, dict = nil, dictionary_name = nil, dictionary = nil;

        
        if ($truthy(name['$empty?']())) {
          self.$fail(Opal.const_get_qualified(Opal.const_get_qualified(Opal.const_get_relative($nesting, 'Prawn'), 'Errors'), 'InvalidName'))};
        if ($truthy(self.$stamp_dictionary_registry()['$[]'](name)['$nil?']())) {
          self.$fail(Opal.const_get_qualified(Opal.const_get_qualified(Opal.const_get_relative($nesting, 'Prawn'), 'Errors'), 'UndefinedObjectName'))};
        dict = self.$stamp_dictionary_registry()['$[]'](name);
        dictionary_name = dict['$[]']("stamp_dictionary_name");
        dictionary = dict['$[]']("stamp_dictionary");
        return [dictionary_name, dictionary];
      }, TMP_Stamp_stamp_dictionary_7.$$arity = 1);
      
      Opal.defn(self, '$create_stamp_dictionary', TMP_Stamp_create_stamp_dictionary_8 = function $$create_stamp_dictionary(name) {
        var self = this, dictionary = nil, dictionary_name = nil, $writer = nil;

        
        if ($truthy(name['$empty?']())) {
          self.$fail(Opal.const_get_qualified(Opal.const_get_qualified(Opal.const_get_relative($nesting, 'Prawn'), 'Errors'), 'InvalidName'))};
        if ($truthy(self.$stamp_dictionary_registry()['$[]'](name)['$nil?']())) {
          } else {
          self.$fail(Opal.const_get_qualified(Opal.const_get_qualified(Opal.const_get_relative($nesting, 'Prawn'), 'Errors'), 'NameTaken'))
        };
        dictionary = self['$ref!']($hash2(["Type", "Subtype", "BBox"], {"Type": "XObject", "Subtype": "Form", "BBox": [0, 0, self.$state().$page().$dimensions()['$[]'](2), self.$state().$page().$dimensions()['$[]'](3)]}));
        dictionary_name = "" + "Stamp" + (self.$next_stamp_dictionary_id());
        
        $writer = [name, $hash2(["stamp_dictionary_name", "stamp_dictionary"], {"stamp_dictionary_name": dictionary_name, "stamp_dictionary": dictionary})];
        $send(self.$stamp_dictionary_registry(), '[]=', Opal.to_a($writer));
        $writer[$rb_minus($writer["length"], 1)];;
        return dictionary;
      }, TMP_Stamp_create_stamp_dictionary_8.$$arity = 1);
      
      Opal.defn(self, '$update_annotation_references', TMP_Stamp_update_annotation_references_9 = function $$update_annotation_references(annots) {
        var $a, self = this, $logical_op_recvr_tmp_10 = nil, $writer = nil, $binary_op_recvr_tmp_2 = nil;

        if ($truthy(($truthy($a = annots) ? annots['$any?']() : $a))) {
          
          
          $logical_op_recvr_tmp_10 = self.$state().$page().$dictionary().$data();
          ($truthy($a = $logical_op_recvr_tmp_10['$[]']("Annots")) ? $a : (($writer = ["Annots", []]), $send($logical_op_recvr_tmp_10, '[]=', Opal.to_a($writer)), $writer[$rb_minus($writer["length"], 1)]));;
          
          $binary_op_recvr_tmp_2 = self.$state().$page().$dictionary().$data();
          
          $writer = ["Annots", $binary_op_recvr_tmp_2['$[]']("Annots")['$|'](annots)];
          $send($binary_op_recvr_tmp_2, '[]=', Opal.to_a($writer));
          return $writer[$rb_minus($writer["length"], 1)];;;
          } else {
          return nil
        }
      }, TMP_Stamp_update_annotation_references_9.$$arity = 1);
      
      Opal.defn(self, '$freeze_stamp_graphics', TMP_Stamp_freeze_stamp_graphics_10 = function $$freeze_stamp_graphics() {
        var self = this;

        
        self.$update_colors();
        self.$write_line_width();
        self.$write_stroke_cap_style();
        self.$write_stroke_join_style();
        return self.$write_stroke_dash();
      }, TMP_Stamp_freeze_stamp_graphics_10.$$arity = 0);
    })($nesting[0], $nesting)
  })($nesting[0], $nesting)
};

/* Generated by Opal 0.11.0 */
Opal.modules["prawn/soft_mask"] = function(Opal) {
  function $rb_minus(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs - rhs : lhs['$-'](rhs);
  }
  var self = Opal.top, $nesting = [], nil = Opal.nil, $breaker = Opal.breaker, $slice = Opal.slice, $module = Opal.module, $hash2 = Opal.hash2, $send = Opal.send, $truthy = Opal.truthy;

  Opal.add_stubs(['$min_version', '$renderer', '$ref!', '$dimensions', '$page', '$state', '$stamp_stream', '$to_proc', '$hash', '$normalized', '$filters', '$stream', '$filtered_stream', '$page_count', '$[]', '$soft_mask_registry', '$add_content', '$resources', '$[]=', '$-', '$empty?', '$succ', '$last', '$sort', '$keys', '$private']);
  return (function($base, $parent_nesting) {
    var $Prawn, self = $Prawn = $module($base, 'Prawn');

    var def = self.$$proto, $nesting = [self].concat($parent_nesting);

    (function($base, $parent_nesting) {
      var $SoftMask, self = $SoftMask = $module($base, 'SoftMask');

      var def = self.$$proto, $nesting = [self].concat($parent_nesting), TMP_SoftMask_soft_mask_1, TMP_SoftMask_soft_mask_registry_2;

      
      
      Opal.defn(self, '$soft_mask', TMP_SoftMask_soft_mask_1 = function $$soft_mask() {
        var $a, self = this, $iter = TMP_SoftMask_soft_mask_1.$$p, block = $iter || nil, group_attrs = nil, group = nil, mask = nil, g_state = nil, registry_key = nil, masks = nil, $logical_op_recvr_tmp_11 = nil, $writer = nil, id = nil;

        if ($iter) TMP_SoftMask_soft_mask_1.$$p = null;
        
        self.$renderer().$min_version(1.4);
        group_attrs = self['$ref!']($hash2(["Type", "S", "CS", "I", "K"], {"Type": "Group", "S": "Transparency", "CS": "DeviceRGB", "I": false, "K": false}));
        group = self['$ref!']($hash2(["Type", "Subtype", "BBox", "Group"], {"Type": "XObject", "Subtype": "Form", "BBox": self.$state().$page().$dimensions(), "Group": group_attrs}));
        $send(self.$state().$page(), 'stamp_stream', [group], block.$to_proc());
        mask = self['$ref!']($hash2(["Type", "S", "G"], {"Type": "Mask", "S": "Luminosity", "G": group}));
        g_state = self['$ref!']($hash2(["Type", "SMask", "AIS", "BM", "OP", "op", "OPM", "SA"], {"Type": "ExtGState", "SMask": mask, "AIS": false, "BM": "Normal", "OP": false, "op": false, "OPM": 1, "SA": true}));
        registry_key = $hash2(["bbox", "mask", "page"], {"bbox": self.$state().$page().$dimensions(), "mask": [group.$stream().$filters().$normalized(), group.$stream().$filtered_stream()], "page": self.$state().$page_count()}).$hash();
        if ($truthy(self.$soft_mask_registry()['$[]'](registry_key))) {
          return self.$renderer().$add_content("" + "/" + (self.$soft_mask_registry()['$[]'](registry_key)) + " gs")
          } else {
          
          masks = (($logical_op_recvr_tmp_11 = self.$page().$resources()), ($truthy($a = $logical_op_recvr_tmp_11['$[]']("ExtGState")) ? $a : (($writer = ["ExtGState", $hash2([], {})]), $send($logical_op_recvr_tmp_11, '[]=', Opal.to_a($writer)), $writer[$rb_minus($writer["length"], 1)])));
          id = (function() {if ($truthy(masks['$empty?']())) {
            return "GS1"
            } else {
            return masks.$keys().$sort().$last().$succ()
          }; return nil; })();
          
          $writer = [id, g_state];
          $send(masks, '[]=', Opal.to_a($writer));
          $writer[$rb_minus($writer["length"], 1)];;
          
          $writer = [registry_key, id];
          $send(self.$soft_mask_registry(), '[]=', Opal.to_a($writer));
          $writer[$rb_minus($writer["length"], 1)];;
          return self.$renderer().$add_content("" + "/" + (id) + " gs");
        };
      }, TMP_SoftMask_soft_mask_1.$$arity = 0);
      self.$private();
      
      Opal.defn(self, '$soft_mask_registry', TMP_SoftMask_soft_mask_registry_2 = function $$soft_mask_registry() {
        var $a, self = this;
        if (self.soft_mask_registry == null) self.soft_mask_registry = nil;

        return (self.soft_mask_registry = ($truthy($a = self.soft_mask_registry) ? $a : $hash2([], {})))
      }, TMP_SoftMask_soft_mask_registry_2.$$arity = 0);
    })($nesting[0], $nesting)
  })($nesting[0], $nesting)
};

/* Generated by Opal 0.11.0 */
Opal.modules["digest/md5"] = function(Opal) {
  var self = Opal.top, $nesting = [], nil = Opal.nil, $breaker = Opal.breaker, $slice = Opal.slice, $module = Opal.module;

  return (function($base, $parent_nesting) {
    var $Digest, self = $Digest = $module($base, 'Digest');

    var def = self.$$proto, $nesting = [self].concat($parent_nesting);

    (function($base, $parent_nesting) {
      var $MD5, self = $MD5 = $module($base, 'MD5');

      var def = self.$$proto, $nesting = [self].concat($parent_nesting);

      nil
    })($nesting[0], $nesting)
  })($nesting[0], $nesting)
};

/* Generated by Opal 0.11.0 */
Opal.modules["prawn/security/arcfour"] = function(Opal) {
  function $rb_lt(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs < rhs : lhs['$<'](rhs);
  }
  function $rb_plus(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs + rhs : lhs['$+'](rhs);
  }
  var self = Opal.top, $nesting = [], nil = Opal.nil, $breaker = Opal.breaker, $slice = Opal.slice, $klass = Opal.klass, $truthy = Opal.truthy, $range = Opal.range, $send = Opal.send;

  Opal.add_stubs(['$is_a?', '$unpack', '$to_a', '$<', '$length', '$+', '$[]', '$each', '$%', '$[]=', '$pack', '$map', '$^', '$key_byte', '$private']);
  return (function($base, $super, $parent_nesting) {
    function $Arcfour(){};
    var self = $Arcfour = $klass($base, $super, 'Arcfour', $Arcfour);

    var def = self.$$proto, $nesting = [self].concat($parent_nesting), TMP_Arcfour_initialize_2, TMP_Arcfour_encrypt_4, TMP_Arcfour_key_byte_5;

    def.i = def.j = def.sbox = nil;
    
    
    Opal.defn(self, '$initialize', TMP_Arcfour_initialize_2 = function $$initialize(key) {
      var $a, TMP_1, self = this, s2 = nil, j = nil;

      
      if ($truthy(key['$is_a?'](Opal.const_get_relative($nesting, 'String')))) {
        key = key.$unpack("c*")};
      self.sbox = $range(0, 255, false).$to_a();
      s2 = [];
      while ($truthy($rb_lt(s2.$length(), 256))) {
        s2 = $rb_plus(s2, key)
      };
      s2 = s2['$[]'](0, 256);
      j = 0;
      $send($range(0, 255, false), 'each', [], (TMP_1 = function(i){var self = TMP_1.$$s || this, $b;
        if (self.sbox == null) self.sbox = nil;
if (i == null) i = nil;
      
        j = $rb_plus($rb_plus(j, self.sbox['$[]'](i)), s2['$[]'](i))['$%'](256);
        return $b = [self.sbox['$[]'](j), self.sbox['$[]'](i)], self.sbox['$[]='](i, $b[0]), self.sbox['$[]='](j, $b[1]), $b;}, TMP_1.$$s = self, TMP_1.$$arity = 1, TMP_1));
      return (self.i = (self.j = 0));
    }, TMP_Arcfour_initialize_2.$$arity = 1);
    
    Opal.defn(self, '$encrypt', TMP_Arcfour_encrypt_4 = function $$encrypt(string) {
      var TMP_3, self = this;

      return $send(string.$unpack("c*"), 'map', [], (TMP_3 = function(byte$){var self = TMP_3.$$s || this;
if (byte$ == null) byte$ = nil;
      return byte$['$^'](self.$key_byte())}, TMP_3.$$s = self, TMP_3.$$arity = 1, TMP_3)).$pack("c*")
    }, TMP_Arcfour_encrypt_4.$$arity = 1);
    self.$private();
    return (Opal.defn(self, '$key_byte', TMP_Arcfour_key_byte_5 = function $$key_byte() {
      var $a, self = this;

      
      self.i = $rb_plus(self.i, 1)['$%'](256);
      self.j = $rb_plus(self.j, self.sbox['$[]'](self.i))['$%'](256);
      $a = [self.sbox['$[]'](self.j), self.sbox['$[]'](self.i)], self.sbox['$[]='](self.i, $a[0]), self.sbox['$[]='](self.j, $a[1]), $a;
      return self.sbox['$[]']($rb_plus(self.sbox['$[]'](self.i), self.sbox['$[]'](self.j))['$%'](256));
    }, TMP_Arcfour_key_byte_5.$$arity = 0), nil) && 'key_byte';
  })($nesting[0], null, $nesting)
};

/* Generated by Opal 0.11.0 */
Opal.modules["prawn/security"] = function(Opal) {
  function $rb_minus(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs - rhs : lhs['$-'](rhs);
  }
  function $rb_plus(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs + rhs : lhs['$+'](rhs);
  }
  var self = Opal.top, $nesting = [], nil = Opal.nil, $breaker = Opal.breaker, $slice = Opal.slice, $module = Opal.module, $klass = Opal.klass, $truthy = Opal.truthy, $send = Opal.send, $range = Opal.range, $hash2 = Opal.hash2;

  Opal.add_stubs(['$require', '$verify_options', '$delete', '$==', '$pack', '$map', '$rand', '$permissions=', '$-', '$encryption_dictionary', '$[]=', '$trailer', '$state', '$encrypt=', '$user_encryption_key', '$encryption_key=', '$[]', '$digest', '$encrypt', '$new', '$private', '$owner_password_hash', '$user_password_hash', '$permissions_value', '$each', '$fail', '$+', '$join', '$keys', '$to_proc', '$|', '$<<', '$&', '$~', '$scan', '$to_i', '$length', '$pad_password', '$module_function', '$===', '$EncryptedPdfObject', '$gsub', '$encrypt_string', '$chop', '$strftime', '$PdfObject', '$to_sym', '$name', '$value', '$to_hash', '$filtered_stream', '$call', '$gen', '$empty?', '$data', '$merge', '$encrypted_object']);
  
  self.$require("digest/md5");
  self.$require("pdf/core/byte_string");
  self.$require("prawn/security"+ '/../' + "security/arcfour");
  (function($base, $parent_nesting) {
    var $Prawn, self = $Prawn = $module($base, 'Prawn');

    var def = self.$$proto, $nesting = [self].concat($parent_nesting);

    (function($base, $super, $parent_nesting) {
      function $Document(){};
      var self = $Document = $klass($base, $super, 'Document', $Document);

      var def = self.$$proto, $nesting = [self].concat($parent_nesting);

      return (function($base, $parent_nesting) {
        var $Security, self = $Security = $module($base, 'Security');

        var def = self.$$proto, $nesting = [self].concat($parent_nesting), TMP_Security_encrypt_document_2, TMP_Security_encrypt_string_3, TMP_Security_encryption_dictionary_4, TMP_Security_permissions$eq_6, TMP_Security_permissions_value_7, TMP_Security_8, TMP_Security_pad_password_9, TMP_Security_user_encryption_key_10, TMP_Security_owner_password_hash_11, TMP_Security_user_password_hash_12;

        
        
        Opal.defn(self, '$encrypt_document', TMP_Security_encrypt_document_2 = function $$encrypt_document(options) {
          var $a, TMP_1, self = this, $writer = nil;
          if (self.user_password == null) self.user_password = nil;
          if (self.owner_password == null) self.owner_password = nil;

          if (options == null) {
            options = $hash2([], {});
          }
          
          Opal.const_get_relative($nesting, 'Prawn').$verify_options(["user_password", "owner_password", "permissions"], options);
          self.user_password = ($truthy($a = options.$delete("user_password")) ? $a : "");
          self.owner_password = ($truthy($a = options.$delete("owner_password")) ? $a : self.user_password);
          if (self.owner_password['$==']("random")) {
            self.owner_password = $send($range(1, 32, false), 'map', [], (TMP_1 = function(){var self = TMP_1.$$s || this;

            return self.$rand(256)}, TMP_1.$$s = self, TMP_1.$$arity = 0, TMP_1)).$pack("c*")};
          
          $writer = [($truthy($a = options.$delete("permissions")) ? $a : $hash2([], {}))];
          $send(self, 'permissions=', Opal.to_a($writer));
          $writer[$rb_minus($writer["length"], 1)];;
          
          $writer = ["Encrypt", self.$encryption_dictionary()];
          $send(self.$state().$trailer(), '[]=', Opal.to_a($writer));
          $writer[$rb_minus($writer["length"], 1)];;
          
          $writer = [true];
          $send(self.$state(), 'encrypt=', Opal.to_a($writer));
          $writer[$rb_minus($writer["length"], 1)];;
          
          $writer = [self.$user_encryption_key()];
          $send(self.$state(), 'encryption_key=', Opal.to_a($writer));
          return $writer[$rb_minus($writer["length"], 1)];;
        }, TMP_Security_encrypt_document_2.$$arity = -1);
        Opal.defs(self, '$encrypt_string', TMP_Security_encrypt_string_3 = function $$encrypt_string(str, key, id, gen) {
          var self = this, extended_key = nil, rc4_key = nil;

          
          id = [id].$pack("V")['$[]'](0, 3);
          gen = [gen].$pack("V")['$[]'](0, 2);
          extended_key = "" + (key) + (id) + (gen);
          rc4_key = Opal.const_get_qualified(Opal.const_get_relative($nesting, 'Digest'), 'MD5').$digest(extended_key)['$[]'](0, 10);
          return Opal.const_get_relative($nesting, 'Arcfour').$new(rc4_key).$encrypt(str);
        }, TMP_Security_encrypt_string_3.$$arity = 4);
        self.$private();
        
        Opal.defn(self, '$encryption_dictionary', TMP_Security_encryption_dictionary_4 = function $$encryption_dictionary() {
          var self = this;

          return $hash2(["Filter", "V", "R", "O", "U", "P"], {"Filter": "Standard", "V": 1, "R": 2, "O": Opal.const_get_qualified(Opal.const_get_qualified(Opal.const_get_relative($nesting, 'PDF'), 'Core'), 'ByteString').$new(self.$owner_password_hash()), "U": Opal.const_get_qualified(Opal.const_get_qualified(Opal.const_get_relative($nesting, 'PDF'), 'Core'), 'ByteString').$new(self.$user_password_hash()), "P": self.$permissions_value()})
        }, TMP_Security_encryption_dictionary_4.$$arity = 0);
        Opal.const_set($nesting[0], 'PermissionsBits', $hash2(["print_document", "modify_contents", "copy_contents", "modify_annotations"], {"print_document": 3, "modify_contents": 4, "copy_contents": 5, "modify_annotations": 6}));
        Opal.const_set($nesting[0], 'FullPermissions', 4294967295);
        
        Opal.defn(self, '$permissions=', TMP_Security_permissions$eq_6 = function(perms) {
          var $a, TMP_5, self = this;
          if (self.permissions == null) self.permissions = nil;

          if (perms == null) {
            perms = $hash2([], {});
          }
          
          self.permissions = ($truthy($a = self.permissions) ? $a : Opal.const_get_relative($nesting, 'FullPermissions'));
          return $send(perms, 'each', [], (TMP_5 = function(key, value){var self = TMP_5.$$s || this, bit_position = nil;
            if (self.permissions == null) self.permissions = nil;
if (key == null) key = nil;if (value == null) value = nil;
          
            if ($truthy(Opal.const_get_relative($nesting, 'PermissionsBits')['$[]'](key))) {
              } else {
              self.$fail(Opal.const_get_relative($nesting, 'ArgumentError'), $rb_plus("" + "Unknown permission :" + (key) + ". Valid options: ", $send(Opal.const_get_relative($nesting, 'PermissionsBits').$keys(), 'map', [], "inspect".$to_proc()).$join(", ")))
            };
            bit_position = $rb_minus(Opal.const_get_relative($nesting, 'PermissionsBits')['$[]'](key), 1);
            if ($truthy(value)) {
              return (self.permissions = self.permissions['$|']((1)['$<<'](bit_position)))
              } else {
              return (self.permissions = self.permissions['$&']((1)['$<<'](bit_position)['$~']()))
            };}, TMP_5.$$s = self, TMP_5.$$arity = 2, TMP_5));
        }, TMP_Security_permissions$eq_6.$$arity = -1);
        
        Opal.defn(self, '$permissions_value', TMP_Security_permissions_value_7 = function $$permissions_value() {
          var $a, self = this;
          if (self.permissions == null) self.permissions = nil;

          return ($truthy($a = self.permissions) ? $a : Opal.const_get_relative($nesting, 'FullPermissions'))
        }, TMP_Security_permissions_value_7.$$arity = 0);
        Opal.const_set($nesting[0], 'PasswordPadding', $send("28BF4E5E4E758A4164004E56FFFA01082E2E00B6D0683E802F0CA9FE6453697A".$scan(/../), 'map', [], (TMP_Security_8 = function(x){var self = TMP_Security_8.$$s || this;
if (x == null) x = nil;
        return x.$to_i(16)}, TMP_Security_8.$$s = self, TMP_Security_8.$$arity = 1, TMP_Security_8)).$pack("c*"));
        
        Opal.defn(self, '$pad_password', TMP_Security_pad_password_9 = function $$pad_password(password) {
          var self = this;

          
          password = password['$[]'](0, 32);
          return $rb_plus(password, Opal.const_get_relative($nesting, 'PasswordPadding')['$[]'](0, $rb_minus(32, password.$length())));
        }, TMP_Security_pad_password_9.$$arity = 1);
        
        Opal.defn(self, '$user_encryption_key', TMP_Security_user_encryption_key_10 = function $$user_encryption_key() {
          var $a, self = this, md5 = nil;
          if (self.user_encryption_key == null) self.user_encryption_key = nil;
          if (self.user_password == null) self.user_password = nil;

          return (self.user_encryption_key = ($truthy($a = self.user_encryption_key) ? $a : ((md5 = Opal.const_get_qualified(Opal.const_get_relative($nesting, 'Digest'), 'MD5').$new()), md5['$<<'](self.$pad_password(self.user_password)), md5['$<<'](self.$owner_password_hash()), md5['$<<']([self.$permissions_value()].$pack("V")), md5.$digest()['$[]'](0, 5))))
        }, TMP_Security_user_encryption_key_10.$$arity = 0);
        
        Opal.defn(self, '$owner_password_hash', TMP_Security_owner_password_hash_11 = function $$owner_password_hash() {
          var $a, self = this, key = nil;
          if (self.owner_password_hash == null) self.owner_password_hash = nil;
          if (self.owner_password == null) self.owner_password = nil;
          if (self.user_password == null) self.user_password = nil;

          return (self.owner_password_hash = ($truthy($a = self.owner_password_hash) ? $a : ((key = Opal.const_get_qualified(Opal.const_get_relative($nesting, 'Digest'), 'MD5').$digest(self.$pad_password(self.owner_password))['$[]'](0, 5)), Opal.const_get_relative($nesting, 'Arcfour').$new(key).$encrypt(self.$pad_password(self.user_password)))))
        }, TMP_Security_owner_password_hash_11.$$arity = 0);
        
        Opal.defn(self, '$user_password_hash', TMP_Security_user_password_hash_12 = function $$user_password_hash() {
          var self = this;

          return Opal.const_get_relative($nesting, 'Arcfour').$new(self.$user_encryption_key()).$encrypt(Opal.const_get_relative($nesting, 'PasswordPadding'))
        }, TMP_Security_user_password_hash_12.$$arity = 0);
      })($nesting[0], $nesting)
    })($nesting[0], null, $nesting)
  })($nesting[0], $nesting);
  return (function($base, $parent_nesting) {
    var $PDF, self = $PDF = $module($base, 'PDF');

    var def = self.$$proto, $nesting = [self].concat($parent_nesting);

    (function($base, $parent_nesting) {
      var $Core, self = $Core = $module($base, 'Core');

      var def = self.$$proto, $nesting = [self].concat($parent_nesting), TMP_Core_EncryptedPdfObject_17;

      
      self.$module_function();
      
      Opal.defn(self, '$EncryptedPdfObject', TMP_Core_EncryptedPdfObject_17 = function $$EncryptedPdfObject(obj, key, id, gen, in_content_stream) {
        var TMP_13, TMP_14, TMP_15, TMP_16, self = this, $case = nil, output = nil;

        if (in_content_stream == null) {
          in_content_stream = false;
        }
        return (function() {$case = obj;
        if (Opal.const_get_relative($nesting, 'Array')['$===']($case)) {return "["['$<<']($send(obj, 'map', [], (TMP_13 = function(e){var self = TMP_13.$$s || this;
if (e == null) e = nil;
        return self.$EncryptedPdfObject(e, key, id, gen, in_content_stream)}, TMP_13.$$s = self, TMP_13.$$arity = 1, TMP_13)).$join(" "))['$<<']("]")}
        else if (Opal.const_get_relative($nesting, 'LiteralString')['$===']($case)) {
        obj = $send(Opal.const_get_relative($nesting, 'ByteString').$new(Opal.const_get_qualified(Opal.const_get_qualified(Opal.const_get_relative($nesting, 'Prawn'), 'Document'), 'Security').$encrypt_string(obj, key, id, gen)), 'gsub', [/[\\\n\(\)]/], (TMP_14 = function(m){var self = TMP_14.$$s || this;
if (m == null) m = nil;
        return "" + "\\" + (m)}, TMP_14.$$s = self, TMP_14.$$arity = 1, TMP_14));
        return "" + "(" + (obj) + ")";}
        else if (Opal.const_get_relative($nesting, 'Time')['$===']($case)) {
        obj = $rb_plus(obj.$strftime("D:%Y%m%d%H%M%S%z").$chop().$chop(), "'00'");
        obj = $send(Opal.const_get_relative($nesting, 'ByteString').$new(Opal.const_get_qualified(Opal.const_get_qualified(Opal.const_get_relative($nesting, 'Prawn'), 'Document'), 'Security').$encrypt_string(obj, key, id, gen)), 'gsub', [/[\\\n\(\)]/], (TMP_15 = function(m){var self = TMP_15.$$s || this;
if (m == null) m = nil;
        return "" + "\\" + (m)}, TMP_15.$$s = self, TMP_15.$$arity = 1, TMP_15));
        return "" + "(" + (obj) + ")";}
        else if (Opal.const_get_relative($nesting, 'String')['$===']($case)) {return self.$PdfObject(Opal.const_get_relative($nesting, 'ByteString').$new(Opal.const_get_qualified(Opal.const_get_qualified(Opal.const_get_relative($nesting, 'Prawn'), 'Document'), 'Security').$encrypt_string(obj, key, id, gen)), in_content_stream)}
        else if (Opal.const_get_qualified('::', 'Hash')['$===']($case)) {
        output = "<< ";
        $send(obj, 'each', [], (TMP_16 = function(k, v){var self = TMP_16.$$s || this, $a;
if (k == null) k = nil;if (v == null) v = nil;
        
          if ($truthy(($truthy($a = Opal.const_get_relative($nesting, 'String')['$==='](k)) ? $a : Opal.const_get_relative($nesting, 'Symbol')['$==='](k)))) {
            } else {
            self.$fail(Opal.const_get_qualified(Opal.const_get_qualified(Opal.const_get_qualified(Opal.const_get_relative($nesting, 'PDF'), 'Core'), 'Errors'), 'FailedObjectConversion'), "A PDF Dictionary must be keyed by names")
          };
          return output['$<<'](self.$PdfObject(k.$to_sym(), in_content_stream))['$<<'](" ")['$<<'](self.$EncryptedPdfObject(v, key, id, gen, in_content_stream))['$<<']("\n");}, TMP_16.$$s = self, TMP_16.$$arity = 2, TMP_16));
        return output['$<<'](">>");}
        else if (Opal.const_get_qualified(Opal.const_get_relative($nesting, 'NameTree'), 'Value')['$===']($case)) {return $rb_plus($rb_plus(self.$PdfObject(obj.$name()), " "), self.$EncryptedPdfObject(obj.$value(), key, id, gen, in_content_stream))}
        else if (Opal.const_get_qualified(Opal.const_get_qualified(Opal.const_get_relative($nesting, 'PDF'), 'Core'), 'OutlineRoot')['$===']($case) || Opal.const_get_qualified(Opal.const_get_qualified(Opal.const_get_relative($nesting, 'PDF'), 'Core'), 'OutlineItem')['$===']($case)) {return self.$EncryptedPdfObject(obj.$to_hash(), key, id, gen, in_content_stream)}
        else {return self.$PdfObject(obj, in_content_stream)}})()
      }, TMP_Core_EncryptedPdfObject_17.$$arity = -5);
      (function($base, $super, $parent_nesting) {
        function $Stream(){};
        var self = $Stream = $klass($base, $super, 'Stream', $Stream);

        var def = self.$$proto, $nesting = [self].concat($parent_nesting), TMP_Stream_encrypted_object_18;

        return (Opal.defn(self, '$encrypted_object', TMP_Stream_encrypted_object_18 = function $$encrypted_object(key, id, gen) {
          var self = this;

          if ($truthy(self.$filtered_stream())) {
            return "" + "stream\n" + (Opal.const_get_qualified(Opal.const_get_qualified(Opal.const_get_relative($nesting, 'Prawn'), 'Document'), 'Security').$encrypt_string(self.$filtered_stream(), key, id, gen)) + "\nendstream\n"
            } else {
            return ""
          }
        }, TMP_Stream_encrypted_object_18.$$arity = 3), nil) && 'encrypted_object'
      })($nesting[0], null, $nesting);
      (function($base, $super, $parent_nesting) {
        function $Reference(){};
        var self = $Reference = $klass($base, $super, 'Reference', $Reference);

        var def = self.$$proto, $nesting = [self].concat($parent_nesting), TMP_Reference_encrypted_object_19;

        def.on_encode = def.identifier = def.stream = nil;
        return (Opal.defn(self, '$encrypted_object', TMP_Reference_encrypted_object_19 = function $$encrypted_object(key) {
          var self = this, output = nil;

          
          if ($truthy(self.on_encode)) {
            self.on_encode.$call(self)};
          output = "" + (self.identifier) + " " + (self.$gen()) + " obj\n";
          if ($truthy(self.stream['$empty?']())) {
            output['$<<'](Opal.const_get_qualified(Opal.const_get_relative($nesting, 'PDF'), 'Core').$EncryptedPdfObject(self.$data(), key, self.identifier, self.$gen()))['$<<']("\n")
            } else {
            output['$<<'](Opal.const_get_qualified(Opal.const_get_relative($nesting, 'PDF'), 'Core').$EncryptedPdfObject(self.$data().$merge(self.stream.$data()), key, self.identifier, self.$gen()))['$<<']("\n")['$<<'](self.stream.$encrypted_object(key, self.identifier, self.$gen()))
          };
          return output['$<<']("endobj\n");
        }, TMP_Reference_encrypted_object_19.$$arity = 1), nil) && 'encrypted_object'
      })($nesting[0], null, $nesting);
    })($nesting[0], $nesting)
  })($nesting[0], $nesting);
};

/* Generated by Opal 0.11.0 */
Opal.modules["matrix"] = function(Opal) {
  var self = Opal.top, $nesting = [], nil = Opal.nil, $breaker = Opal.breaker, $slice = Opal.slice;

  Opal.add_stubs(['$raise']);
  return self.$raise(Opal.const_get_relative($nesting, 'LoadError'), "can't find file: \"matrix\" in:\n- /home/guillaume/.rvm/gems/ruby-2.4.1@prawn.js/gems/opal-0.11.0/opal\n- /home/guillaume/.rvm/gems/ruby-2.4.1@prawn.js/gems/opal-0.11.0/stdlib\n- /home/guillaume/.rvm/gems/ruby-2.4.1@prawn.js/gems/opal-0.11.0/lib\n- /home/guillaume/.rvm/gems/ruby-2.4.1@prawn.js/gems/ast-2.3.0/lib\n- /home/guillaume/.rvm/gems/ruby-2.4.1@prawn.js/gems/ast-2.3.0/lib\n- /home/guillaume/.rvm/gems/ruby-2.4.1@prawn.js/gems/parser-2.3.3.1/lib\n- /home/guillaume/workspace/opensource/prawn.js/lib\n- /home/guillaume/workspace/opensource/prawn.js/lib/prawn\n- /home/guillaume/workspace/opensource/prawn.js/build/prawn/lib\n- /home/guillaume/workspace/opensource/prawn.js/build/ttfunk/lib\n- /home/guillaume/workspace/opensource/prawn.js/build/pdf-core/lib\n\nWith the following extensions:\n- .js\n- .js.js\n- .rb\n- .js.rb\n- .opal\n- .js.opal\n- .opalerb\n- .js.opalerb\n- .erb\n- .js.erb\n\nAnd the following processors:\n- Opal::BuilderProcessors::JsProcessor\n- Opal::BuilderProcessors::RubyProcessor\n- Opal::BuilderProcessors::OpalERBProcessor\n- Opal::BuilderProcessors::ERBProcessor\n")
};

/* Generated by Opal 0.11.0 */
Opal.modules["prawn/transformation_stack"] = function(Opal) {
  function $rb_times(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs * rhs : lhs['$*'](rhs);
  }
  var self = Opal.top, $nesting = [], nil = Opal.nil, $breaker = Opal.breaker, $slice = Opal.slice, $module = Opal.module, $truthy = Opal.truthy, $send = Opal.send, $range = Opal.range;

  Opal.add_stubs(['$require', '$push', '$last', '$map', '$to_proc', '$dup', '$pop', '$identity', '$each', '$*', '$[]', '$flatten', '$transpose', '$to_a']);
  
  self.$require("matrix");
  return (function($base, $parent_nesting) {
    var $Prawn, self = $Prawn = $module($base, 'Prawn');

    var def = self.$$proto, $nesting = [self].concat($parent_nesting);

    (function($base, $parent_nesting) {
      var $TransformationStack, self = $TransformationStack = $module($base, 'TransformationStack');

      var def = self.$$proto, $nesting = [self].concat($parent_nesting), TMP_TransformationStack_add_to_transformation_stack_1, TMP_TransformationStack_save_transformation_stack_2, TMP_TransformationStack_restore_transformation_stack_3, TMP_TransformationStack_current_transformation_matrix_with_translation_5;

      
      
      Opal.defn(self, '$add_to_transformation_stack', TMP_TransformationStack_add_to_transformation_stack_1 = function $$add_to_transformation_stack(a, b, c, d, e, f) {
        var $a, self = this;
        if (self.transformation_stack == null) self.transformation_stack = nil;

        
        self.transformation_stack = ($truthy($a = self.transformation_stack) ? $a : [[]]);
        return self.transformation_stack.$last().$push($send([a, b, c, d, e, f], 'map', [], "to_f".$to_proc()));
      }, TMP_TransformationStack_add_to_transformation_stack_1.$$arity = 6);
      
      Opal.defn(self, '$save_transformation_stack', TMP_TransformationStack_save_transformation_stack_2 = function $$save_transformation_stack() {
        var $a, self = this;
        if (self.transformation_stack == null) self.transformation_stack = nil;

        
        self.transformation_stack = ($truthy($a = self.transformation_stack) ? $a : [[]]);
        return self.transformation_stack.$push(self.transformation_stack.$last().$dup());
      }, TMP_TransformationStack_save_transformation_stack_2.$$arity = 0);
      
      Opal.defn(self, '$restore_transformation_stack', TMP_TransformationStack_restore_transformation_stack_3 = function $$restore_transformation_stack() {
        var self = this;
        if (self.transformation_stack == null) self.transformation_stack = nil;

        if ($truthy(self.transformation_stack)) {
          return self.transformation_stack.$pop()
          } else {
          return nil
        }
      }, TMP_TransformationStack_restore_transformation_stack_3.$$arity = 0);
      
      Opal.defn(self, '$current_transformation_matrix_with_translation', TMP_TransformationStack_current_transformation_matrix_with_translation_5 = function $$current_transformation_matrix_with_translation(x, y) {
        var $a, TMP_4, self = this, transformations = nil, matrix = nil;
        if (self.transformation_stack == null) self.transformation_stack = nil;

        if (x == null) {
          x = 0;
        }
        if (y == null) {
          y = 0;
        }
        
        transformations = ($truthy($a = self.transformation_stack) ? $a : [[]]).$last();
        matrix = Opal.const_get_relative($nesting, 'Matrix').$identity(3);
        $send(transformations, 'each', [], (TMP_4 = function(a, b, c, d, e, f){var self = TMP_4.$$s || this;
if (a == null) a = nil;if (b == null) b = nil;if (c == null) c = nil;if (d == null) d = nil;if (e == null) e = nil;if (f == null) f = nil;
        return (matrix = $rb_times(matrix, Opal.const_get_relative($nesting, 'Matrix')['$[]']([a, c, e], [b, d, f], [0, 0, 1])))}, TMP_4.$$s = self, TMP_4.$$arity = 6, TMP_4));
        matrix = $rb_times(matrix, Opal.const_get_relative($nesting, 'Matrix')['$[]']([1, 0, x], [0, 1, y], [0, 0, 1]));
        return matrix.$to_a()['$[]']($range(0, 1, false)).$transpose().$flatten();
      }, TMP_TransformationStack_current_transformation_matrix_with_translation_5.$$arity = -1);
    })($nesting[0], $nesting)
  })($nesting[0], $nesting);
};

/* Generated by Opal 0.11.0 */
Opal.modules["prawn/document/bounding_box"] = function(Opal) {
  function $rb_minus(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs - rhs : lhs['$-'](rhs);
  }
  function $rb_plus(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs + rhs : lhs['$+'](rhs);
  }
  var self = Opal.top, $nesting = [], nil = Opal.nil, $breaker = Opal.breaker, $slice = Opal.slice, $module = Opal.module, $klass = Opal.klass, $send = Opal.send, $hash2 = Opal.hash2, $truthy = Opal.truthy;

  Opal.add_stubs(['$init_bounding_box', '$map_to_absolute', '$new', '$[]', '$dimensions', '$page', '$private', '$fail', '$y', '$call', '$absolute_top', '$y=', '$-', '$==', '$stretchy?', '$absolute_bottom', '$attr_reader', '$height', '$add_left_padding', '$add_right_padding', '$subtract_left_padding', '$bounds', '$subtract_right_padding', '$+', '$left', '$top', '$right', '$bottom', '$width', '$absolute_left', '$absolute_right', '$max', '$to_f', '$page_number', '$page_count', '$start_new_page', '$go_to_page', '$!', '$reference_bounds', '$alias_method', '$dup', '$instance_variable_set', '$===', '$deep_copy']);
  return (function($base, $parent_nesting) {
    var $Prawn, self = $Prawn = $module($base, 'Prawn');

    var def = self.$$proto, $nesting = [self].concat($parent_nesting);

    (function($base, $super, $parent_nesting) {
      function $Document(){};
      var self = $Document = $klass($base, $super, 'Document', $Document);

      var def = self.$$proto, $nesting = [self].concat($parent_nesting), TMP_Document_bounding_box_1, TMP_Document_canvas_3, TMP_Document_init_bounding_box_5;

      def.bounding_box = nil;
      
      
      Opal.defn(self, '$bounding_box', TMP_Document_bounding_box_1 = function $$bounding_box(pt, $a_rest) {
        var TMP_2, self = this, args, $iter = TMP_Document_bounding_box_1.$$p, block = $iter || nil;

        var $args_len = arguments.length, $rest_len = $args_len - 1;
        if ($rest_len < 0) { $rest_len = 0; }
        args = new Array($rest_len);
        for (var $arg_idx = 1; $arg_idx < $args_len; $arg_idx++) {
          args[$arg_idx - 1] = arguments[$arg_idx];
        }
        if ($iter) TMP_Document_bounding_box_1.$$p = null;
        return $send(self, 'init_bounding_box', [block], (TMP_2 = function(parent_box){var self = TMP_2.$$s || this;
if (parent_box == null) parent_box = nil;
        
          pt = self.$map_to_absolute(pt);
          return (self.bounding_box = $send(Opal.const_get_relative($nesting, 'BoundingBox'), 'new', [self, parent_box, pt].concat(Opal.to_a(args))));}, TMP_2.$$s = self, TMP_2.$$arity = 1, TMP_2))
      }, TMP_Document_bounding_box_1.$$arity = -2);
      
      Opal.defn(self, '$canvas', TMP_Document_canvas_3 = function $$canvas() {
        var TMP_4, self = this, $iter = TMP_Document_canvas_3.$$p, block = $iter || nil;

        if ($iter) TMP_Document_canvas_3.$$p = null;
        return $send(self, 'init_bounding_box', [block, $hash2(["hold_position"], {"hold_position": true})], (TMP_4 = function(_){var self = TMP_4.$$s || this;
if (_ == null) _ = nil;
        return (self.bounding_box = Opal.const_get_relative($nesting, 'BoundingBox').$new(self, nil, [0, self.$page().$dimensions()['$[]'](3)], $hash2(["width", "height"], {"width": self.$page().$dimensions()['$[]'](2), "height": self.$page().$dimensions()['$[]'](3)})))}, TMP_4.$$s = self, TMP_4.$$arity = 1, TMP_4))
      }, TMP_Document_canvas_3.$$arity = 0);
      self.$private();
      
      Opal.defn(self, '$init_bounding_box', TMP_Document_init_bounding_box_5 = function $$init_bounding_box(user_block, options) {
        var $a, self = this, $iter = TMP_Document_init_bounding_box_5.$$p, init_block = $iter || nil, parent_box = nil, original_ypos = nil, $writer = nil, created_box = nil;

        if (options == null) {
          options = $hash2([], {});
        }
        if ($iter) TMP_Document_init_bounding_box_5.$$p = null;
        
        if ($truthy(user_block)) {
          } else {
          self.$fail(Opal.const_get_relative($nesting, 'ArgumentError'), "bounding boxes require a block to be drawn within the box")
        };
        parent_box = self.bounding_box;
        original_ypos = self.$y();
        init_block.$call(parent_box);
        
        $writer = [self.bounding_box.$absolute_top()];
        $send(self, 'y=', Opal.to_a($writer));
        $writer[$rb_minus($writer["length"], 1)];;
        user_block.$call();
        if (self.$y()['$=='](self.bounding_box.$absolute_top())) {
          
          $writer = [original_ypos];
          $send(self, 'y=', Opal.to_a($writer));
          $writer[$rb_minus($writer["length"], 1)];};
        if ($truthy(($truthy($a = options['$[]']("hold_position")) ? $a : self.bounding_box['$stretchy?']()))) {
          } else {
          
          $writer = [self.bounding_box.$absolute_bottom()];
          $send(self, 'y=', Opal.to_a($writer));
          $writer[$rb_minus($writer["length"], 1)];
        };
        $a = [self.bounding_box, parent_box], (created_box = $a[0]), (self.bounding_box = $a[1]), $a;
        return created_box;
      }, TMP_Document_init_bounding_box_5.$$arity = -2);
      return (function($base, $super, $parent_nesting) {
        function $BoundingBox(){};
        var self = $BoundingBox = $klass($base, $super, 'BoundingBox', $BoundingBox);

        var def = self.$$proto, $nesting = [self].concat($parent_nesting), TMP_BoundingBox_initialize_6, TMP_BoundingBox_anchor_7, TMP_BoundingBox_left_8, TMP_BoundingBox_indent_9, TMP_BoundingBox_add_left_padding_10, TMP_BoundingBox_subtract_left_padding_11, TMP_BoundingBox_add_right_padding_12, TMP_BoundingBox_subtract_right_padding_13, TMP_BoundingBox_right_14, TMP_BoundingBox_top_15, TMP_BoundingBox_bottom_16, TMP_BoundingBox_top_left_17, TMP_BoundingBox_top_right_18, TMP_BoundingBox_bottom_right_19, TMP_BoundingBox_bottom_left_20, TMP_BoundingBox_absolute_left_21, TMP_BoundingBox_absolute_right_22, TMP_BoundingBox_absolute_top_23, TMP_BoundingBox_absolute_bottom_24, TMP_BoundingBox_absolute_top_left_25, TMP_BoundingBox_absolute_top_right_26, TMP_BoundingBox_absolute_bottom_left_27, TMP_BoundingBox_absolute_bottom_right_28, TMP_BoundingBox_height_29, TMP_BoundingBox_left_side_30, TMP_BoundingBox_right_side_31, TMP_BoundingBox_move_past_bottom_32, TMP_BoundingBox_stretchy$q_33, TMP_BoundingBox_reference_bounds_34, TMP_BoundingBox_deep_copy_35, TMP_BoundingBox_restore_deep_copy_36;

        def.x = def.y = def.document = def.total_left_padding = def.width = def.total_right_padding = def.height = def.stretched_height = def.parent = nil;
        
        
        Opal.defn(self, '$initialize', TMP_BoundingBox_initialize_6 = function $$initialize(document, parent, point, options) {
          var $a, $b, self = this;

          if (options == null) {
            options = $hash2([], {});
          }
          
          if ($truthy(options['$[]']("width"))) {
            } else {
            self.$fail(Opal.const_get_relative($nesting, 'ArgumentError'), "BoundingBox needs the :width option to be set")
          };
          self.document = document;
          self.parent = parent;
          $b = point, $a = Opal.to_ary($b), (self.x = ($a[0] == null ? nil : $a[0])), (self.y = ($a[1] == null ? nil : $a[1])), $b;
          $a = [options['$[]']("width"), options['$[]']("height")], (self.width = $a[0]), (self.height = $a[1]), $a;
          self.total_left_padding = 0;
          self.total_right_padding = 0;
          return (self.stretched_height = nil);
        }, TMP_BoundingBox_initialize_6.$$arity = -4);
        self.$attr_reader("document", "parent");
        self.$attr_reader("total_left_padding");
        self.$attr_reader("total_right_padding");
        
        Opal.defn(self, '$anchor', TMP_BoundingBox_anchor_7 = function $$anchor() {
          var self = this;

          return [self.x, $rb_minus(self.y, self.$height())]
        }, TMP_BoundingBox_anchor_7.$$arity = 0);
        
        Opal.defn(self, '$left', TMP_BoundingBox_left_8 = function $$left() {
          var self = this;

          return 0
        }, TMP_BoundingBox_left_8.$$arity = 0);
        
        Opal.defn(self, '$indent', TMP_BoundingBox_indent_9 = function $$indent(left_padding, right_padding) {
          var self = this, $iter = TMP_BoundingBox_indent_9.$$p, block = $iter || nil;

          if (right_padding == null) {
            right_padding = 0;
          }
          if ($iter) TMP_BoundingBox_indent_9.$$p = null;
          return (function() { try {
          
          self.$add_left_padding(left_padding);
          self.$add_right_padding(right_padding);
          return Opal.yieldX(block, []);;
          } finally {
            (self.document.$bounds().$subtract_left_padding(left_padding), self.document.$bounds().$subtract_right_padding(right_padding))
          }; })()
        }, TMP_BoundingBox_indent_9.$$arity = -2);
        
        Opal.defn(self, '$add_left_padding', TMP_BoundingBox_add_left_padding_10 = function $$add_left_padding(left_padding) {
          var self = this;

          
          self.total_left_padding = $rb_plus(self.total_left_padding, left_padding);
          self.x = $rb_plus(self.x, left_padding);
          return (self.width = $rb_minus(self.width, left_padding));
        }, TMP_BoundingBox_add_left_padding_10.$$arity = 1);
        
        Opal.defn(self, '$subtract_left_padding', TMP_BoundingBox_subtract_left_padding_11 = function $$subtract_left_padding(left_padding) {
          var self = this;

          
          self.total_left_padding = $rb_minus(self.total_left_padding, left_padding);
          self.x = $rb_minus(self.x, left_padding);
          return (self.width = $rb_plus(self.width, left_padding));
        }, TMP_BoundingBox_subtract_left_padding_11.$$arity = 1);
        
        Opal.defn(self, '$add_right_padding', TMP_BoundingBox_add_right_padding_12 = function $$add_right_padding(right_padding) {
          var self = this;

          
          self.total_right_padding = $rb_plus(self.total_right_padding, right_padding);
          return (self.width = $rb_minus(self.width, right_padding));
        }, TMP_BoundingBox_add_right_padding_12.$$arity = 1);
        
        Opal.defn(self, '$subtract_right_padding', TMP_BoundingBox_subtract_right_padding_13 = function $$subtract_right_padding(right_padding) {
          var self = this;

          
          self.total_right_padding = $rb_minus(self.total_right_padding, right_padding);
          return (self.width = $rb_plus(self.width, right_padding));
        }, TMP_BoundingBox_subtract_right_padding_13.$$arity = 1);
        
        Opal.defn(self, '$right', TMP_BoundingBox_right_14 = function $$right() {
          var self = this;

          return self.width
        }, TMP_BoundingBox_right_14.$$arity = 0);
        
        Opal.defn(self, '$top', TMP_BoundingBox_top_15 = function $$top() {
          var self = this;

          return self.$height()
        }, TMP_BoundingBox_top_15.$$arity = 0);
        
        Opal.defn(self, '$bottom', TMP_BoundingBox_bottom_16 = function $$bottom() {
          var self = this;

          return 0
        }, TMP_BoundingBox_bottom_16.$$arity = 0);
        
        Opal.defn(self, '$top_left', TMP_BoundingBox_top_left_17 = function $$top_left() {
          var self = this;

          return [self.$left(), self.$top()]
        }, TMP_BoundingBox_top_left_17.$$arity = 0);
        
        Opal.defn(self, '$top_right', TMP_BoundingBox_top_right_18 = function $$top_right() {
          var self = this;

          return [self.$right(), self.$top()]
        }, TMP_BoundingBox_top_right_18.$$arity = 0);
        
        Opal.defn(self, '$bottom_right', TMP_BoundingBox_bottom_right_19 = function $$bottom_right() {
          var self = this;

          return [self.$right(), self.$bottom()]
        }, TMP_BoundingBox_bottom_right_19.$$arity = 0);
        
        Opal.defn(self, '$bottom_left', TMP_BoundingBox_bottom_left_20 = function $$bottom_left() {
          var self = this;

          return [self.$left(), self.$bottom()]
        }, TMP_BoundingBox_bottom_left_20.$$arity = 0);
        
        Opal.defn(self, '$absolute_left', TMP_BoundingBox_absolute_left_21 = function $$absolute_left() {
          var self = this;

          return self.x
        }, TMP_BoundingBox_absolute_left_21.$$arity = 0);
        
        Opal.defn(self, '$absolute_right', TMP_BoundingBox_absolute_right_22 = function $$absolute_right() {
          var self = this;

          return $rb_plus(self.x, self.$width())
        }, TMP_BoundingBox_absolute_right_22.$$arity = 0);
        
        Opal.defn(self, '$absolute_top', TMP_BoundingBox_absolute_top_23 = function $$absolute_top() {
          var self = this;

          return self.y
        }, TMP_BoundingBox_absolute_top_23.$$arity = 0);
        
        Opal.defn(self, '$absolute_bottom', TMP_BoundingBox_absolute_bottom_24 = function $$absolute_bottom() {
          var self = this;

          return $rb_minus(self.y, self.$height())
        }, TMP_BoundingBox_absolute_bottom_24.$$arity = 0);
        
        Opal.defn(self, '$absolute_top_left', TMP_BoundingBox_absolute_top_left_25 = function $$absolute_top_left() {
          var self = this;

          return [self.$absolute_left(), self.$absolute_top()]
        }, TMP_BoundingBox_absolute_top_left_25.$$arity = 0);
        
        Opal.defn(self, '$absolute_top_right', TMP_BoundingBox_absolute_top_right_26 = function $$absolute_top_right() {
          var self = this;

          return [self.$absolute_right(), self.$absolute_top()]
        }, TMP_BoundingBox_absolute_top_right_26.$$arity = 0);
        
        Opal.defn(self, '$absolute_bottom_left', TMP_BoundingBox_absolute_bottom_left_27 = function $$absolute_bottom_left() {
          var self = this;

          return [self.$absolute_left(), self.$absolute_bottom()]
        }, TMP_BoundingBox_absolute_bottom_left_27.$$arity = 0);
        
        Opal.defn(self, '$absolute_bottom_right', TMP_BoundingBox_absolute_bottom_right_28 = function $$absolute_bottom_right() {
          var self = this;

          return [self.$absolute_right(), self.$absolute_bottom()]
        }, TMP_BoundingBox_absolute_bottom_right_28.$$arity = 0);
        self.$attr_reader("width");
        
        Opal.defn(self, '$height', TMP_BoundingBox_height_29 = function $$height() {
          var self = this;

          
          if ($truthy(self.height)) {
            return self.height};
          return (self.stretched_height = [$rb_minus(self.$absolute_top(), self.document.$y()), self.stretched_height.$to_f()].$max());
        }, TMP_BoundingBox_height_29.$$arity = 0);
        
        Opal.defn(self, '$left_side', TMP_BoundingBox_left_side_30 = function $$left_side() {
          var self = this;

          return self.$absolute_left()
        }, TMP_BoundingBox_left_side_30.$$arity = 0);
        
        Opal.defn(self, '$right_side', TMP_BoundingBox_right_side_31 = function $$right_side() {
          var self = this;

          return self.$absolute_right()
        }, TMP_BoundingBox_right_side_31.$$arity = 0);
        
        Opal.defn(self, '$move_past_bottom', TMP_BoundingBox_move_past_bottom_32 = function $$move_past_bottom() {
          var self = this;

          if (self.document.$page_number()['$=='](self.document.$page_count())) {
            return self.document.$start_new_page()
            } else {
            return self.document.$go_to_page($rb_plus(self.document.$page_number(), 1))
          }
        }, TMP_BoundingBox_move_past_bottom_32.$$arity = 0);
        
        Opal.defn(self, '$stretchy?', TMP_BoundingBox_stretchy$q_33 = function() {
          var self = this;

          return self.height['$!']()
        }, TMP_BoundingBox_stretchy$q_33.$$arity = 0);
        
        Opal.defn(self, '$reference_bounds', TMP_BoundingBox_reference_bounds_34 = function $$reference_bounds() {
          var self = this;

          if ($truthy(self['$stretchy?']())) {
            
            if ($truthy(self.parent)) {
              } else {
              self.$fail("Can't find reference bounds: my parent is unset")
            };
            return self.parent.$reference_bounds();
            } else {
            return self
          }
        }, TMP_BoundingBox_reference_bounds_34.$$arity = 0);
        self.$alias_method("update_height", "height");
        
        Opal.defn(self, '$deep_copy', TMP_BoundingBox_deep_copy_35 = function $$deep_copy() {
          var self = this, copy = nil;

          
          copy = self.$dup();
          copy.$instance_variable_set("@parent", (function() {if ($truthy(Opal.const_get_relative($nesting, 'BoundingBox')['$==='](self.parent))) {
            return self.parent.$deep_copy()
            } else {
            return nil
          }; return nil; })());
          copy.$instance_variable_set("@document", nil);
          return copy;
        }, TMP_BoundingBox_deep_copy_35.$$arity = 0);
        return Opal.defs(self, '$restore_deep_copy', TMP_BoundingBox_restore_deep_copy_36 = function $$restore_deep_copy(bounds, document) {
          var self = this;

          
          bounds.$instance_variable_set("@document", document);
          return bounds;
        }, TMP_BoundingBox_restore_deep_copy_36.$$arity = 2);
      })($nesting[0], null, $nesting);
    })($nesting[0], null, $nesting)
  })($nesting[0], $nesting)
};

/* Generated by Opal 0.11.0 */
Opal.modules["prawn/document/column_box"] = function(Opal) {
  function $rb_minus(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs - rhs : lhs['$-'](rhs);
  }
  function $rb_divide(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs / rhs : lhs['$/'](rhs);
  }
  function $rb_times(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs * rhs : lhs['$*'](rhs);
  }
  function $rb_plus(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs + rhs : lhs['$+'](rhs);
  }
  var self = Opal.top, $nesting = [], nil = Opal.nil, $breaker = Opal.breaker, $slice = Opal.slice, $module = Opal.module, $klass = Opal.klass, $send = Opal.send, $truthy = Opal.truthy, $hash2 = Opal.hash2;

  Opal.add_stubs(['$init_column_box', '$map_to_absolute!', '$[]', '$new', '$private', '$call', '$absolute_top', '$y=', '$-', '$absolute_bottom', '$font_size', '$/', '$*', '$bare_column_width', '$+', '$absolute_left', '$width_of_column', '$absolute_right', '$left', '$width', '$%', '$==', '$start_new_page']);
  
  self.$require("prawn/document/column_box"+ '/../' + "bounding_box");
  return (function($base, $parent_nesting) {
    var $Prawn, self = $Prawn = $module($base, 'Prawn');

    var def = self.$$proto, $nesting = [self].concat($parent_nesting);

    (function($base, $super, $parent_nesting) {
      function $Document(){};
      var self = $Document = $klass($base, $super, 'Document', $Document);

      var def = self.$$proto, $nesting = [self].concat($parent_nesting), TMP_Document_column_box_1, TMP_Document_init_column_box_3;

      def.bounding_box = nil;
      
      
      Opal.defn(self, '$column_box', TMP_Document_column_box_1 = function $$column_box($a_rest) {
        var TMP_2, self = this, args, $iter = TMP_Document_column_box_1.$$p, block = $iter || nil;

        var $args_len = arguments.length, $rest_len = $args_len - 0;
        if ($rest_len < 0) { $rest_len = 0; }
        args = new Array($rest_len);
        for (var $arg_idx = 0; $arg_idx < $args_len; $arg_idx++) {
          args[$arg_idx - 0] = arguments[$arg_idx];
        }
        if ($iter) TMP_Document_column_box_1.$$p = null;
        return $send(self, 'init_column_box', [block], (TMP_2 = function(parent_box){var self = TMP_2.$$s || this;
if (parent_box == null) parent_box = nil;
        
          self['$map_to_absolute!'](args['$[]'](0));
          return (self.bounding_box = $send(Opal.const_get_relative($nesting, 'ColumnBox'), 'new', [self, parent_box].concat(Opal.to_a(args))));}, TMP_2.$$s = self, TMP_2.$$arity = 1, TMP_2))
      }, TMP_Document_column_box_1.$$arity = -1);
      self.$private();
      
      Opal.defn(self, '$init_column_box', TMP_Document_init_column_box_3 = function $$init_column_box(user_block, options) {
        var self = this, $iter = TMP_Document_init_column_box_3.$$p, init_block = $iter || nil, parent_box = nil, $writer = nil;

        if (options == null) {
          options = $hash2([], {});
        }
        if ($iter) TMP_Document_init_column_box_3.$$p = null;
        
        parent_box = self.bounding_box;
        init_block.$call(parent_box);
        
        $writer = [self.bounding_box.$absolute_top()];
        $send(self, 'y=', Opal.to_a($writer));
        $writer[$rb_minus($writer["length"], 1)];;
        user_block.$call();
        if ($truthy(options['$[]']("hold_position"))) {
          } else {
          
          $writer = [self.bounding_box.$absolute_bottom()];
          $send(self, 'y=', Opal.to_a($writer));
          $writer[$rb_minus($writer["length"], 1)];
        };
        return (self.bounding_box = parent_box);
      }, TMP_Document_init_column_box_3.$$arity = -2);
      return (function($base, $super, $parent_nesting) {
        function $ColumnBox(){};
        var self = $ColumnBox = $klass($base, $super, 'ColumnBox', $ColumnBox);

        var def = self.$$proto, $nesting = [self].concat($parent_nesting), TMP_ColumnBox_initialize_4, TMP_ColumnBox_bare_column_width_5, TMP_ColumnBox_width_6, TMP_ColumnBox_width_of_column_7, TMP_ColumnBox_left_side_8, TMP_ColumnBox_left_9, TMP_ColumnBox_right_side_10, TMP_ColumnBox_right_11, TMP_ColumnBox_move_past_bottom_12, TMP_ColumnBox_add_left_padding_13, TMP_ColumnBox_subtract_left_padding_14, TMP_ColumnBox_add_right_padding_15, TMP_ColumnBox_subtract_right_padding_16;

        def.document = def.width = def.spacer = def.columns = def.total_left_padding = def.total_right_padding = def.current_column = def.y = def.reflow_margins = def.parent = def.x = nil;
        
        
        Opal.defn(self, '$initialize', TMP_ColumnBox_initialize_4 = function $$initialize(document, parent, point, options) {
          var $a, self = this, $iter = TMP_ColumnBox_initialize_4.$$p, $yield = $iter || nil, $zuper = nil, $zuper_i = nil, $zuper_ii = nil;

          if (options == null) {
            options = $hash2([], {});
          }
          if ($iter) TMP_ColumnBox_initialize_4.$$p = null;
          // Prepare super implicit arguments
          for($zuper_i = 0, $zuper_ii = arguments.length, $zuper = new Array($zuper_ii); $zuper_i < $zuper_ii; $zuper_i++) {
            $zuper[$zuper_i] = arguments[$zuper_i];
          }
          
          $send(self, Opal.find_super_dispatcher(self, 'initialize', TMP_ColumnBox_initialize_4, false), $zuper, $iter);
          self.columns = ($truthy($a = options['$[]']("columns")) ? $a : 3);
          self.spacer = ($truthy($a = options['$[]']("spacer")) ? $a : self.document.$font_size());
          self.current_column = 0;
          return (self.reflow_margins = options['$[]']("reflow_margins"));
        }, TMP_ColumnBox_initialize_4.$$arity = -4);
        
        Opal.defn(self, '$bare_column_width', TMP_ColumnBox_bare_column_width_5 = function $$bare_column_width() {
          var self = this;

          return $rb_divide($rb_minus(self.width, $rb_times(self.spacer, $rb_minus(self.columns, 1))), self.columns)
        }, TMP_ColumnBox_bare_column_width_5.$$arity = 0);
        
        Opal.defn(self, '$width', TMP_ColumnBox_width_6 = function $$width() {
          var self = this;

          return $rb_minus(self.$bare_column_width(), $rb_plus(self.total_left_padding, self.total_right_padding))
        }, TMP_ColumnBox_width_6.$$arity = 0);
        
        Opal.defn(self, '$width_of_column', TMP_ColumnBox_width_of_column_7 = function $$width_of_column() {
          var self = this;

          return $rb_plus(self.$bare_column_width(), self.spacer)
        }, TMP_ColumnBox_width_of_column_7.$$arity = 0);
        
        Opal.defn(self, '$left_side', TMP_ColumnBox_left_side_8 = function $$left_side() {
          var self = this;

          return $rb_plus(self.$absolute_left(), $rb_times(self.$width_of_column(), self.current_column))
        }, TMP_ColumnBox_left_side_8.$$arity = 0);
        
        Opal.defn(self, '$left', TMP_ColumnBox_left_9 = function $$left() {
          var self = this;

          return $rb_times(self.$width_of_column(), self.current_column)
        }, TMP_ColumnBox_left_9.$$arity = 0);
        
        Opal.defn(self, '$right_side', TMP_ColumnBox_right_side_10 = function $$right_side() {
          var self = this, columns_from_right = nil;

          
          columns_from_right = $rb_minus(self.columns, $rb_plus(1, self.current_column));
          return $rb_minus(self.$absolute_right(), $rb_times(self.$width_of_column(), columns_from_right));
        }, TMP_ColumnBox_right_side_10.$$arity = 0);
        
        Opal.defn(self, '$right', TMP_ColumnBox_right_11 = function $$right() {
          var self = this;

          return $rb_plus(self.$left(), self.$width())
        }, TMP_ColumnBox_right_11.$$arity = 0);
        
        Opal.defn(self, '$move_past_bottom', TMP_ColumnBox_move_past_bottom_12 = function $$move_past_bottom() {
          var self = this, $writer = nil;

          
          self.current_column = $rb_plus(self.current_column, 1)['$%'](self.columns);
          
          $writer = [self.y];
          $send(self.document, 'y=', Opal.to_a($writer));
          $writer[$rb_minus($writer["length"], 1)];;
          if ((0)['$=='](self.current_column)) {
            
            if ($truthy(self.reflow_margins)) {
              self.y = self.parent.$absolute_top()};
            return self.document.$start_new_page();
            } else {
            return nil
          };
        }, TMP_ColumnBox_move_past_bottom_12.$$arity = 0);
        
        Opal.defn(self, '$add_left_padding', TMP_ColumnBox_add_left_padding_13 = function $$add_left_padding(left_padding) {
          var self = this;

          
          self.total_left_padding = $rb_plus(self.total_left_padding, left_padding);
          return (self.x = $rb_plus(self.x, left_padding));
        }, TMP_ColumnBox_add_left_padding_13.$$arity = 1);
        
        Opal.defn(self, '$subtract_left_padding', TMP_ColumnBox_subtract_left_padding_14 = function $$subtract_left_padding(left_padding) {
          var self = this;

          
          self.total_left_padding = $rb_minus(self.total_left_padding, left_padding);
          return (self.x = $rb_minus(self.x, left_padding));
        }, TMP_ColumnBox_subtract_left_padding_14.$$arity = 1);
        
        Opal.defn(self, '$add_right_padding', TMP_ColumnBox_add_right_padding_15 = function $$add_right_padding(right_padding) {
          var self = this;

          return (self.total_right_padding = $rb_plus(self.total_right_padding, right_padding))
        }, TMP_ColumnBox_add_right_padding_15.$$arity = 1);
        return (Opal.defn(self, '$subtract_right_padding', TMP_ColumnBox_subtract_right_padding_16 = function $$subtract_right_padding(right_padding) {
          var self = this;

          return (self.total_right_padding = $rb_minus(self.total_right_padding, right_padding))
        }, TMP_ColumnBox_subtract_right_padding_16.$$arity = 1), nil) && 'subtract_right_padding';
      })($nesting[0], Opal.const_get_relative($nesting, 'BoundingBox'), $nesting);
    })($nesting[0], null, $nesting)
  })($nesting[0], $nesting);
};

/* Generated by Opal 0.11.0 */
Opal.modules["forwardable"] = function(Opal) {
  var self = Opal.top, $nesting = [], nil = Opal.nil, $breaker = Opal.breaker, $slice = Opal.slice, $module = Opal.module, $send = Opal.send, $truthy = Opal.truthy;

  Opal.add_stubs(['$each', '$respond_to?', '$def_instance_delegator', '$include?', '$start_with?', '$to_s', '$define_method', '$__send__', '$instance_variable_get', '$to_proc', '$def_single_delegator', '$define_singleton_method']);
  
  (function($base, $parent_nesting) {
    var $Forwardable, self = $Forwardable = $module($base, 'Forwardable');

    var def = self.$$proto, $nesting = [self].concat($parent_nesting), TMP_Forwardable_instance_delegate_3, TMP_Forwardable_def_instance_delegators_5, TMP_Forwardable_def_instance_delegator_8;

    
    
    Opal.defn(self, '$instance_delegate', TMP_Forwardable_instance_delegate_3 = function $$instance_delegate(hash) {
      var TMP_1, self = this;

      return $send(hash, 'each', [], (TMP_1 = function(methods, accessor){var self = TMP_1.$$s || this, TMP_2;
if (methods == null) methods = nil;if (accessor == null) accessor = nil;
      
        if ($truthy(methods['$respond_to?']("each"))) {
          } else {
          methods = [methods]
        };
        return $send(methods, 'each', [], (TMP_2 = function(method){var self = TMP_2.$$s || this;
if (method == null) method = nil;
        return self.$def_instance_delegator(accessor, method)}, TMP_2.$$s = self, TMP_2.$$arity = 1, TMP_2));}, TMP_1.$$s = self, TMP_1.$$arity = 2, TMP_1))
    }, TMP_Forwardable_instance_delegate_3.$$arity = 1);
    
    Opal.defn(self, '$def_instance_delegators', TMP_Forwardable_def_instance_delegators_5 = function $$def_instance_delegators(accessor, $a_rest) {
      var TMP_4, self = this, methods;

      var $args_len = arguments.length, $rest_len = $args_len - 1;
      if ($rest_len < 0) { $rest_len = 0; }
      methods = new Array($rest_len);
      for (var $arg_idx = 1; $arg_idx < $args_len; $arg_idx++) {
        methods[$arg_idx - 1] = arguments[$arg_idx];
      }
      return $send(methods, 'each', [], (TMP_4 = function(method){var self = TMP_4.$$s || this;
if (method == null) method = nil;
      
        if ($truthy(["__send__", "__id__"]['$include?'](method))) {
          return nil;};
        return self.$def_instance_delegator(accessor, method);}, TMP_4.$$s = self, TMP_4.$$arity = 1, TMP_4))
    }, TMP_Forwardable_def_instance_delegators_5.$$arity = -2);
    
    Opal.defn(self, '$def_instance_delegator', TMP_Forwardable_def_instance_delegator_8 = function $$def_instance_delegator(accessor, method, ali) {
      var TMP_6, TMP_7, self = this;

      if (ali == null) {
        ali = method;
      }
      if ($truthy(accessor.$to_s()['$start_with?']("@"))) {
        return $send(self, 'define_method', [ali], (TMP_6 = function($a_rest){var self = TMP_6.$$s || this, block, args;

          block = TMP_6.$$p || nil;
          if (block) TMP_6.$$p = null;
          var $args_len = arguments.length, $rest_len = $args_len - 0;
          if ($rest_len < 0) { $rest_len = 0; }
          args = new Array($rest_len);
          for (var $arg_idx = 0; $arg_idx < $args_len; $arg_idx++) {
            args[$arg_idx - 0] = arguments[$arg_idx];
          }
        return $send(self.$instance_variable_get(accessor), '__send__', [method].concat(Opal.to_a(args)), block.$to_proc())}, TMP_6.$$s = self, TMP_6.$$arity = -1, TMP_6))
        } else {
        return $send(self, 'define_method', [ali], (TMP_7 = function($a_rest){var self = TMP_7.$$s || this, block, args;

          block = TMP_7.$$p || nil;
          if (block) TMP_7.$$p = null;
          var $args_len = arguments.length, $rest_len = $args_len - 0;
          if ($rest_len < 0) { $rest_len = 0; }
          args = new Array($rest_len);
          for (var $arg_idx = 0; $arg_idx < $args_len; $arg_idx++) {
            args[$arg_idx - 0] = arguments[$arg_idx];
          }
        return $send(self.$__send__(accessor), '__send__', [method].concat(Opal.to_a(args)), block.$to_proc())}, TMP_7.$$s = self, TMP_7.$$arity = -1, TMP_7))
      }
    }, TMP_Forwardable_def_instance_delegator_8.$$arity = -3);
    Opal.alias(self, "delegate", "instance_delegate");
    Opal.alias(self, "def_delegators", "def_instance_delegators");
    Opal.alias(self, "def_delegator", "def_instance_delegator");
  })($nesting[0], $nesting);
  return (function($base, $parent_nesting) {
    var $SingleForwardable, self = $SingleForwardable = $module($base, 'SingleForwardable');

    var def = self.$$proto, $nesting = [self].concat($parent_nesting), TMP_SingleForwardable_single_delegate_11, TMP_SingleForwardable_def_single_delegators_13, TMP_SingleForwardable_def_single_delegator_16;

    
    
    Opal.defn(self, '$single_delegate', TMP_SingleForwardable_single_delegate_11 = function $$single_delegate(hash) {
      var TMP_9, self = this;

      return $send(hash, 'each', [], (TMP_9 = function(methods, accessor){var self = TMP_9.$$s || this, TMP_10;
if (methods == null) methods = nil;if (accessor == null) accessor = nil;
      
        if ($truthy(methods['$respond_to?']("each"))) {
          } else {
          methods = [methods]
        };
        return $send(methods, 'each', [], (TMP_10 = function(method){var self = TMP_10.$$s || this;
if (method == null) method = nil;
        return self.$def_single_delegator(accessor, method)}, TMP_10.$$s = self, TMP_10.$$arity = 1, TMP_10));}, TMP_9.$$s = self, TMP_9.$$arity = 2, TMP_9))
    }, TMP_SingleForwardable_single_delegate_11.$$arity = 1);
    
    Opal.defn(self, '$def_single_delegators', TMP_SingleForwardable_def_single_delegators_13 = function $$def_single_delegators(accessor, $a_rest) {
      var TMP_12, self = this, methods;

      var $args_len = arguments.length, $rest_len = $args_len - 1;
      if ($rest_len < 0) { $rest_len = 0; }
      methods = new Array($rest_len);
      for (var $arg_idx = 1; $arg_idx < $args_len; $arg_idx++) {
        methods[$arg_idx - 1] = arguments[$arg_idx];
      }
      return $send(methods, 'each', [], (TMP_12 = function(method){var self = TMP_12.$$s || this;
if (method == null) method = nil;
      
        if ($truthy(["__send__", "__id__"]['$include?'](method))) {
          return nil;};
        return self.$def_single_delegator(accessor, method);}, TMP_12.$$s = self, TMP_12.$$arity = 1, TMP_12))
    }, TMP_SingleForwardable_def_single_delegators_13.$$arity = -2);
    
    Opal.defn(self, '$def_single_delegator', TMP_SingleForwardable_def_single_delegator_16 = function $$def_single_delegator(accessor, method, ali) {
      var TMP_14, TMP_15, self = this;

      if (ali == null) {
        ali = method;
      }
      if ($truthy(accessor.$to_s()['$start_with?']("@"))) {
        return $send(self, 'define_singleton_method', [ali], (TMP_14 = function($a_rest){var self = TMP_14.$$s || this, block, args;

          block = TMP_14.$$p || nil;
          if (block) TMP_14.$$p = null;
          var $args_len = arguments.length, $rest_len = $args_len - 0;
          if ($rest_len < 0) { $rest_len = 0; }
          args = new Array($rest_len);
          for (var $arg_idx = 0; $arg_idx < $args_len; $arg_idx++) {
            args[$arg_idx - 0] = arguments[$arg_idx];
          }
        return $send(self.$instance_variable_get(accessor), '__send__', [method].concat(Opal.to_a(args)), block.$to_proc())}, TMP_14.$$s = self, TMP_14.$$arity = -1, TMP_14))
        } else {
        return $send(self, 'define_singleton_method', [ali], (TMP_15 = function($a_rest){var self = TMP_15.$$s || this, block, args;

          block = TMP_15.$$p || nil;
          if (block) TMP_15.$$p = null;
          var $args_len = arguments.length, $rest_len = $args_len - 0;
          if ($rest_len < 0) { $rest_len = 0; }
          args = new Array($rest_len);
          for (var $arg_idx = 0; $arg_idx < $args_len; $arg_idx++) {
            args[$arg_idx - 0] = arguments[$arg_idx];
          }
        return $send(self.$__send__(accessor), '__send__', [method].concat(Opal.to_a(args)), block.$to_proc())}, TMP_15.$$s = self, TMP_15.$$arity = -1, TMP_15))
      }
    }, TMP_SingleForwardable_def_single_delegator_16.$$arity = -3);
    Opal.alias(self, "delegate", "single_delegate");
    Opal.alias(self, "def_delegators", "def_single_delegators");
    Opal.alias(self, "def_delegator", "def_single_delegator");
  })($nesting[0], $nesting);
};

/* Generated by Opal 0.11.0 */
Opal.modules["prawn/document/internals"] = function(Opal) {
  var self = Opal.top, $nesting = [], nil = Opal.nil, $breaker = Opal.breaker, $slice = Opal.slice, $module = Opal.module, $klass = Opal.klass, $hash = Opal.hash, $send = Opal.send, $truthy = Opal.truthy;

  Opal.add_stubs(['$require', '$extend', '$delegate', '$save_transformation_stack', '$save_graphics_state', '$renderer', '$to_proc', '$restore_transformation_stack', '$restore_graphics_state', '$new', '$state']);
  
  self.$require("forwardable");
  return (function($base, $parent_nesting) {
    var $Prawn, self = $Prawn = $module($base, 'Prawn');

    var def = self.$$proto, $nesting = [self].concat($parent_nesting);

    (function($base, $super, $parent_nesting) {
      function $Document(){};
      var self = $Document = $klass($base, $super, 'Document', $Document);

      var def = self.$$proto, $nesting = [self].concat($parent_nesting);

      return (function($base, $parent_nesting) {
        var $Internals, self = $Internals = $module($base, 'Internals');

        var def = self.$$proto, $nesting = [self].concat($parent_nesting), TMP_Internals_save_graphics_state_1, TMP_Internals_restore_graphics_state_2, TMP_Internals_renderer_3;

        
        self.$extend(Opal.const_get_relative($nesting, 'Forwardable'));
        self.$delegate($hash(["graphic_state", "on_page_create"], "renderer"));
        
        Opal.defn(self, '$save_graphics_state', TMP_Internals_save_graphics_state_1 = function $$save_graphics_state(state) {
          var self = this, $iter = TMP_Internals_save_graphics_state_1.$$p, block = $iter || nil;

          if (state == null) {
            state = nil;
          }
          if ($iter) TMP_Internals_save_graphics_state_1.$$p = null;
          
          self.$save_transformation_stack();
          return $send(self.$renderer(), 'save_graphics_state', [state], block.$to_proc());
        }, TMP_Internals_save_graphics_state_1.$$arity = -1);
        
        Opal.defn(self, '$restore_graphics_state', TMP_Internals_restore_graphics_state_2 = function $$restore_graphics_state() {
          var self = this;

          
          self.$restore_transformation_stack();
          return self.$renderer().$restore_graphics_state();
        }, TMP_Internals_restore_graphics_state_2.$$arity = 0);
        self.$delegate($hash(["compression_enabled?"], "renderer"));
        self.$delegate($hash(["ref", "ref!", "deref"], "renderer"));
        self.$delegate($hash(["names"], "renderer"));
        self.$delegate($hash(["add_content"], "renderer"));
        
        Opal.defn(self, '$renderer', TMP_Internals_renderer_3 = function $$renderer() {
          var $a, self = this;
          if (self.renderer == null) self.renderer = nil;

          return (self.renderer = ($truthy($a = self.renderer) ? $a : Opal.const_get_qualified(Opal.const_get_qualified(Opal.const_get_relative($nesting, 'PDF'), 'Core'), 'Renderer').$new(self.$state())))
        }, TMP_Internals_renderer_3.$$arity = 0);
      })($nesting[0], $nesting)
    })($nesting[0], null, $nesting)
  })($nesting[0], $nesting);
};

/* Generated by Opal 0.11.0 */
Opal.modules["prawn/document/span"] = function(Opal) {
  function $rb_minus(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs - rhs : lhs['$-'](rhs);
  }
  function $rb_plus(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs + rhs : lhs['$+'](rhs);
  }
  function $rb_divide(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs / rhs : lhs['$/'](rhs);
  }
  var self = Opal.top, $nesting = [], nil = Opal.nil, $breaker = Opal.breaker, $slice = Opal.slice, $module = Opal.module, $klass = Opal.klass, $truthy = Opal.truthy, $send = Opal.send, $hash2 = Opal.hash2;

  Opal.add_stubs(['$verify_options', '$y', '$[]', '$===', '$absolute_left', '$margin_box', '$-', '$+', '$/', '$width', '$absolute_right', '$fail', '$canvas', '$bounding_box', '$absolute_top', '$y=']);
  return (function($base, $parent_nesting) {
    var $Prawn, self = $Prawn = $module($base, 'Prawn');

    var def = self.$$proto, $nesting = [self].concat($parent_nesting);

    (function($base, $super, $parent_nesting) {
      function $Document(){};
      var self = $Document = $klass($base, $super, 'Document', $Document);

      var def = self.$$proto, $nesting = [self].concat($parent_nesting), TMP_Document_span_3;

      return (Opal.defn(self, '$span', TMP_Document_span_3 = function $$span(width, options) {
        var $a, TMP_1, self = this, $iter = TMP_Document_span_3.$$p, $yield = $iter || nil, original_position = nil, left_boundary = nil, $case = nil;

        if (options == null) {
          options = $hash2([], {});
        }
        if ($iter) TMP_Document_span_3.$$p = null;
        
        Opal.const_get_relative($nesting, 'Prawn').$verify_options(["position"], options);
        original_position = self.$y();
        left_boundary = (function() {$case = ($truthy($a = options['$[]']("position")) ? $a : "left");
        if ("left"['$===']($case)) {return self.$margin_box().$absolute_left()}
        else if ("center"['$===']($case)) {return $rb_minus($rb_plus(self.$margin_box().$absolute_left(), $rb_divide(self.$margin_box().$width(), 2.0)), $rb_divide(width, 2.0))}
        else if ("right"['$===']($case)) {return $rb_minus(self.$margin_box().$absolute_right(), width)}
        else if (Opal.const_get_relative($nesting, 'Numeric')['$===']($case)) {return $rb_plus(self.$margin_box().$absolute_left(), options['$[]']("position"))}
        else {return self.$fail(Opal.const_get_relative($nesting, 'ArgumentError'), "Invalid option for :position")}})();
        return $send(self, 'canvas', [], (TMP_1 = function(){var self = TMP_1.$$s || this, TMP_2;

        return $send(self, 'bounding_box', [[left_boundary, self.$margin_box().$absolute_top()], $hash2(["width"], {"width": width})], (TMP_2 = function(){var self = TMP_2.$$s || this, $writer = nil;

          
            
            $writer = [original_position];
            $send(self, 'y=', Opal.to_a($writer));
            $writer[$rb_minus($writer["length"], 1)];;
            return Opal.yieldX($yield, []);;}, TMP_2.$$s = self, TMP_2.$$arity = 0, TMP_2))}, TMP_1.$$s = self, TMP_1.$$arity = 0, TMP_1));
      }, TMP_Document_span_3.$$arity = -2), nil) && 'span'
    })($nesting[0], null, $nesting)
  })($nesting[0], $nesting)
};

/* Generated by Opal 0.11.0 */
Opal.modules["prawn/document"] = function(Opal) {
  function $rb_minus(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs - rhs : lhs['$-'](rhs);
  }
  function $rb_lt(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs < rhs : lhs['$<'](rhs);
  }
  function $rb_plus(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs + rhs : lhs['$+'](rhs);
  }
  var self = Opal.top, $nesting = [], nil = Opal.nil, $breaker = Opal.breaker, $slice = Opal.slice, $module = Opal.module, $klass = Opal.klass, $truthy = Opal.truthy, $send = Opal.send, $hash2 = Opal.hash2, $hash = Opal.hash;

  Opal.add_stubs(['$require', '$include', '$each', '$extensions', '$<<', '$attr_accessor', '$attr_reader', '$new', '$to_proc', '$render_file', '$dup', '$verify_options', '$reverse_each', '$class', '$extend', '$state=', '$-', '$populate_pages_from_store', '$state', '$min_version', '$store', '$renderer', '$==', '$[]', '$delete', '$[]=', '$initialize_first_page', '$<', '$arity', '$instance_eval', '$page', '$size', '$layout', '$margins', '$graphic_state', '$color_space=', '$merge!', '$page=', '$apply_margin_options', '$generate_margin_box', '$!=', '$use_graphic_settings', '$insert_page', '$+', '$canvas', '$image', '$top_left', '$bounds', '$absolute_top', '$float', '$on_page_create_action', '$page_count', '$pages', '$update_height', '$y', '$absolute_bottom', '$y=', '$page_number', '$go_to_page', '$repeaters', '$run', '$render', '$open', '$reference_bounds', '$move_down', '$indent', '$to_i', '$key?', '$===', '$page_match?', '$nil?', '$fill_color', '$gsub', '$text_box', '$fail', '$odd?', '$even?', '$include?', '$call', '$send', '$start_new_page', '$merge', '$private', '$current_fill_color', '$set_fill_color', '$current_stroke_color', '$set_stroke_color', '$line_width', '$write_line_width', '$cap_style', '$write_stroke_cap_style', '$join_style', '$write_stroke_join_style', '$dashed?', '$write_stroke_dash', '$dimensions', '$add_left_padding', '$total_left_padding', '$add_right_padding', '$total_right_padding', '$parent', '$Array', '$length', '$zip']);
  
  self.$require("stringio");
  self.$require("prawn/document"+ '/../' + "document/bounding_box");
  self.$require("prawn/document"+ '/../' + "document/column_box");
  self.$require("prawn/document"+ '/../' + "document/internals");
  self.$require("prawn/document"+ '/../' + "document/span");
  return (function($base, $parent_nesting) {
    var $Prawn, self = $Prawn = $module($base, 'Prawn');

    var def = self.$$proto, $nesting = [self].concat($parent_nesting);

    (function($base, $super, $parent_nesting) {
      function $Document(){};
      var self = $Document = $klass($base, $super, 'Document', $Document);

      var def = self.$$proto, $nesting = [self].concat($parent_nesting), TMP_Document_extensions_1, TMP_Document_inherited_3, TMP_Document_generate_4, TMP_Document_initialize_5, TMP_Document_start_new_page_9, TMP_Document_page_count_10, TMP_Document_go_to_page_11, TMP_Document_y$eq_12, TMP_Document_cursor_13, TMP_Document_move_cursor_to_14, TMP_Document_float_15, TMP_Document_render_16, TMP_Document_render_file_20, TMP_Document_bounds_21, TMP_Document_reference_bounds_22, TMP_Document_bounds$eq_23, TMP_Document_move_up_24, TMP_Document_move_down_25, TMP_Document_pad_top_26, TMP_Document_pad_bottom_27, TMP_Document_pad_28, TMP_Document_indent_29, TMP_Document_number_pages_31, TMP_Document_group_32, TMP_Document_transaction_33, TMP_Document_page_match$q_34, TMP_Document_mask_36, TMP_Document_initialize_first_page_38, TMP_Document_page_39, TMP_Document_use_graphic_settings_40, TMP_Document_generate_margin_box_41, TMP_Document_apply_margin_options_44, TMP_Document_font_metric_cache_45;

      def.margin_box = def.page_number = def.background = def.bounding_box = def.font_metric_cache = nil;
      
      self.$include(Opal.const_get_qualified(Opal.const_get_qualified(Opal.const_get_relative($nesting, 'Prawn'), 'Document'), 'Internals'));
      self.$include(Opal.const_get_qualified(Opal.const_get_qualified(Opal.const_get_relative($nesting, 'PDF'), 'Core'), 'Annotations'));
      self.$include(Opal.const_get_qualified(Opal.const_get_qualified(Opal.const_get_relative($nesting, 'PDF'), 'Core'), 'Destinations'));
      self.$include(Opal.const_get_qualified(Opal.const_get_qualified(Opal.const_get_relative($nesting, 'Prawn'), 'Document'), 'Security'));
      self.$include(Opal.const_get_qualified(Opal.const_get_relative($nesting, 'Prawn'), 'Text'));
      self.$include(Opal.const_get_qualified(Opal.const_get_relative($nesting, 'Prawn'), 'Graphics'));
      self.$include(Opal.const_get_qualified(Opal.const_get_relative($nesting, 'Prawn'), 'Images'));
      self.$include(Opal.const_get_qualified(Opal.const_get_relative($nesting, 'Prawn'), 'Stamp'));
      self.$include(Opal.const_get_qualified(Opal.const_get_relative($nesting, 'Prawn'), 'SoftMask'));
      self.$include(Opal.const_get_qualified(Opal.const_get_relative($nesting, 'Prawn'), 'TransformationStack'));
      Opal.const_set($nesting[0], 'VALID_OPTIONS', ["page_size", "page_layout", "margin", "left_margin", "right_margin", "top_margin", "bottom_margin", "skip_page_creation", "compress", "background", "info", "text_formatter", "print_scaling"]);
      Opal.defs(self, '$extensions', TMP_Document_extensions_1 = function $$extensions() {
        var $a, self = this;
        if (self.extensions == null) self.extensions = nil;

        return (self.extensions = ($truthy($a = self.extensions) ? $a : []))
      }, TMP_Document_extensions_1.$$arity = 0);
      Opal.defs(self, '$inherited', TMP_Document_inherited_3 = function $$inherited(base) {
        var TMP_2, self = this;

        return $send(self.$extensions(), 'each', [], (TMP_2 = function(e){var self = TMP_2.$$s || this;
if (e == null) e = nil;
        return base.$extensions()['$<<'](e)}, TMP_2.$$s = self, TMP_2.$$arity = 1, TMP_2))
      }, TMP_Document_inherited_3.$$arity = 1);
      self.$attr_accessor("margin_box");
      self.$attr_reader("margins", "y");
      self.$attr_accessor("page_number");
      self.$attr_accessor("text_formatter");
      Opal.defs(self, '$generate', TMP_Document_generate_4 = function $$generate(filename, options) {
        var self = this, $iter = TMP_Document_generate_4.$$p, block = $iter || nil, pdf = nil;

        if (options == null) {
          options = $hash2([], {});
        }
        if ($iter) TMP_Document_generate_4.$$p = null;
        
        pdf = $send(self, 'new', [options], block.$to_proc());
        return pdf.$render_file(filename);
      }, TMP_Document_generate_4.$$arity = -2);
      
      Opal.defn(self, '$initialize', TMP_Document_initialize_5 = function $$initialize(options) {
        var TMP_6, $a, self = this, $iter = TMP_Document_initialize_5.$$p, block = $iter || nil, $writer = nil;

        if (options == null) {
          options = $hash2([], {});
        }
        if ($iter) TMP_Document_initialize_5.$$p = null;
        
        options = options.$dup();
        Opal.const_get_relative($nesting, 'Prawn').$verify_options(Opal.const_get_relative($nesting, 'VALID_OPTIONS'), options);
        $send(self.$class().$extensions(), 'reverse_each', [], (TMP_6 = function(e){var self = TMP_6.$$s || this;
if (e == null) e = nil;
        return self.$extend(e)}, TMP_6.$$s = self, TMP_6.$$arity = 1, TMP_6));
        
        $writer = [Opal.const_get_qualified(Opal.const_get_qualified(Opal.const_get_relative($nesting, 'PDF'), 'Core'), 'DocumentState').$new(options)];
        $send(self, 'state=', Opal.to_a($writer));
        $writer[$rb_minus($writer["length"], 1)];;
        self.$state().$populate_pages_from_store(self);
        if ($truthy(self.$state().$store().$min_version())) {
          self.$renderer().$min_version(self.$state().$store().$min_version())};
        if (options['$[]']("print_scaling")['$==']("none")) {
          self.$renderer().$min_version(1.6)};
        self.background = options['$[]']("background");
        self.background_scale = ($truthy($a = options['$[]']("background_scale")) ? $a : 1);
        self.font_size = 12;
        self.bounding_box = nil;
        self.margin_box = nil;
        self.page_number = 0;
        self.text_formatter = ($truthy($a = options.$delete("text_formatter")) ? $a : Opal.const_get_qualified(Opal.const_get_qualified(Opal.const_get_relative($nesting, 'Text'), 'Formatted'), 'Parser'));
        
        $writer = ["size", options.$delete("page_size")];
        $send(options, '[]=', Opal.to_a($writer));
        $writer[$rb_minus($writer["length"], 1)];;
        
        $writer = ["layout", options.$delete("page_layout")];
        $send(options, '[]=', Opal.to_a($writer));
        $writer[$rb_minus($writer["length"], 1)];;
        self.$initialize_first_page(options);
        self.bounding_box = self.margin_box;
        if ($truthy(block)) {
          if ($truthy($rb_lt(block.$arity(), 1))) {
            return $send(self, 'instance_eval', [], block.$to_proc())
            } else {
            return block['$[]'](self)
          }
          } else {
          return nil
        };
      }, TMP_Document_initialize_5.$$arity = -1);
      
      Opal.defn(self, '$start_new_page', TMP_Document_start_new_page_9 = function $$start_new_page(options) {
        var $a, $b, TMP_7, TMP_8, self = this, last_page = nil, last_page_size = nil, last_page_layout = nil, last_page_margins = nil, page_options = nil, new_graphic_state = nil, $writer = nil;

        if (options == null) {
          options = $hash2([], {});
        }
        
        if ($truthy((last_page = self.$state().$page()))) {
          
          last_page_size = last_page.$size();
          last_page_layout = last_page.$layout();
          last_page_margins = last_page.$margins().$dup();};
        page_options = $hash2(["size", "layout", "margins"], {"size": ($truthy($a = options['$[]']("size")) ? $a : last_page_size), "layout": ($truthy($a = options['$[]']("layout")) ? $a : last_page_layout), "margins": last_page_margins});
        if ($truthy(last_page)) {
          
          if ($truthy(last_page.$graphic_state())) {
            new_graphic_state = last_page.$graphic_state().$dup()};
          if ($truthy(new_graphic_state)) {
            
            $writer = [$hash2([], {})];
            $send(new_graphic_state, 'color_space=', Opal.to_a($writer));
            $writer[$rb_minus($writer["length"], 1)];};
          page_options['$merge!']($hash2(["graphic_state"], {"graphic_state": new_graphic_state}));};
        
        $writer = [Opal.const_get_qualified(Opal.const_get_qualified(Opal.const_get_relative($nesting, 'PDF'), 'Core'), 'Page').$new(self, page_options)];
        $send(self.$state(), 'page=', Opal.to_a($writer));
        $writer[$rb_minus($writer["length"], 1)];;
        self.$apply_margin_options(options);
        self.$generate_margin_box();
        if ($truthy(($truthy($a = last_page) ? ($truthy($b = last_page.$size()['$!='](self.$state().$page().$size())) ? $b : last_page.$layout()['$!='](self.$state().$page().$layout())) : $a))) {
          self.bounding_box = self.margin_box};
        self.$use_graphic_settings();
        if ($truthy(options['$[]']("orphan"))) {
          return nil
          } else {
          
          self.$state().$insert_page(self.$state().$page(), self.page_number);
          self.page_number = $rb_plus(self.page_number, 1);
          if ($truthy(self.background)) {
            $send(self, 'canvas', [], (TMP_7 = function(){var self = TMP_7.$$s || this;
              if (self.background == null) self.background = nil;
              if (self.background_scale == null) self.background_scale = nil;

            return self.$image(self.background, $hash2(["scale", "at"], {"scale": self.background_scale, "at": self.$bounds().$top_left()}))}, TMP_7.$$s = self, TMP_7.$$arity = 0, TMP_7))};
          self.y = self.bounding_box.$absolute_top();
          return $send(self, 'float', [], (TMP_8 = function(){var self = TMP_8.$$s || this;

          return self.$state().$on_page_create_action(self)}, TMP_8.$$s = self, TMP_8.$$arity = 0, TMP_8));
        };
      }, TMP_Document_start_new_page_9.$$arity = -1);
      
      Opal.defn(self, '$page_count', TMP_Document_page_count_10 = function $$page_count() {
        var self = this;

        return self.$state().$page_count()
      }, TMP_Document_page_count_10.$$arity = 0);
      
      Opal.defn(self, '$go_to_page', TMP_Document_go_to_page_11 = function $$go_to_page(k) {
        var self = this, $writer = nil;

        
        self.page_number = k;
        
        $writer = [self.$state().$pages()['$[]']($rb_minus(k, 1))];
        $send(self.$state(), 'page=', Opal.to_a($writer));
        $writer[$rb_minus($writer["length"], 1)];;
        self.$generate_margin_box();
        return (self.y = self.bounding_box.$absolute_top());
      }, TMP_Document_go_to_page_11.$$arity = 1);
      
      Opal.defn(self, '$y=', TMP_Document_y$eq_12 = function(new_y) {
        var self = this;

        
        self.y = new_y;
        return self.$bounds().$update_height();
      }, TMP_Document_y$eq_12.$$arity = 1);
      
      Opal.defn(self, '$cursor', TMP_Document_cursor_13 = function $$cursor() {
        var self = this;

        return $rb_minus(self.$y(), self.$bounds().$absolute_bottom())
      }, TMP_Document_cursor_13.$$arity = 0);
      
      Opal.defn(self, '$move_cursor_to', TMP_Document_move_cursor_to_14 = function $$move_cursor_to(new_y) {
        var self = this, $writer = nil;

        
        $writer = [$rb_plus(new_y, self.$bounds().$absolute_bottom())];
        $send(self, 'y=', Opal.to_a($writer));
        return $writer[$rb_minus($writer["length"], 1)];
      }, TMP_Document_move_cursor_to_14.$$arity = 1);
      
      Opal.defn(self, '$float', TMP_Document_float_15 = function() {
        var self = this, $iter = TMP_Document_float_15.$$p, $yield = $iter || nil, original_page = nil, original_y = nil, $writer = nil;

        if ($iter) TMP_Document_float_15.$$p = null;
        
        original_page = self.$page_number();
        original_y = self.$y();
        Opal.yieldX($yield, []);
        if (self.$page_number()['$=='](original_page)) {
          } else {
          self.$go_to_page(original_page)
        };
        
        $writer = [original_y];
        $send(self, 'y=', Opal.to_a($writer));
        return $writer[$rb_minus($writer["length"], 1)];;
      }, TMP_Document_float_15.$$arity = 0);
      
      Opal.defn(self, '$render', TMP_Document_render_16 = function $$render($a_rest) {
        var TMP_17, self = this, a, $iter = TMP_Document_render_16.$$p, b = $iter || nil;

        var $args_len = arguments.length, $rest_len = $args_len - 0;
        if ($rest_len < 0) { $rest_len = 0; }
        a = new Array($rest_len);
        for (var $arg_idx = 0; $arg_idx < $args_len; $arg_idx++) {
          a[$arg_idx - 0] = arguments[$arg_idx];
        }
        if ($iter) TMP_Document_render_16.$$p = null;
        
        $send(Opal.Range.$new(1, self.$page_count(), false), 'each', [], (TMP_17 = function(i){var self = TMP_17.$$s || this, TMP_18;
if (i == null) i = nil;
        
          self.$go_to_page(i);
          return $send(self.$repeaters(), 'each', [], (TMP_18 = function(r){var self = TMP_18.$$s || this;
if (r == null) r = nil;
          return r.$run(i)}, TMP_18.$$s = self, TMP_18.$$arity = 1, TMP_18));}, TMP_17.$$s = self, TMP_17.$$arity = 1, TMP_17));
        return $send(self.$renderer(), 'render', Opal.to_a(a), b.$to_proc());
      }, TMP_Document_render_16.$$arity = -1);
      
      Opal.defn(self, '$render_file', TMP_Document_render_file_20 = function $$render_file(filename) {
        var TMP_19, self = this;

        return $send(Opal.const_get_relative($nesting, 'File'), 'open', [filename, "wb"], (TMP_19 = function(f){var self = TMP_19.$$s || this;
if (f == null) f = nil;
        return self.$render(f)}, TMP_19.$$s = self, TMP_19.$$arity = 1, TMP_19))
      }, TMP_Document_render_file_20.$$arity = 1);
      
      Opal.defn(self, '$bounds', TMP_Document_bounds_21 = function $$bounds() {
        var self = this;

        return self.bounding_box
      }, TMP_Document_bounds_21.$$arity = 0);
      
      Opal.defn(self, '$reference_bounds', TMP_Document_reference_bounds_22 = function $$reference_bounds() {
        var self = this;

        return self.bounding_box.$reference_bounds()
      }, TMP_Document_reference_bounds_22.$$arity = 0);
      
      Opal.defn(self, '$bounds=', TMP_Document_bounds$eq_23 = function(bounding_box) {
        var self = this;

        return (self.bounding_box = bounding_box)
      }, TMP_Document_bounds$eq_23.$$arity = 1);
      
      Opal.defn(self, '$move_up', TMP_Document_move_up_24 = function $$move_up(n) {
        var self = this, $writer = nil;

        
        $writer = [$rb_plus(self.$y(), n)];
        $send(self, 'y=', Opal.to_a($writer));
        return $writer[$rb_minus($writer["length"], 1)];
      }, TMP_Document_move_up_24.$$arity = 1);
      
      Opal.defn(self, '$move_down', TMP_Document_move_down_25 = function $$move_down(n) {
        var self = this, $writer = nil;

        
        $writer = [$rb_minus(self.$y(), n)];
        $send(self, 'y=', Opal.to_a($writer));
        return $writer[$rb_minus($writer["length"], 1)];
      }, TMP_Document_move_down_25.$$arity = 1);
      
      Opal.defn(self, '$pad_top', TMP_Document_pad_top_26 = function $$pad_top(y) {
        var self = this, $iter = TMP_Document_pad_top_26.$$p, $yield = $iter || nil;

        if ($iter) TMP_Document_pad_top_26.$$p = null;
        
        self.$move_down(y);
        return Opal.yieldX($yield, []);;
      }, TMP_Document_pad_top_26.$$arity = 1);
      
      Opal.defn(self, '$pad_bottom', TMP_Document_pad_bottom_27 = function $$pad_bottom(y) {
        var self = this, $iter = TMP_Document_pad_bottom_27.$$p, $yield = $iter || nil;

        if ($iter) TMP_Document_pad_bottom_27.$$p = null;
        
        Opal.yieldX($yield, []);
        return self.$move_down(y);
      }, TMP_Document_pad_bottom_27.$$arity = 1);
      
      Opal.defn(self, '$pad', TMP_Document_pad_28 = function $$pad(y) {
        var self = this, $iter = TMP_Document_pad_28.$$p, $yield = $iter || nil;

        if ($iter) TMP_Document_pad_28.$$p = null;
        
        self.$move_down(y);
        Opal.yieldX($yield, []);
        return self.$move_down(y);
      }, TMP_Document_pad_28.$$arity = 1);
      
      Opal.defn(self, '$indent', TMP_Document_indent_29 = function $$indent(left, right) {
        var self = this, $iter = TMP_Document_indent_29.$$p, block = $iter || nil;

        if (right == null) {
          right = 0;
        }
        if ($iter) TMP_Document_indent_29.$$p = null;
        return $send(self.$bounds(), 'indent', [left, right], block.$to_proc())
      }, TMP_Document_indent_29.$$arity = -2);
      
      Opal.defn(self, '$number_pages', TMP_Document_number_pages_31 = function $$number_pages(string, options) {
        var TMP_30, self = this, opts = nil, start_count_at = nil, page_filter = nil, total_pages = nil, txtcolor = nil, $writer = nil, start_count = nil, pseudopage = nil;

        if (options == null) {
          options = $hash2([], {});
        }
        
        opts = options.$dup();
        start_count_at = opts.$delete("start_count_at").$to_i();
        if ($truthy(opts['$key?']("page_filter"))) {
          page_filter = opts.$delete("page_filter")
          } else {
          page_filter = "all"
        };
        total_pages = opts.$delete("total_pages");
        txtcolor = opts.$delete("color");
        if ($truthy(opts['$key?']("height"))) {
          } else {
          
          $writer = ["height", 50];
          $send(opts, '[]=', Opal.to_a($writer));
          $writer[$rb_minus($writer["length"], 1)];
        };
        start_count = false;
        pseudopage = 0;
        return $send(Opal.Range.$new(1, self.$page_count(), false), 'each', [], (TMP_30 = function(p){var self = TMP_30.$$s || this, $case = nil, str = nil;
if (p == null) p = nil;
        
          if ($truthy(start_count)) {
            } else {
            pseudopage = (function() {$case = start_count_at;
            if ((0)['$===']($case)) {return 1}
            else {return start_count_at.$to_i()}})()
          };
          if ($truthy(self['$page_match?'](page_filter, p))) {
            
            self.$go_to_page(p);
            if ($truthy(txtcolor['$nil?']())) {
              } else {
              self.$fill_color(txtcolor)
            };
            total_pages = (function() {if ($truthy(total_pages['$nil?']())) {
              return self.$page_count()
              } else {
              return total_pages
            }; return nil; })();
            str = string.$gsub("<page>", "" + (pseudopage)).$gsub("<total>", "" + (total_pages));
            self.$text_box(str, opts);
            start_count = true;};
          if ($truthy(start_count)) {
            return (pseudopage = $rb_plus(pseudopage, 1))
            } else {
            return nil
          };}, TMP_30.$$s = self, TMP_30.$$arity = 1, TMP_30));
      }, TMP_Document_number_pages_31.$$arity = -2);
      
      Opal.defn(self, '$group', TMP_Document_group_32 = function $$group($a_rest) {
        var self = this, a, $iter = TMP_Document_group_32.$$p, b = $iter || nil;

        var $args_len = arguments.length, $rest_len = $args_len - 0;
        if ($rest_len < 0) { $rest_len = 0; }
        a = new Array($rest_len);
        for (var $arg_idx = 0; $arg_idx < $args_len; $arg_idx++) {
          a[$arg_idx - 0] = arguments[$arg_idx];
        }
        if ($iter) TMP_Document_group_32.$$p = null;
        return self.$fail(Opal.const_get_relative($nesting, 'NotImplementedError'), "" + "Document#group has been disabled because its implementation " + "lead to corrupted documents whenever a page boundary was " + "crossed. We will try to work on reimplementing it in a " + "future release")
      }, TMP_Document_group_32.$$arity = -1);
      
      Opal.defn(self, '$transaction', TMP_Document_transaction_33 = function $$transaction() {
        var self = this;

        return self.$fail(Opal.const_get_relative($nesting, 'NotImplementedError'), "" + "Document#transaction has been disabled because its implementation " + "lead to corrupted documents whenever a page boundary was " + "crossed. We will try to work on reimplementing it in a " + "future release")
      }, TMP_Document_transaction_33.$$arity = 0);
      
      Opal.defn(self, '$page_match?', TMP_Document_page_match$q_34 = function(page_filter, page_number) {
        var self = this, $case = nil;

        return (function() {$case = page_filter;
        if ("all"['$===']($case)) {return true}
        else if ("odd"['$===']($case)) {return page_number['$odd?']()}
        else if ("even"['$===']($case)) {return page_number['$even?']()}
        else if (Opal.const_get_relative($nesting, 'Range')['$===']($case) || Opal.const_get_relative($nesting, 'Array')['$===']($case)) {return page_filter['$include?'](page_number)}
        else if (Opal.const_get_relative($nesting, 'Proc')['$===']($case)) {return page_filter.$call(page_number)}
        else { return nil }})()
      }, TMP_Document_page_match$q_34.$$arity = 2);
      
      Opal.defn(self, '$mask', TMP_Document_mask_36 = function $$mask($a_rest) {
        var TMP_35, TMP_37, self = this, fields, $iter = TMP_Document_mask_36.$$p, $yield = $iter || nil, stored = nil;

        var $args_len = arguments.length, $rest_len = $args_len - 0;
        if ($rest_len < 0) { $rest_len = 0; }
        fields = new Array($rest_len);
        for (var $arg_idx = 0; $arg_idx < $args_len; $arg_idx++) {
          fields[$arg_idx - 0] = arguments[$arg_idx];
        }
        if ($iter) TMP_Document_mask_36.$$p = null;
        
        stored = $hash2([], {});
        $send(fields, 'each', [], (TMP_35 = function(f){var self = TMP_35.$$s || this, $writer = nil;
if (f == null) f = nil;
        
          $writer = [f, self.$send(f)];
          $send(stored, '[]=', Opal.to_a($writer));
          return $writer[$rb_minus($writer["length"], 1)];}, TMP_35.$$s = self, TMP_35.$$arity = 1, TMP_35));
        Opal.yieldX($yield, []);
        return $send(fields, 'each', [], (TMP_37 = function(f){var self = TMP_37.$$s || this;
if (f == null) f = nil;
        return self.$send("" + (f) + "=", stored['$[]'](f))}, TMP_37.$$s = self, TMP_37.$$arity = 1, TMP_37));
      }, TMP_Document_mask_36.$$arity = -1);
      
      Opal.defn(self, '$initialize_first_page', TMP_Document_initialize_first_page_38 = function $$initialize_first_page(options) {
        var self = this;

        if ($truthy(options['$[]']("skip_page_creation"))) {
          return self.$start_new_page(options.$merge($hash2(["orphan"], {"orphan": true})))
          } else {
          return self.$start_new_page(options)
        }
      }, TMP_Document_initialize_first_page_38.$$arity = 1);
      self.$attr_accessor("state");
      
      Opal.defn(self, '$page', TMP_Document_page_39 = function $$page() {
        var self = this;

        return self.$state().$page()
      }, TMP_Document_page_39.$$arity = 0);
      self.$private();
      
      Opal.defn(self, '$use_graphic_settings', TMP_Document_use_graphic_settings_40 = function $$use_graphic_settings(override_settings) {
        var $a, self = this;

        if (override_settings == null) {
          override_settings = false;
        }
        
        if ($truthy(($truthy($a = self.$current_fill_color()['$!=']("000000")) ? $a : override_settings))) {
          self.$set_fill_color()};
        if ($truthy(($truthy($a = self.$current_stroke_color()['$!=']("000000")) ? $a : override_settings))) {
          self.$set_stroke_color()};
        if ($truthy(($truthy($a = self.$line_width()['$!='](1)) ? $a : override_settings))) {
          self.$write_line_width()};
        if ($truthy(($truthy($a = self.$cap_style()['$!=']("butt")) ? $a : override_settings))) {
          self.$write_stroke_cap_style()};
        if ($truthy(($truthy($a = self.$join_style()['$!=']("miter")) ? $a : override_settings))) {
          self.$write_stroke_join_style()};
        if ($truthy(($truthy($a = self['$dashed?']()) ? $a : override_settings))) {
          return self.$write_stroke_dash()
          } else {
          return nil
        };
      }, TMP_Document_use_graphic_settings_40.$$arity = -1);
      
      Opal.defn(self, '$generate_margin_box', TMP_Document_generate_margin_box_41 = function $$generate_margin_box() {
        var $a, self = this, old_margin_box = nil, page = nil;

        
        old_margin_box = self.margin_box;
        page = self.$state().$page();
        self.margin_box = Opal.const_get_relative($nesting, 'BoundingBox').$new(self, nil, [page.$margins()['$[]']("left"), $rb_minus(page.$dimensions()['$[]'](-1), page.$margins()['$[]']("top"))], $hash2(["width", "height"], {"width": $rb_minus(page.$dimensions()['$[]'](-2), $rb_plus(page.$margins()['$[]']("left"), page.$margins()['$[]']("right"))), "height": $rb_minus(page.$dimensions()['$[]'](-1), $rb_plus(page.$margins()['$[]']("top"), page.$margins()['$[]']("bottom")))}));
        if ($truthy(old_margin_box)) {
          
          self.margin_box.$add_left_padding(old_margin_box.$total_left_padding());
          self.margin_box.$add_right_padding(old_margin_box.$total_right_padding());};
        if ($truthy(($truthy($a = self.bounding_box) ? self.bounding_box.$parent() : $a))) {
          return nil
          } else {
          return (self.bounding_box = self.margin_box)
        };
      }, TMP_Document_generate_margin_box_41.$$arity = 0);
      
      Opal.defn(self, '$apply_margin_options', TMP_Document_apply_margin_options_44 = function $$apply_margin_options(options) {
        var TMP_42, TMP_43, self = this, margin = nil, positions = nil;

        
        if ($truthy(options['$[]']("margin"))) {
          
          margin = self.$Array(options['$[]']("margin"));
          positions = $hash(4, [0, 1, 2, 3], 3, [0, 1, 2, 1], 2, [0, 1, 0, 1], 1, [0, 0, 0, 0])['$[]'](margin.$length());
          $send(["top", "right", "bottom", "left"].$zip(positions), 'each', [], (TMP_42 = function(p, i){var self = TMP_42.$$s || this, $a, $writer = nil;
if (p == null) p = nil;if (i == null) i = nil;
          return ($truthy($a = options['$[]']("" + (p) + "_margin")) ? $a : (($writer = ["" + (p) + "_margin", margin['$[]'](i)]), $send(options, '[]=', Opal.to_a($writer)), $writer[$rb_minus($writer["length"], 1)]))}, TMP_42.$$s = self, TMP_42.$$arity = 2, TMP_42));};
        return $send(["left", "right", "top", "bottom"], 'each', [], (TMP_43 = function(side){var self = TMP_43.$$s || this, $writer = nil;
if (side == null) side = nil;
        if ($truthy((margin = options['$[]']("" + (side) + "_margin")))) {
            
            $writer = [side, margin];
            $send(self.$state().$page().$margins(), '[]=', Opal.to_a($writer));
            return $writer[$rb_minus($writer["length"], 1)];
            } else {
            return nil
          }}, TMP_43.$$s = self, TMP_43.$$arity = 1, TMP_43));
      }, TMP_Document_apply_margin_options_44.$$arity = 1);
      return (Opal.defn(self, '$font_metric_cache', TMP_Document_font_metric_cache_45 = function $$font_metric_cache() {
        var $a, self = this;

        return (self.font_metric_cache = ($truthy($a = self.font_metric_cache) ? $a : Opal.const_get_relative($nesting, 'FontMetricCache').$new(self)))
      }, TMP_Document_font_metric_cache_45.$$arity = 0), nil) && 'font_metric_cache';
    })($nesting[0], null, $nesting)
  })($nesting[0], $nesting);
};

/* Generated by Opal 0.11.0 */
Opal.modules["prawn/encoding"] = function(Opal) {
  var self = Opal.top, $nesting = [], nil = Opal.nil, $breaker = Opal.breaker, $slice = Opal.slice, $module = Opal.module, $klass = Opal.klass;

  return (function($base, $parent_nesting) {
    var $Prawn, self = $Prawn = $module($base, 'Prawn');

    var def = self.$$proto, $nesting = [self].concat($parent_nesting);

    (function($base, $parent_nesting) {
      var $Encoding, self = $Encoding = $module($base, 'Encoding');

      var def = self.$$proto, $nesting = [self].concat($parent_nesting);

      (function($base, $super, $parent_nesting) {
        function $WinAnsi(){};
        var self = $WinAnsi = $klass($base, $super, 'WinAnsi', $WinAnsi);

        var def = self.$$proto, $nesting = [self].concat($parent_nesting);

        return Opal.const_set($nesting[0], 'CHARACTERS', [".notdef", ".notdef", ".notdef", ".notdef", ".notdef", ".notdef", ".notdef", ".notdef", ".notdef", ".notdef", ".notdef", ".notdef", ".notdef", ".notdef", ".notdef", ".notdef", ".notdef", ".notdef", ".notdef", ".notdef", ".notdef", ".notdef", ".notdef", ".notdef", ".notdef", ".notdef", ".notdef", ".notdef", ".notdef", ".notdef", ".notdef", ".notdef", "space", "exclam", "quotedbl", "numbersign", "dollar", "percent", "ampersand", "quotesingle", "parenleft", "parenright", "asterisk", "plus", "comma", "hyphen", "period", "slash", "zero", "one", "two", "three", "four", "five", "six", "seven", "eight", "nine", "colon", "semicolon", "less", "equal", "greater", "question", "at", "A", "B", "C", "D", "E", "F", "G", "H", "I", "J", "K", "L", "M", "N", "O", "P", "Q", "R", "S", "T", "U", "V", "W", "X", "Y", "Z", "bracketleft", "backslash", "bracketright", "asciicircum", "underscore", "grave", "a", "b", "c", "d", "e", "f", "g", "h", "i", "j", "k", "l", "m", "n", "o", "p", "q", "r", "s", "t", "u", "v", "w", "x", "y", "z", "braceleft", "bar", "braceright", "asciitilde", ".notdef", "Euro", ".notdef", "quotesinglbase", "florin", "quotedblbase", "ellipsis", "dagger", "daggerdbl", "circumflex", "perthousand", "Scaron", "guilsinglleft", "OE", ".notdef", "Zcaron", ".notdef", ".notdef", "quoteleft", "quoteright", "quotedblleft", "quotedblright", "bullet", "endash", "emdash", "tilde", "trademark", "scaron", "guilsinglright", "oe", ".notdef", "zcaron", "ydieresis", "space", "exclamdown", "cent", "sterling", "currency", "yen", "brokenbar", "section", "dieresis", "copyright", "ordfeminine", "guillemotleft", "logicalnot", "hyphen", "registered", "macron", "degree", "plusminus", "twosuperior", "threesuperior", "acute", "mu", "paragraph", "periodcentered", "cedilla", "onesuperior", "ordmasculine", "guillemotright", "onequarter", "onehalf", "threequarters", "questiondown", "Agrave", "Aacute", "Acircumflex", "Atilde", "Adieresis", "Aring", "AE", "Ccedilla", "Egrave", "Eacute", "Ecircumflex", "Edieresis", "Igrave", "Iacute", "Icircumflex", "Idieresis", "Eth", "Ntilde", "Ograve", "Oacute", "Ocircumflex", "Otilde", "Odieresis", "multiply", "Oslash", "Ugrave", "Uacute", "Ucircumflex", "Udieresis", "Yacute", "Thorn", "germandbls", "agrave", "aacute", "acircumflex", "atilde", "adieresis", "aring", "ae", "ccedilla", "egrave", "eacute", "ecircumflex", "edieresis", "igrave", "iacute", "icircumflex", "idieresis", "eth", "ntilde", "ograve", "oacute", "ocircumflex", "otilde", "odieresis", "divide", "oslash", "ugrave", "uacute", "ucircumflex", "udieresis", "yacute", "thorn", "ydieresis"])
      })($nesting[0], null, $nesting)
    })($nesting[0], $nesting)
  })($nesting[0], $nesting)
};

/* Generated by Opal 0.11.0 */
Opal.modules["prawn/font/afm"] = function(Opal) {
  function $rb_minus(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs - rhs : lhs['$-'](rhs);
  }
  function $rb_plus(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs + rhs : lhs['$+'](rhs);
  }
  function $rb_divide(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs / rhs : lhs['$/'](rhs);
  }
  function $rb_times(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs * rhs : lhs['$*'](rhs);
  }
  var self = Opal.top, $nesting = [], nil = Opal.nil, $breaker = Opal.breaker, $slice = Opal.slice, $module = Opal.module, $klass = Opal.klass, $send = Opal.send, $truthy = Opal.truthy, $hash2 = Opal.hash2, $gvars = Opal.gvars, $range = Opal.range;

  Opal.add_stubs(['$attr_accessor', '$hide_m17n_warning=', '$-', '$[]', '$split', '$+', '$attr_reader', '$include?', '$fail', '$new', '$dup', '$=~', '$<<', '$==', '$find_font', '$parse_afm', '$[]=', '$to_i', '$Float', '$bbox', '$map', '$Integer', '$/', '$size', '$partition', '$kern', '$is_a?', '$inject', '$*', '$unscaled_width_of', '$join', '$any?', '$encode', '$raise', '$length', '$!', '$normalize_encoding', '$private', '$to_sym', '$name', '$symbolic?', '$merge!', '$ref!', '$attributes', '$find', '$metrics_path', '$class', '$exist?', '$foreach', '$===', '$push', '$pop', '$rstrip', '$to_s', '$parse_generic_afm_attribute', '$zip', '$to_a', '$each_with_object', '$each_value', '$to_proc', '$freeze', '$downcase', '$Array', '$each_byte', '$-@', '$last', '$pack', '$respond_to?', '$force_encoding', '$bytes']);
  
  self.$require("prawn/font/afm"+ '/../' + "../encoding");
  return (function($base, $parent_nesting) {
    var $Prawn, self = $Prawn = $module($base, 'Prawn');

    var def = self.$$proto, $nesting = [self].concat($parent_nesting);

    (function($base, $super, $parent_nesting) {
      function $Font(){};
      var self = $Font = $klass($base, $super, 'Font', $Font);

      var def = self.$$proto, $nesting = [self].concat($parent_nesting);

      return (function($base, $super, $parent_nesting) {
        function $AFM(){};
        var self = $AFM = $klass($base, $super, 'AFM', $AFM);

        var def = self.$$proto, $nesting = [self].concat($parent_nesting), TMP_AFM_unicode$q_1, TMP_AFM_metrics_path_2, TMP_AFM_initialize_3, TMP_AFM_bbox_5, TMP_AFM_compute_width_of_8, TMP_AFM_has_kerning_data$q_9, TMP_AFM_normalize_encoding_10, TMP_AFM_to_utf8_11, TMP_AFM_character_count_12, TMP_AFM_encode_text_13, TMP_AFM_glyph_present$q_14, TMP_AFM_register_15, TMP_AFM_symbolic$q_16, TMP_AFM_find_font_18, TMP_AFM_parse_afm_23, TMP_AFM_parse_generic_afm_attribute_24, TMP_AFM_kern_27, TMP_AFM_unscaled_width_of_29, $writer = nil;

        def.name = def.attributes = def.ascender = def.descender = def.bbox = def.kern_pairs = def.document = nil;
        
        (function(self, $parent_nesting) {
          var def = self.$$proto, $nesting = [self].concat($parent_nesting);

          return self.$attr_accessor("hide_m17n_warning")
        })(Opal.get_singleton_class(self), $nesting);
        
        $writer = [false];
        $send(self, 'hide_m17n_warning=', Opal.to_a($writer));
        $writer[$rb_minus($writer["length"], 1)];;
        Opal.const_set($nesting[0], 'BUILT_INS', ["Courier", "Helvetica", "Times-Roman", "Symbol", "ZapfDingbats", "Courier-Bold", "Courier-Oblique", "Courier-BoldOblique", "Times-Bold", "Times-Italic", "Times-BoldItalic", "Helvetica-Bold", "Helvetica-Oblique", "Helvetica-BoldOblique"]);
        
        Opal.defn(self, '$unicode?', TMP_AFM_unicode$q_1 = function() {
          var self = this;

          return false
        }, TMP_AFM_unicode$q_1.$$arity = 0);
        Opal.defs(self, '$metrics_path', TMP_AFM_metrics_path_2 = function $$metrics_path() {
          var $a, self = this, m = nil;
          if (self.metrics_path == null) self.metrics_path = nil;

          if ($truthy((m = Opal.const_get_relative($nesting, 'ENV')['$[]']("METRICS")))) {
            return (self.metrics_path = ($truthy($a = self.metrics_path) ? $a : m.$split(":")))
            } else {
            return (self.metrics_path = ($truthy($a = self.metrics_path) ? $a : [".", "/usr/lib/afm", "/usr/local/lib/afm", "/usr/openwin/lib/fonts/afm", $rb_plus(Opal.const_get_qualified(Opal.const_get_relative($nesting, 'Prawn'), 'DATADIR'), "/fonts")]))
          }
        }, TMP_AFM_metrics_path_2.$$arity = 0);
        self.$attr_reader("attributes");
        
        Opal.defn(self, '$initialize', TMP_AFM_initialize_3 = function $$initialize(document, name, options) {
          var $a, $b, self = this, $iter = TMP_AFM_initialize_3.$$p, $yield = $iter || nil, file_name = nil, font_data = nil, $writer = nil, $zuper = nil, $zuper_i = nil, $zuper_ii = nil;

          if (options == null) {
            options = $hash2([], {});
          }
          if ($iter) TMP_AFM_initialize_3.$$p = null;
          // Prepare super implicit arguments
          for($zuper_i = 0, $zuper_ii = arguments.length, $zuper = new Array($zuper_ii); $zuper_i < $zuper_ii; $zuper_i++) {
            $zuper[$zuper_i] = arguments[$zuper_i];
          }
          
          if ($truthy(Opal.const_get_relative($nesting, 'BUILT_INS')['$include?'](name))) {
            } else {
            self.$fail(Opal.const_get_qualified(Opal.const_get_qualified(Opal.const_get_relative($nesting, 'Prawn'), 'Errors'), 'UnknownFont'), "" + (name) + " is not a known font.")
          };
          $send(self, Opal.find_super_dispatcher(self, 'initialize', TMP_AFM_initialize_3, false), $zuper, $iter);
          (Opal.class_variable_set($AFM, '@@font_data', ($truthy($a = (($b = $AFM.$$cvars['@@font_data']) == null ? nil : $b)) ? $a : Opal.const_get_relative($nesting, 'SynchronizedCache').$new())));
          file_name = self.name.$dup();
          if ($truthy(file_name['$=~'](/\.afm$/))) {
            } else {
            file_name['$<<'](".afm")
          };
          file_name = (function() {if (file_name['$[]'](0)['$==']("/")) {
            return file_name
            } else {
            return self.$find_font(file_name)
          }; return nil; })();
          font_data = ($truthy($a = (($b = $AFM.$$cvars['@@font_data']) == null ? nil : $b)['$[]'](file_name)) ? $a : (($writer = [file_name, self.$parse_afm(file_name)]), $send((($b = $AFM.$$cvars['@@font_data']) == null ? nil : $b), '[]=', Opal.to_a($writer)), $writer[$rb_minus($writer["length"], 1)]));
          self.glyph_widths = font_data['$[]']("glyph_widths");
          self.glyph_table = font_data['$[]']("glyph_table");
          self.bounding_boxes = font_data['$[]']("bounding_boxes");
          self.kern_pairs = font_data['$[]']("kern_pairs");
          self.kern_pair_table = font_data['$[]']("kern_pair_table");
          self.attributes = font_data['$[]']("attributes");
          self.ascender = self.attributes['$[]']("ascender").$to_i();
          self.descender = self.attributes['$[]']("descender").$to_i();
          return (self.line_gap = $rb_minus(self.$Float($rb_minus(self.$bbox()['$[]'](3), self.$bbox()['$[]'](1))), $rb_minus(self.ascender, self.descender)));
        }, TMP_AFM_initialize_3.$$arity = -3);
        
        Opal.defn(self, '$bbox', TMP_AFM_bbox_5 = function $$bbox() {
          var $a, TMP_4, self = this;

          return (self.bbox = ($truthy($a = self.bbox) ? $a : $send(self.attributes['$[]']("fontbbox").$split(/\s+/), 'map', [], (TMP_4 = function(e){var self = TMP_4.$$s || this;
if (e == null) e = nil;
          return self.$Integer(e)}, TMP_4.$$s = self, TMP_4.$$arity = 1, TMP_4))))
        }, TMP_AFM_bbox_5.$$arity = 0);
        
        Opal.defn(self, '$compute_width_of', TMP_AFM_compute_width_of_8 = function $$compute_width_of(string, options) {
          var $a, $b, TMP_6, TMP_7, self = this, scale = nil, strings = nil, numbers = nil, total_kerning_offset = nil;

          if (options == null) {
            options = $hash2([], {});
          }
          
          scale = $rb_divide(($truthy($a = options['$[]']("size")) ? $a : self.$size()), 1000.0);
          if ($truthy(options['$[]']("kerning"))) {
            
            $b = $send(self.$kern(string), 'partition', [], (TMP_6 = function(e){var self = TMP_6.$$s || this;
if (e == null) e = nil;
            return e['$is_a?'](Opal.const_get_relative($nesting, 'String'))}, TMP_6.$$s = self, TMP_6.$$arity = 1, TMP_6)), $a = Opal.to_ary($b), (strings = ($a[0] == null ? nil : $a[0])), (numbers = ($a[1] == null ? nil : $a[1])), $b;
            total_kerning_offset = $send(numbers, 'inject', [0.0], (TMP_7 = function(s, r){var self = TMP_7.$$s || this;
if (s == null) s = nil;if (r == null) r = nil;
            return $rb_plus(s, r)}, TMP_7.$$s = self, TMP_7.$$arity = 2, TMP_7));
            return $rb_times($rb_minus(self.$unscaled_width_of(strings.$join()), total_kerning_offset), scale);
            } else {
            return $rb_times(self.$unscaled_width_of(string), scale)
          };
        }, TMP_AFM_compute_width_of_8.$$arity = -2);
        
        Opal.defn(self, '$has_kerning_data?', TMP_AFM_has_kerning_data$q_9 = function() {
          var self = this;

          return self.kern_pairs['$any?']()
        }, TMP_AFM_has_kerning_data$q_9.$$arity = 0);
        
        Opal.defn(self, '$normalize_encoding', TMP_AFM_normalize_encoding_10 = function $$normalize_encoding(text) {
          var self = this;

          try {
            return text.$encode("windows-1252")
          } catch ($err) {
            if (Opal.rescue($err, [Opal.const_get_qualified(Opal.const_get_qualified('::', 'Encoding'), 'InvalidByteSequenceError'), Opal.const_get_qualified(Opal.const_get_qualified('::', 'Encoding'), 'UndefinedConversionError')])) {
              try {
                return self.$raise(Opal.const_get_qualified(Opal.const_get_qualified(Opal.const_get_relative($nesting, 'Prawn'), 'Errors'), 'IncompatibleStringEncoding'), "" + "Your document includes text that's not compatible with the Windows-1252 character set.\n" + "If you need full UTF-8 support, use TTF fonts instead of PDF's built-in fonts\n.")
              } finally { Opal.pop_exception() }
            } else { throw $err; }
          }
        }, TMP_AFM_normalize_encoding_10.$$arity = 1);
        
        Opal.defn(self, '$to_utf8', TMP_AFM_to_utf8_11 = function $$to_utf8(text) {
          var self = this;

          return text.$encode("UTF-8")
        }, TMP_AFM_to_utf8_11.$$arity = 1);
        
        Opal.defn(self, '$character_count', TMP_AFM_character_count_12 = function $$character_count(str) {
          var self = this;

          return str.$length()
        }, TMP_AFM_character_count_12.$$arity = 1);
        
        Opal.defn(self, '$encode_text', TMP_AFM_encode_text_13 = function $$encode_text(text, options) {
          var self = this;

          if (options == null) {
            options = $hash2([], {});
          }
          return [[0, (function() {if ($truthy(options['$[]']("kerning"))) {
            return self.$kern(text)
            } else {
            return text
          }; return nil; })()]]
        }, TMP_AFM_encode_text_13.$$arity = -2);
        
        Opal.defn(self, '$glyph_present?', TMP_AFM_glyph_present$q_14 = function(char$) {
          var self = this;

          try {
            return self.$normalize_encoding(char$)['$!']()['$!']()
          } catch ($err) {
            if (Opal.rescue($err, [Opal.const_get_qualified(Opal.const_get_qualified(Opal.const_get_relative($nesting, 'Prawn'), 'Errors'), 'IncompatibleStringEncoding')])) {
              try {
                return false
              } finally { Opal.pop_exception() }
            } else { throw $err; }
          }
        }, TMP_AFM_glyph_present$q_14.$$arity = 1);
        self.$private();
        
        Opal.defn(self, '$register', TMP_AFM_register_15 = function $$register(subset) {
          var self = this, font_dict = nil;

          
          font_dict = $hash2(["Type", "Subtype", "BaseFont"], {"Type": "Font", "Subtype": "Type1", "BaseFont": self.$name().$to_sym()});
          if ($truthy(self['$symbolic?']())) {
            } else {
            font_dict['$merge!']($hash2(["Encoding"], {"Encoding": "WinAnsiEncoding"}))
          };
          return self.document['$ref!'](font_dict);
        }, TMP_AFM_register_15.$$arity = 1);
        
        Opal.defn(self, '$symbolic?', TMP_AFM_symbolic$q_16 = function() {
          var self = this;

          return self.$attributes()['$[]']("characterset")['$==']("Special")
        }, TMP_AFM_symbolic$q_16.$$arity = 0);
        
        Opal.defn(self, '$find_font', TMP_AFM_find_font_18 = function $$find_font(file) {
          var TMP_17, self = this;

          try {
            return $rb_plus($send(self.$class().$metrics_path(), 'find', [], (TMP_17 = function(f){var self = TMP_17.$$s || this;
if (f == null) f = nil;
            return Opal.const_get_relative($nesting, 'File')['$exist?']("" + (f) + "/" + (file))}, TMP_17.$$s = self, TMP_17.$$arity = 1, TMP_17)), "" + "/" + (file))
          } catch ($err) {
            if (Opal.rescue($err, [Opal.const_get_relative($nesting, 'NoMethodError')])) {
              try {
                return self.$raise(Opal.const_get_qualified(Opal.const_get_qualified(Opal.const_get_relative($nesting, 'Prawn'), 'Errors'), 'UnknownFont'), $rb_plus("" + "Couldn't find the font: " + (file) + " in any of:\n", self.$class().$metrics_path().$join("\n")))
              } finally { Opal.pop_exception() }
            } else { throw $err; }
          }
        }, TMP_AFM_find_font_18.$$arity = 1);
        
        Opal.defn(self, '$parse_afm', TMP_AFM_parse_afm_23 = function $$parse_afm(file_name) {
          var TMP_19, TMP_20, TMP_21, self = this, data = nil, section = nil, $writer = nil, character_hash = nil;

          
          data = $hash2(["glyph_widths", "bounding_boxes", "kern_pairs", "attributes"], {"glyph_widths": $hash2([], {}), "bounding_boxes": $hash2([], {}), "kern_pairs": $hash2([], {}), "attributes": $hash2([], {})});
          section = [];
          $send(Opal.const_get_relative($nesting, 'File'), 'foreach', [file_name], (TMP_19 = function(line){var self = TMP_19.$$s || this, $a, $case = nil, name = nil, $writer = nil;
if (line == null) line = nil;
          
            $case = line;
            if (/^Start(\w+)/['$===']($case)) {
            section.$push((($a = $gvars['~']) === nil ? nil : $a['$[]'](1)));
            return nil;;}
            else if (/^End(\w+)/['$===']($case)) {
            section.$pop();
            return nil;;};
            return (function() {$case = section;
            if (["FontMetrics", "CharMetrics"]['$===']($case)) {
            if ($truthy(line['$=~'](/^CH?\s/))) {
              } else {
              return nil;
            };
            name = line['$[]'](/\bN\s+(\.?\w+)\s*;/, 1);
            
            $writer = [name, line['$[]'](/\bWX\s+(\d+)\s*;/, 1).$to_i()];
            $send(data['$[]']("glyph_widths"), '[]=', Opal.to_a($writer));
            $writer[$rb_minus($writer["length"], 1)];;
            
            $writer = [name, line['$[]'](/\bB\s+([^;]+);/, 1).$to_s().$rstrip()];
            $send(data['$[]']("bounding_boxes"), '[]=', Opal.to_a($writer));
            return $writer[$rb_minus($writer["length"], 1)];;}
            else if (["FontMetrics", "KernData", "KernPairs"]['$===']($case)) {
            if ($truthy(line['$=~'](/^KPX\s+(\.?\w+)\s+(\.?\w+)\s+(-?\d+)/))) {
              } else {
              return nil;
            };
            
            $writer = [[(($a = $gvars['~']) === nil ? nil : $a['$[]'](1)), (($a = $gvars['~']) === nil ? nil : $a['$[]'](2))], (($a = $gvars['~']) === nil ? nil : $a['$[]'](3)).$to_i()];
            $send(data['$[]']("kern_pairs"), '[]=', Opal.to_a($writer));
            return $writer[$rb_minus($writer["length"], 1)];;}
            else if (["FontMetrics", "KernData", "TrackKern"]['$===']($case) || ["FontMetrics", "Composites"]['$===']($case)) {return nil;}
            else {return self.$parse_generic_afm_attribute(line, data)}})();}, TMP_19.$$s = self, TMP_19.$$arity = 1, TMP_19));
          
          $writer = ["glyph_table", $send($range(0, 255, false), 'map', [], (TMP_20 = function(i){var self = TMP_20.$$s || this;
if (i == null) i = nil;
          return data['$[]']("glyph_widths")['$[]'](Opal.const_get_qualified(Opal.const_get_qualified(Opal.const_get_relative($nesting, 'Encoding'), 'WinAnsi'), 'CHARACTERS')['$[]'](i)).$to_i()}, TMP_20.$$s = self, TMP_20.$$arity = 1, TMP_20))];
          $send(data, '[]=', Opal.to_a($writer));
          $writer[$rb_minus($writer["length"], 1)];;
          character_hash = Opal.const_get_relative($nesting, 'Hash')['$[]'](Opal.const_get_qualified(Opal.const_get_qualified(Opal.const_get_relative($nesting, 'Encoding'), 'WinAnsi'), 'CHARACTERS').$zip(Opal.Range.$new(0, Opal.const_get_qualified(Opal.const_get_qualified(Opal.const_get_relative($nesting, 'Encoding'), 'WinAnsi'), 'CHARACTERS').$size(), false).$to_a()));
          
          $writer = ["kern_pair_table", $send(data['$[]']("kern_pairs"), 'each_with_object', [$hash2([], {})], (TMP_21 = function(p, h){var self = TMP_21.$$s || this, TMP_22;
if (p == null) p = nil;if (h == null) h = nil;
          
            $writer = [$send(p['$[]'](0), 'map', [], (TMP_22 = function(n){var self = TMP_22.$$s || this;
if (n == null) n = nil;
            return character_hash['$[]'](n)}, TMP_22.$$s = self, TMP_22.$$arity = 1, TMP_22)), p['$[]'](1)];
            $send(h, '[]=', Opal.to_a($writer));
            return $writer[$rb_minus($writer["length"], 1)];}, TMP_21.$$s = self, TMP_21.$$arity = 2, TMP_21))];
          $send(data, '[]=', Opal.to_a($writer));
          $writer[$rb_minus($writer["length"], 1)];;
          $send(data, 'each_value', [], "freeze".$to_proc());
          return data.$freeze();
        }, TMP_AFM_parse_afm_23.$$arity = 1);
        
        Opal.defn(self, '$parse_generic_afm_attribute', TMP_AFM_parse_generic_afm_attribute_24 = function $$parse_generic_afm_attribute(line, hash) {
          var $a, $b, self = this, key = nil, value = nil, $writer = nil;

          
          line['$=~'](/(^\w+)\s+(.*)/);
          $a = [(($b = $gvars['~']) === nil ? nil : $b['$[]'](1)).$to_s().$downcase(), (($b = $gvars['~']) === nil ? nil : $b['$[]'](2))], (key = $a[0]), (value = $a[1]), $a;
          
          $writer = [key, (function() {if ($truthy(hash['$[]']("attributes")['$[]'](key))) {
            return self.$Array(hash['$[]']("attributes")['$[]'](key))['$<<'](value)
            } else {
            return value
          }; return nil; })()];
          $send(hash['$[]']("attributes"), '[]=', Opal.to_a($writer));
          return $writer[$rb_minus($writer["length"], 1)];;
        }, TMP_AFM_parse_generic_afm_attribute_24.$$arity = 2);
        
        Opal.defn(self, '$kern', TMP_AFM_kern_27 = function $$kern(string) {
          var TMP_25, TMP_26, self = this, kerned = nil, last_byte = nil;

          
          kerned = [[]];
          last_byte = nil;
          $send(string, 'each_byte', [], (TMP_25 = function(byte$){var self = TMP_25.$$s || this, $a, k = nil;
            if (self.kern_pair_table == null) self.kern_pair_table = nil;
if (byte$ == null) byte$ = nil;
          
            if ($truthy((k = ($truthy($a = last_byte) ? self.kern_pair_table['$[]']([last_byte, byte$]) : $a)))) {
              kerned['$<<'](k['$-@']())['$<<']([byte$])
              } else {
              kerned.$last()['$<<'](byte$)
            };
            return (last_byte = byte$);}, TMP_25.$$s = self, TMP_25.$$arity = 1, TMP_25));
          return $send(kerned, 'map', [], (TMP_26 = function(e){var self = TMP_26.$$s || this;
if (e == null) e = nil;
          
            e = (function() {if ($truthy(Opal.const_get_relative($nesting, 'Array')['$==='](e))) {
              return e.$pack("C*")
              } else {
              return e
            }; return nil; })();
            if ($truthy(e['$respond_to?']("force_encoding"))) {
              return e.$force_encoding(Opal.const_get_qualified(Opal.const_get_qualified('::', 'Encoding'), 'Windows_1252'))
              } else {
              return e
            };}, TMP_26.$$s = self, TMP_26.$$arity = 1, TMP_26));
        }, TMP_AFM_kern_27.$$arity = 1);
        self.$private();
        return (Opal.defn(self, '$unscaled_width_of', TMP_AFM_unscaled_width_of_29 = function $$unscaled_width_of(string) {
          var TMP_28, self = this;

          return $send(string.$bytes(), 'inject', [0], (TMP_28 = function(s, r){var self = TMP_28.$$s || this;
            if (self.glyph_table == null) self.glyph_table = nil;
if (s == null) s = nil;if (r == null) r = nil;
          return $rb_plus(s, self.glyph_table['$[]'](r))}, TMP_28.$$s = self, TMP_28.$$arity = 2, TMP_28))
        }, TMP_AFM_unscaled_width_of_29.$$arity = 1), nil) && 'unscaled_width_of';
      })($nesting[0], Opal.const_get_relative($nesting, 'Font'), $nesting)
    })($nesting[0], null, $nesting)
  })($nesting[0], $nesting);
};

/* Generated by Opal 0.11.0 */
Opal.modules["ttfunk/table/simple"] = function(Opal) {
  var self = Opal.top, $nesting = [], nil = Opal.nil, $breaker = Opal.breaker, $slice = Opal.slice, $module = Opal.module, $klass = Opal.klass, $send = Opal.send;

  Opal.add_stubs(['$attr_reader']);
  
  self.$require("ttfunk/table/simple"+ '/../' + "../table");
  return (function($base, $parent_nesting) {
    var $TTFunk, self = $TTFunk = $module($base, 'TTFunk');

    var def = self.$$proto, $nesting = [self].concat($parent_nesting);

    (function($base, $super, $parent_nesting) {
      function $Table(){};
      var self = $Table = $klass($base, $super, 'Table', $Table);

      var def = self.$$proto, $nesting = [self].concat($parent_nesting);

      return (function($base, $super, $parent_nesting) {
        function $Simple(){};
        var self = $Simple = $klass($base, $super, 'Simple', $Simple);

        var def = self.$$proto, $nesting = [self].concat($parent_nesting), TMP_Simple_initialize_1;

        
        self.$attr_reader("tag");
        return (Opal.defn(self, '$initialize', TMP_Simple_initialize_1 = function $$initialize(file, tag) {
          var self = this, $iter = TMP_Simple_initialize_1.$$p, $yield = $iter || nil;

          if ($iter) TMP_Simple_initialize_1.$$p = null;
          
          self.tag = tag;
          return $send(self, Opal.find_super_dispatcher(self, 'initialize', TMP_Simple_initialize_1, false), [file], null);
        }, TMP_Simple_initialize_1.$$arity = 2), nil) && 'initialize';
      })($nesting[0], Opal.const_get_relative($nesting, 'Table'), $nesting)
    })($nesting[0], null, $nesting)
  })($nesting[0], $nesting);
};

/* Generated by Opal 0.11.0 */
Opal.modules["ttfunk/subset/base"] = function(Opal) {
  function $rb_minus(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs - rhs : lhs['$-'](rhs);
  }
  function $rb_plus(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs + rhs : lhs['$+'](rhs);
  }
  function $rb_times(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs * rhs : lhs['$*'](rhs);
  }
  function $rb_divide(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs / rhs : lhs['$/'](rhs);
  }
  var self = Opal.top, $nesting = [], nil = Opal.nil, $breaker = Opal.breaker, $slice = Opal.slice, $module = Opal.module, $klass = Opal.klass, $hash2 = Opal.hash2, $send = Opal.send, $hash = Opal.hash, $truthy = Opal.truthy;

  Opal.add_stubs(['$attr_reader', '$new_cmap_table', '$collect_glyphs', '$original_glyph_ids', '$each_with_object', '$[]', '$[]=', '$-', '$each', '$keys', '$key?', '$+', '$invert', '$encode', '$horizontal_metrics', '$original', '$horizontal_header', '$maximum_profile', '$postscript', '$name', '$header', '$raw', '$os2', '$new', '$kerning', '$delete_if', '$nil?', '$*', '$to_i', '$/', '$log', '$length', '$pack', '$scaler_type', '$directory', '$<<', '$checksum', '$==', '$!=', '$%', '$private', '$first', '$unicode', '$cmap', '$&', '$reduce', '$unpack', '$for', '$glyph_outlines', '$flatten', '$map', '$select', '$values', '$compound?', '$to_proc', '$any?', '$update']);
  
  self.$require("ttfunk/subset/base"+ '/../' + "../table/cmap");
  self.$require("ttfunk/subset/base"+ '/../' + "../table/glyf");
  self.$require("ttfunk/subset/base"+ '/../' + "../table/head");
  self.$require("ttfunk/subset/base"+ '/../' + "../table/hhea");
  self.$require("ttfunk/subset/base"+ '/../' + "../table/hmtx");
  self.$require("ttfunk/subset/base"+ '/../' + "../table/kern");
  self.$require("ttfunk/subset/base"+ '/../' + "../table/loca");
  self.$require("ttfunk/subset/base"+ '/../' + "../table/maxp");
  self.$require("ttfunk/subset/base"+ '/../' + "../table/name");
  self.$require("ttfunk/subset/base"+ '/../' + "../table/post");
  self.$require("ttfunk/subset/base"+ '/../' + "../table/simple");
  return (function($base, $parent_nesting) {
    var $TTFunk, self = $TTFunk = $module($base, 'TTFunk');

    var def = self.$$proto, $nesting = [self].concat($parent_nesting);

    (function($base, $parent_nesting) {
      var $Subset, self = $Subset = $module($base, 'Subset');

      var def = self.$$proto, $nesting = [self].concat($parent_nesting);

      (function($base, $super, $parent_nesting) {
        function $Base(){};
        var self = $Base = $klass($base, $super, 'Base', $Base);

        var def = self.$$proto, $nesting = [self].concat($parent_nesting), TMP_Base_initialize_1, TMP_Base_unicode$q_2, TMP_Base_to_unicode_map_3, TMP_Base_encode_8, TMP_Base_unicode_cmap_9, TMP_Base_checksum_10, TMP_Base_collect_glyphs_13;

        def.unicode_cmap = def.original = nil;
        
        self.$attr_reader("original");
        
        Opal.defn(self, '$initialize', TMP_Base_initialize_1 = function $$initialize(original) {
          var self = this;

          return (self.original = original)
        }, TMP_Base_initialize_1.$$arity = 1);
        
        Opal.defn(self, '$unicode?', TMP_Base_unicode$q_2 = function() {
          var self = this;

          return false
        }, TMP_Base_unicode$q_2.$$arity = 0);
        
        Opal.defn(self, '$to_unicode_map', TMP_Base_to_unicode_map_3 = function $$to_unicode_map() {
          var self = this;

          return $hash2([], {})
        }, TMP_Base_to_unicode_map_3.$$arity = 0);
        
        Opal.defn(self, '$encode', TMP_Base_encode_8 = function $$encode(options) {
          var TMP_4, TMP_5, TMP_6, TMP_7, self = this, cmap_table = nil, glyphs = nil, old2new_glyph = nil, next_glyph_id = nil, new2old_glyph = nil, glyf_table = nil, loca_table = nil, hmtx_table = nil, hhea_table = nil, maxp_table = nil, post_table = nil, name_table = nil, head_table = nil, os2_table = nil, cvt_table = nil, fpgm_table = nil, prep_table = nil, kern_table = nil, tables = nil, search_range = nil, entry_selector = nil, range_shift = nil, newfont = nil, directory_size = nil, offset = nil, table_data = nil, head_offset = nil, sum = nil, adjustment = nil, $writer = nil;

          if (options == null) {
            options = $hash2([], {});
          }
          
          cmap_table = self.$new_cmap_table(options);
          glyphs = self.$collect_glyphs(self.$original_glyph_ids());
          old2new_glyph = $send(cmap_table['$[]']("charmap"), 'each_with_object', [$hash(0, 0)], (TMP_4 = function($a, map){var self = TMP_4.$$s || this, $a_args, _, ids, $writer = nil;

            if ($a == null) {
              $a = nil;
            }
            $a = Opal.to_ary($a);
            $a_args = Opal.slice.call($a, 0, $a.length);
            _ = $a_args.splice(0,1)[0];
            if (_ == null) {
              _ = nil;
            }
            ids = $a_args.splice(0,1)[0];
            if (ids == null) {
              ids = nil;
            }if (map == null) map = nil;
          
            $writer = [ids['$[]']("old"), ids['$[]']("new")];
            $send(map, '[]=', Opal.to_a($writer));
            return $writer[$rb_minus($writer["length"], 1)];}, TMP_4.$$s = self, TMP_4.$$arity = 2, TMP_4.$$has_top_level_mlhs_arg = true, TMP_4));
          next_glyph_id = cmap_table['$[]']("max_glyph_id");
          $send(glyphs.$keys(), 'each', [], (TMP_5 = function(old_id){var self = TMP_5.$$s || this, $writer = nil;
if (old_id == null) old_id = nil;
          if ($truthy(old2new_glyph['$key?'](old_id))) {
              return nil
              } else {
              
              
              $writer = [old_id, next_glyph_id];
              $send(old2new_glyph, '[]=', Opal.to_a($writer));
              $writer[$rb_minus($writer["length"], 1)];;
              return (next_glyph_id = $rb_plus(next_glyph_id, 1));
            }}, TMP_5.$$s = self, TMP_5.$$arity = 1, TMP_5));
          new2old_glyph = old2new_glyph.$invert();
          glyf_table = Opal.const_get_qualified(Opal.const_get_qualified(Opal.const_get_relative($nesting, 'TTFunk'), 'Table'), 'Glyf').$encode(glyphs, new2old_glyph, old2new_glyph);
          loca_table = Opal.const_get_qualified(Opal.const_get_qualified(Opal.const_get_relative($nesting, 'TTFunk'), 'Table'), 'Loca').$encode(glyf_table['$[]']("offsets"));
          hmtx_table = Opal.const_get_qualified(Opal.const_get_qualified(Opal.const_get_relative($nesting, 'TTFunk'), 'Table'), 'Hmtx').$encode(self.$original().$horizontal_metrics(), new2old_glyph);
          hhea_table = Opal.const_get_qualified(Opal.const_get_qualified(Opal.const_get_relative($nesting, 'TTFunk'), 'Table'), 'Hhea').$encode(self.$original().$horizontal_header(), hmtx_table);
          maxp_table = Opal.const_get_qualified(Opal.const_get_qualified(Opal.const_get_relative($nesting, 'TTFunk'), 'Table'), 'Maxp').$encode(self.$original().$maximum_profile(), old2new_glyph);
          post_table = Opal.const_get_qualified(Opal.const_get_qualified(Opal.const_get_relative($nesting, 'TTFunk'), 'Table'), 'Post').$encode(self.$original().$postscript(), new2old_glyph);
          name_table = Opal.const_get_qualified(Opal.const_get_qualified(Opal.const_get_relative($nesting, 'TTFunk'), 'Table'), 'Name').$encode(self.$original().$name(), glyf_table['$[]']("table"));
          head_table = Opal.const_get_qualified(Opal.const_get_qualified(Opal.const_get_relative($nesting, 'TTFunk'), 'Table'), 'Head').$encode(self.$original().$header(), loca_table);
          os2_table = self.$original().$os2().$raw();
          cvt_table = Opal.const_get_qualified(Opal.const_get_qualified(Opal.const_get_relative($nesting, 'TTFunk'), 'Table'), 'Simple').$new(self.$original(), "cvt ").$raw();
          fpgm_table = Opal.const_get_qualified(Opal.const_get_qualified(Opal.const_get_relative($nesting, 'TTFunk'), 'Table'), 'Simple').$new(self.$original(), "fpgm").$raw();
          prep_table = Opal.const_get_qualified(Opal.const_get_qualified(Opal.const_get_relative($nesting, 'TTFunk'), 'Table'), 'Simple').$new(self.$original(), "prep").$raw();
          if ($truthy(options['$[]']("kerning"))) {
            kern_table = Opal.const_get_qualified(Opal.const_get_qualified(Opal.const_get_relative($nesting, 'TTFunk'), 'Table'), 'Kern').$encode(self.$original().$kerning(), old2new_glyph)};
          tables = $hash2(["cmap", "glyf", "loca", "kern", "hmtx", "hhea", "maxp", "OS/2", "post", "name", "head", "prep", "fpgm", "cvt "], {"cmap": cmap_table['$[]']("table"), "glyf": glyf_table['$[]']("table"), "loca": loca_table['$[]']("table"), "kern": kern_table, "hmtx": hmtx_table['$[]']("table"), "hhea": hhea_table, "maxp": maxp_table, "OS/2": os2_table, "post": post_table, "name": name_table, "head": head_table, "prep": prep_table, "fpgm": fpgm_table, "cvt ": cvt_table});
          $send(tables, 'delete_if', [], (TMP_6 = function(_tag, table){var self = TMP_6.$$s || this;
if (_tag == null) _tag = nil;if (table == null) table = nil;
          return table['$nil?']()}, TMP_6.$$s = self, TMP_6.$$arity = 2, TMP_6));
          search_range = $rb_times($rb_divide(Opal.const_get_relative($nesting, 'Math').$log(tables.$length()), Opal.const_get_relative($nesting, 'Math').$log(2)).$to_i(), 16);
          entry_selector = $rb_divide(Opal.const_get_relative($nesting, 'Math').$log(search_range), Opal.const_get_relative($nesting, 'Math').$log(2)).$to_i();
          range_shift = $rb_minus($rb_times(tables.$length(), 16), search_range);
          newfont = [self.$original().$directory().$scaler_type(), tables.$length(), search_range, entry_selector, range_shift].$pack("Nn*");
          directory_size = $rb_times(tables.$length(), 16);
          offset = $rb_plus(newfont.$length(), directory_size);
          table_data = "";
          head_offset = nil;
          $send(tables, 'each', [], (TMP_7 = function(tag, data){var self = TMP_7.$$s || this, $a;
if (tag == null) tag = nil;if (data == null) data = nil;
          
            newfont['$<<']([tag, self.$checksum(data), offset, data.$length()].$pack("A4N*"));
            table_data['$<<'](data);
            if (tag['$==']("head")) {
              head_offset = offset};
            offset = $rb_plus(offset, data.$length());
            while ($truthy(offset['$%'](4)['$!='](0))) {
              
              offset = $rb_plus(offset, 1);
              table_data['$<<']("\u0000");
            };}, TMP_7.$$s = self, TMP_7.$$arity = 2, TMP_7));
          newfont['$<<'](table_data);
          sum = self.$checksum(newfont);
          adjustment = $rb_minus(2981146554, sum);
          
          $writer = [$rb_plus(head_offset, 8), 4, [adjustment].$pack("N")];
          $send(newfont, '[]=', Opal.to_a($writer));
          $writer[$rb_minus($writer["length"], 1)];;
          return newfont;
        }, TMP_Base_encode_8.$$arity = -1);
        self.$private();
        
        Opal.defn(self, '$unicode_cmap', TMP_Base_unicode_cmap_9 = function $$unicode_cmap() {
          var $a, self = this;

          return (self.unicode_cmap = ($truthy($a = self.unicode_cmap) ? $a : self.original.$cmap().$unicode().$first()))
        }, TMP_Base_unicode_cmap_9.$$arity = 0);
        
        Opal.defn(self, '$checksum', TMP_Base_checksum_10 = function $$checksum(data) {
          var self = this;

          
          if (data.$length()['$%'](4)['$=='](0)) {
            } else {
            data = $rb_plus(data, $rb_times("\u0000", $rb_minus(4, data.$length()['$%'](4))))
          };
          return data.$unpack("N*").$reduce(0, "+")['$&'](4294967295);
        }, TMP_Base_checksum_10.$$arity = 1);
        return (Opal.defn(self, '$collect_glyphs', TMP_Base_collect_glyphs_13 = function $$collect_glyphs(glyph_ids) {
          var TMP_11, TMP_12, self = this, glyphs = nil, additional_ids = nil;

          
          glyphs = $send(glyph_ids, 'each_with_object', [$hash2([], {})], (TMP_11 = function(id, h){var self = TMP_11.$$s || this, $writer = nil;
if (id == null) id = nil;if (h == null) h = nil;
          
            $writer = [id, self.$original().$glyph_outlines().$for(id)];
            $send(h, '[]=', Opal.to_a($writer));
            return $writer[$rb_minus($writer["length"], 1)];}, TMP_11.$$s = self, TMP_11.$$arity = 2, TMP_11));
          additional_ids = $send($send(glyphs.$values(), 'select', [], (TMP_12 = function(g){var self = TMP_12.$$s || this, $a;
if (g == null) g = nil;
          return ($truthy($a = g) ? g['$compound?']() : $a)}, TMP_12.$$s = self, TMP_12.$$arity = 1, TMP_12)), 'map', [], "glyph_ids".$to_proc()).$flatten();
          if ($truthy(additional_ids['$any?']())) {
            glyphs.$update(self.$collect_glyphs(additional_ids))};
          return glyphs;
        }, TMP_Base_collect_glyphs_13.$$arity = 1), nil) && 'collect_glyphs';
      })($nesting[0], null, $nesting)
    })($nesting[0], $nesting)
  })($nesting[0], $nesting);
};

/* Generated by Opal 0.11.0 */
Opal.modules["ttfunk/subset/unicode"] = function(Opal) {
  function $rb_minus(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs - rhs : lhs['$-'](rhs);
  }
  function $rb_plus(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs + rhs : lhs['$+'](rhs);
  }
  var self = Opal.top, $nesting = [], nil = Opal.nil, $breaker = Opal.breaker, $slice = Opal.slice, $module = Opal.module, $klass = Opal.klass, $send = Opal.send, $hash2 = Opal.hash2;

  Opal.add_stubs(['$require', '$new', '$each_with_object', '$[]=', '$-', '$<<', '$includes', '$protected', '$[]', '$unicode_cmap', '$encode', '$sort', '$uniq', '$+', '$map']);
  
  self.$require("set");
  self.$require("ttfunk/subset/unicode"+ '/../' + "base");
  return (function($base, $parent_nesting) {
    var $TTFunk, self = $TTFunk = $module($base, 'TTFunk');

    var def = self.$$proto, $nesting = [self].concat($parent_nesting);

    (function($base, $parent_nesting) {
      var $Subset, self = $Subset = $module($base, 'Subset');

      var def = self.$$proto, $nesting = [self].concat($parent_nesting);

      (function($base, $super, $parent_nesting) {
        function $Unicode(){};
        var self = $Unicode = $klass($base, $super, 'Unicode', $Unicode);

        var def = self.$$proto, $nesting = [self].concat($parent_nesting), TMP_Unicode_initialize_1, TMP_Unicode_unicode$q_2, TMP_Unicode_to_unicode_map_4, TMP_Unicode_use_5, TMP_Unicode_covers$q_6, TMP_Unicode_includes$q_7, TMP_Unicode_from_unicode_8, TMP_Unicode_new_cmap_table_10, TMP_Unicode_original_glyph_ids_12;

        def.subset = nil;
        
        
        Opal.defn(self, '$initialize', TMP_Unicode_initialize_1 = function $$initialize(original) {
          var self = this, $iter = TMP_Unicode_initialize_1.$$p, $yield = $iter || nil, $zuper = nil, $zuper_i = nil, $zuper_ii = nil;

          if ($iter) TMP_Unicode_initialize_1.$$p = null;
          // Prepare super implicit arguments
          for($zuper_i = 0, $zuper_ii = arguments.length, $zuper = new Array($zuper_ii); $zuper_i < $zuper_ii; $zuper_i++) {
            $zuper[$zuper_i] = arguments[$zuper_i];
          }
          
          $send(self, Opal.find_super_dispatcher(self, 'initialize', TMP_Unicode_initialize_1, false), $zuper, $iter);
          return (self.subset = Opal.const_get_relative($nesting, 'Set').$new());
        }, TMP_Unicode_initialize_1.$$arity = 1);
        
        Opal.defn(self, '$unicode?', TMP_Unicode_unicode$q_2 = function() {
          var self = this;

          return true
        }, TMP_Unicode_unicode$q_2.$$arity = 0);
        
        Opal.defn(self, '$to_unicode_map', TMP_Unicode_to_unicode_map_4 = function $$to_unicode_map() {
          var TMP_3, self = this;

          return $send(self.subset, 'each_with_object', [$hash2([], {})], (TMP_3 = function(code, map){var self = TMP_3.$$s || this, $writer = nil;
if (code == null) code = nil;if (map == null) map = nil;
          
            $writer = [code, code];
            $send(map, '[]=', Opal.to_a($writer));
            return $writer[$rb_minus($writer["length"], 1)];}, TMP_3.$$s = self, TMP_3.$$arity = 2, TMP_3))
        }, TMP_Unicode_to_unicode_map_4.$$arity = 0);
        
        Opal.defn(self, '$use', TMP_Unicode_use_5 = function $$use(character) {
          var self = this;

          return self.subset['$<<'](character)
        }, TMP_Unicode_use_5.$$arity = 1);
        
        Opal.defn(self, '$covers?', TMP_Unicode_covers$q_6 = function(_character) {
          var self = this;

          return true
        }, TMP_Unicode_covers$q_6.$$arity = 1);
        
        Opal.defn(self, '$includes?', TMP_Unicode_includes$q_7 = function(character) {
          var self = this;

          return self.subset.$includes(character)
        }, TMP_Unicode_includes$q_7.$$arity = 1);
        
        Opal.defn(self, '$from_unicode', TMP_Unicode_from_unicode_8 = function $$from_unicode(character) {
          var self = this;

          return character
        }, TMP_Unicode_from_unicode_8.$$arity = 1);
        self.$protected();
        
        Opal.defn(self, '$new_cmap_table', TMP_Unicode_new_cmap_table_10 = function $$new_cmap_table(_options) {
          var TMP_9, self = this, mapping = nil;

          
          mapping = $send(self.subset, 'each_with_object', [$hash2([], {})], (TMP_9 = function(code, map){var self = TMP_9.$$s || this, $writer = nil;
if (code == null) code = nil;if (map == null) map = nil;
          
            $writer = [code, self.$unicode_cmap()['$[]'](code)];
            $send(map, '[]=', Opal.to_a($writer));
            return $writer[$rb_minus($writer["length"], 1)];}, TMP_9.$$s = self, TMP_9.$$arity = 2, TMP_9));
          return Opal.const_get_qualified(Opal.const_get_qualified(Opal.const_get_relative($nesting, 'TTFunk'), 'Table'), 'Cmap').$encode(mapping, "unicode");
        }, TMP_Unicode_new_cmap_table_10.$$arity = 1);
        return (Opal.defn(self, '$original_glyph_ids', TMP_Unicode_original_glyph_ids_12 = function $$original_glyph_ids() {
          var TMP_11, self = this;

          return $rb_plus([0], $send(self.subset, 'map', [], (TMP_11 = function(code){var self = TMP_11.$$s || this;
if (code == null) code = nil;
          return self.$unicode_cmap()['$[]'](code)}, TMP_11.$$s = self, TMP_11.$$arity = 1, TMP_11))).$uniq().$sort()
        }, TMP_Unicode_original_glyph_ids_12.$$arity = 0), nil) && 'original_glyph_ids';
      })($nesting[0], Opal.const_get_relative($nesting, 'Base'), $nesting)
    })($nesting[0], $nesting)
  })($nesting[0], $nesting);
};

/* Generated by Opal 0.11.0 */
Opal.modules["ttfunk/subset/unicode_8bit"] = function(Opal) {
  function $rb_minus(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs - rhs : lhs['$-'](rhs);
  }
  function $rb_plus(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs + rhs : lhs['$+'](rhs);
  }
  function $rb_lt(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs < rhs : lhs['$<'](rhs);
  }
  var self = Opal.top, $nesting = [], nil = Opal.nil, $breaker = Opal.breaker, $slice = Opal.slice, $module = Opal.module, $klass = Opal.klass, $send = Opal.send, $hash = Opal.hash, $truthy = Opal.truthy, $hash2 = Opal.hash2;

  Opal.add_stubs(['$require', '$dup', '$key?', '$[]=', '$-', '$+', '$<', '$[]', '$protected', '$each_with_object', '$unicode_cmap', '$encode', '$sort', '$uniq', '$map', '$keys']);
  
  self.$require("set");
  self.$require("ttfunk/subset/unicode_8bit"+ '/../' + "base");
  return (function($base, $parent_nesting) {
    var $TTFunk, self = $TTFunk = $module($base, 'TTFunk');

    var def = self.$$proto, $nesting = [self].concat($parent_nesting);

    (function($base, $parent_nesting) {
      var $Subset, self = $Subset = $module($base, 'Subset');

      var def = self.$$proto, $nesting = [self].concat($parent_nesting);

      (function($base, $super, $parent_nesting) {
        function $Unicode8Bit(){};
        var self = $Unicode8Bit = $klass($base, $super, 'Unicode8Bit', $Unicode8Bit);

        var def = self.$$proto, $nesting = [self].concat($parent_nesting), TMP_Unicode8Bit_initialize_1, TMP_Unicode8Bit_unicode$q_2, TMP_Unicode8Bit_to_unicode_map_3, TMP_Unicode8Bit_use_4, TMP_Unicode8Bit_covers$q_5, TMP_Unicode8Bit_includes$q_6, TMP_Unicode8Bit_from_unicode_7, TMP_Unicode8Bit_new_cmap_table_9, TMP_Unicode8Bit_original_glyph_ids_11;

        def.subset = def.unicodes = def.next = nil;
        
        
        Opal.defn(self, '$initialize', TMP_Unicode8Bit_initialize_1 = function $$initialize(original) {
          var self = this, $iter = TMP_Unicode8Bit_initialize_1.$$p, $yield = $iter || nil, $zuper = nil, $zuper_i = nil, $zuper_ii = nil;

          if ($iter) TMP_Unicode8Bit_initialize_1.$$p = null;
          // Prepare super implicit arguments
          for($zuper_i = 0, $zuper_ii = arguments.length, $zuper = new Array($zuper_ii); $zuper_i < $zuper_ii; $zuper_i++) {
            $zuper[$zuper_i] = arguments[$zuper_i];
          }
          
          $send(self, Opal.find_super_dispatcher(self, 'initialize', TMP_Unicode8Bit_initialize_1, false), $zuper, $iter);
          self.subset = $hash(32, 32);
          self.unicodes = $hash(32, 32);
          return (self.next = 33);
        }, TMP_Unicode8Bit_initialize_1.$$arity = 1);
        
        Opal.defn(self, '$unicode?', TMP_Unicode8Bit_unicode$q_2 = function() {
          var self = this;

          return true
        }, TMP_Unicode8Bit_unicode$q_2.$$arity = 0);
        
        Opal.defn(self, '$to_unicode_map', TMP_Unicode8Bit_to_unicode_map_3 = function $$to_unicode_map() {
          var self = this;

          return self.subset.$dup()
        }, TMP_Unicode8Bit_to_unicode_map_3.$$arity = 0);
        
        Opal.defn(self, '$use', TMP_Unicode8Bit_use_4 = function $$use(character) {
          var self = this, $writer = nil;

          if ($truthy(self.unicodes['$key?'](character))) {
            return nil
            } else {
            
            
            $writer = [self.next, character];
            $send(self.subset, '[]=', Opal.to_a($writer));
            $writer[$rb_minus($writer["length"], 1)];;
            
            $writer = [character, self.next];
            $send(self.unicodes, '[]=', Opal.to_a($writer));
            $writer[$rb_minus($writer["length"], 1)];;
            return (self.next = $rb_plus(self.next, 1));
          }
        }, TMP_Unicode8Bit_use_4.$$arity = 1);
        
        Opal.defn(self, '$covers?', TMP_Unicode8Bit_covers$q_5 = function(character) {
          var $a, self = this;

          return ($truthy($a = self.unicodes['$key?'](character)) ? $a : $rb_lt(self.next, 256))
        }, TMP_Unicode8Bit_covers$q_5.$$arity = 1);
        
        Opal.defn(self, '$includes?', TMP_Unicode8Bit_includes$q_6 = function(character) {
          var self = this;

          return self.unicodes['$key?'](character)
        }, TMP_Unicode8Bit_includes$q_6.$$arity = 1);
        
        Opal.defn(self, '$from_unicode', TMP_Unicode8Bit_from_unicode_7 = function $$from_unicode(character) {
          var self = this;

          return self.unicodes['$[]'](character)
        }, TMP_Unicode8Bit_from_unicode_7.$$arity = 1);
        self.$protected();
        
        Opal.defn(self, '$new_cmap_table', TMP_Unicode8Bit_new_cmap_table_9 = function $$new_cmap_table(_options) {
          var TMP_8, self = this, mapping = nil;

          
          mapping = $send(self.subset, 'each_with_object', [$hash2([], {})], (TMP_8 = function($a, map){var self = TMP_8.$$s || this, $a_args, code, unicode, $writer = nil;

            if ($a == null) {
              $a = nil;
            }
            $a = Opal.to_ary($a);
            $a_args = Opal.slice.call($a, 0, $a.length);
            code = $a_args.splice(0,1)[0];
            if (code == null) {
              code = nil;
            }
            unicode = $a_args.splice(0,1)[0];
            if (unicode == null) {
              unicode = nil;
            }if (map == null) map = nil;
          
            
            $writer = [code, self.$unicode_cmap()['$[]'](unicode)];
            $send(map, '[]=', Opal.to_a($writer));
            $writer[$rb_minus($writer["length"], 1)];;
            return map;}, TMP_8.$$s = self, TMP_8.$$arity = 2, TMP_8.$$has_top_level_mlhs_arg = true, TMP_8));
          return Opal.const_get_qualified(Opal.const_get_qualified(Opal.const_get_relative($nesting, 'TTFunk'), 'Table'), 'Cmap').$encode(mapping, "mac_roman");
        }, TMP_Unicode8Bit_new_cmap_table_9.$$arity = 1);
        return (Opal.defn(self, '$original_glyph_ids', TMP_Unicode8Bit_original_glyph_ids_11 = function $$original_glyph_ids() {
          var TMP_10, self = this;

          return $rb_plus([0], $send(self.unicodes.$keys(), 'map', [], (TMP_10 = function(unicode){var self = TMP_10.$$s || this;
if (unicode == null) unicode = nil;
          return self.$unicode_cmap()['$[]'](unicode)}, TMP_10.$$s = self, TMP_10.$$arity = 1, TMP_10))).$uniq().$sort()
        }, TMP_Unicode8Bit_original_glyph_ids_11.$$arity = 0), nil) && 'original_glyph_ids';
      })($nesting[0], Opal.const_get_relative($nesting, 'Base'), $nesting)
    })($nesting[0], $nesting)
  })($nesting[0], $nesting);
};

/* Generated by Opal 0.11.0 */
Opal.modules["ttfunk/subset/mac_roman"] = function(Opal) {
  function $rb_minus(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs - rhs : lhs['$-'](rhs);
  }
  function $rb_plus(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs + rhs : lhs['$+'](rhs);
  }
  var self = Opal.top, $nesting = [], nil = Opal.nil, $breaker = Opal.breaker, $slice = Opal.slice, $module = Opal.module, $klass = Opal.klass, $send = Opal.send, $truthy = Opal.truthy, $hash2 = Opal.hash2;

  Opal.add_stubs(['$require', '$new', '$[]', '$[]=', '$-', '$covers?', '$protected', '$each_with_index', '$unicode_cmap', '$encode', '$sort', '$uniq', '$compact', '$+', '$map']);
  
  self.$require("set");
  self.$require("ttfunk/subset/mac_roman"+ '/../' + "base");
  self.$require("ttfunk/subset/mac_roman"+ '/../' + "../encoding/mac_roman");
  return (function($base, $parent_nesting) {
    var $TTFunk, self = $TTFunk = $module($base, 'TTFunk');

    var def = self.$$proto, $nesting = [self].concat($parent_nesting);

    (function($base, $parent_nesting) {
      var $Subset, self = $Subset = $module($base, 'Subset');

      var def = self.$$proto, $nesting = [self].concat($parent_nesting);

      (function($base, $super, $parent_nesting) {
        function $MacRoman(){};
        var self = $MacRoman = $klass($base, $super, 'MacRoman', $MacRoman);

        var def = self.$$proto, $nesting = [self].concat($parent_nesting), TMP_MacRoman_initialize_1, TMP_MacRoman_to_unicode_map_2, TMP_MacRoman_use_3, TMP_MacRoman_covers$q_4, TMP_MacRoman_includes$q_5, TMP_MacRoman_from_unicode_6, TMP_MacRoman_new_cmap_table_8, TMP_MacRoman_original_glyph_ids_10;

        def.subset = nil;
        
        
        Opal.defn(self, '$initialize', TMP_MacRoman_initialize_1 = function $$initialize(original) {
          var self = this, $iter = TMP_MacRoman_initialize_1.$$p, $yield = $iter || nil, $zuper = nil, $zuper_i = nil, $zuper_ii = nil;

          if ($iter) TMP_MacRoman_initialize_1.$$p = null;
          // Prepare super implicit arguments
          for($zuper_i = 0, $zuper_ii = arguments.length, $zuper = new Array($zuper_ii); $zuper_i < $zuper_ii; $zuper_i++) {
            $zuper[$zuper_i] = arguments[$zuper_i];
          }
          
          $send(self, Opal.find_super_dispatcher(self, 'initialize', TMP_MacRoman_initialize_1, false), $zuper, $iter);
          return (self.subset = Opal.const_get_relative($nesting, 'Array').$new(256));
        }, TMP_MacRoman_initialize_1.$$arity = 1);
        
        Opal.defn(self, '$to_unicode_map', TMP_MacRoman_to_unicode_map_2 = function $$to_unicode_map() {
          var self = this;

          return Opal.const_get_qualified(Opal.const_get_qualified(Opal.const_get_relative($nesting, 'Encoding'), 'MacRoman'), 'TO_UNICODE')
        }, TMP_MacRoman_to_unicode_map_2.$$arity = 0);
        
        Opal.defn(self, '$use', TMP_MacRoman_use_3 = function $$use(character) {
          var self = this, $writer = nil;

          
          $writer = [Opal.const_get_qualified(Opal.const_get_qualified(Opal.const_get_relative($nesting, 'Encoding'), 'MacRoman'), 'FROM_UNICODE')['$[]'](character), character];
          $send(self.subset, '[]=', Opal.to_a($writer));
          return $writer[$rb_minus($writer["length"], 1)];
        }, TMP_MacRoman_use_3.$$arity = 1);
        
        Opal.defn(self, '$covers?', TMP_MacRoman_covers$q_4 = function(character) {
          var self = this;

          return Opal.const_get_qualified(Opal.const_get_relative($nesting, 'Encoding'), 'MacRoman')['$covers?'](character)
        }, TMP_MacRoman_covers$q_4.$$arity = 1);
        
        Opal.defn(self, '$includes?', TMP_MacRoman_includes$q_5 = function(character) {
          var $a, self = this, code = nil;

          
          code = Opal.const_get_qualified(Opal.const_get_qualified(Opal.const_get_relative($nesting, 'Encoding'), 'MacRoman'), 'FROM_UNICODE')['$[]'](character);
          return ($truthy($a = code) ? self.subset['$[]'](code) : $a);
        }, TMP_MacRoman_includes$q_5.$$arity = 1);
        
        Opal.defn(self, '$from_unicode', TMP_MacRoman_from_unicode_6 = function $$from_unicode(character) {
          var self = this;

          return Opal.const_get_qualified(Opal.const_get_qualified(Opal.const_get_relative($nesting, 'Encoding'), 'MacRoman'), 'FROM_UNICODE')['$[]'](character)
        }, TMP_MacRoman_from_unicode_6.$$arity = 1);
        self.$protected();
        
        Opal.defn(self, '$new_cmap_table', TMP_MacRoman_new_cmap_table_8 = function $$new_cmap_table(_options) {
          var TMP_7, self = this, mapping = nil;

          
          mapping = $hash2([], {});
          $send(self.subset, 'each_with_index', [], (TMP_7 = function(unicode, roman){var self = TMP_7.$$s || this, $writer = nil;
if (unicode == null) unicode = nil;if (roman == null) roman = nil;
          if ($truthy(roman)) {
              
              $writer = [roman, self.$unicode_cmap()['$[]'](unicode)];
              $send(mapping, '[]=', Opal.to_a($writer));
              return $writer[$rb_minus($writer["length"], 1)];
              } else {
              return nil
            }}, TMP_7.$$s = self, TMP_7.$$arity = 2, TMP_7));
          return Opal.const_get_qualified(Opal.const_get_qualified(Opal.const_get_relative($nesting, 'TTFunk'), 'Table'), 'Cmap').$encode(mapping, "mac_roman");
        }, TMP_MacRoman_new_cmap_table_8.$$arity = 1);
        return (Opal.defn(self, '$original_glyph_ids', TMP_MacRoman_original_glyph_ids_10 = function $$original_glyph_ids() {
          var TMP_9, self = this;

          return $rb_plus([0], $send(self.subset, 'map', [], (TMP_9 = function(unicode){var self = TMP_9.$$s || this, $a;
if (unicode == null) unicode = nil;
          return ($truthy($a = unicode) ? self.$unicode_cmap()['$[]'](unicode) : $a)}, TMP_9.$$s = self, TMP_9.$$arity = 1, TMP_9))).$compact().$uniq().$sort()
        }, TMP_MacRoman_original_glyph_ids_10.$$arity = 0), nil) && 'original_glyph_ids';
      })($nesting[0], Opal.const_get_relative($nesting, 'Base'), $nesting)
    })($nesting[0], $nesting)
  })($nesting[0], $nesting);
};

/* Generated by Opal 0.11.0 */
Opal.modules["ttfunk/subset/windows_1252"] = function(Opal) {
  function $rb_minus(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs - rhs : lhs['$-'](rhs);
  }
  function $rb_plus(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs + rhs : lhs['$+'](rhs);
  }
  var self = Opal.top, $nesting = [], nil = Opal.nil, $breaker = Opal.breaker, $slice = Opal.slice, $module = Opal.module, $klass = Opal.klass, $send = Opal.send, $truthy = Opal.truthy, $hash2 = Opal.hash2;

  Opal.add_stubs(['$require', '$new', '$[]', '$[]=', '$-', '$covers?', '$protected', '$each_with_index', '$unicode_cmap', '$encode', '$sort', '$uniq', '$compact', '$+', '$map']);
  
  self.$require("set");
  self.$require("ttfunk/subset/windows_1252"+ '/../' + "base");
  self.$require("ttfunk/subset/windows_1252"+ '/../' + "../encoding/windows_1252");
  return (function($base, $parent_nesting) {
    var $TTFunk, self = $TTFunk = $module($base, 'TTFunk');

    var def = self.$$proto, $nesting = [self].concat($parent_nesting);

    (function($base, $parent_nesting) {
      var $Subset, self = $Subset = $module($base, 'Subset');

      var def = self.$$proto, $nesting = [self].concat($parent_nesting);

      (function($base, $super, $parent_nesting) {
        function $Windows1252(){};
        var self = $Windows1252 = $klass($base, $super, 'Windows1252', $Windows1252);

        var def = self.$$proto, $nesting = [self].concat($parent_nesting), TMP_Windows1252_initialize_1, TMP_Windows1252_to_unicode_map_2, TMP_Windows1252_use_3, TMP_Windows1252_covers$q_4, TMP_Windows1252_includes$q_5, TMP_Windows1252_from_unicode_6, TMP_Windows1252_new_cmap_table_8, TMP_Windows1252_original_glyph_ids_10;

        def.subset = nil;
        
        
        Opal.defn(self, '$initialize', TMP_Windows1252_initialize_1 = function $$initialize(original) {
          var self = this, $iter = TMP_Windows1252_initialize_1.$$p, $yield = $iter || nil, $zuper = nil, $zuper_i = nil, $zuper_ii = nil;

          if ($iter) TMP_Windows1252_initialize_1.$$p = null;
          // Prepare super implicit arguments
          for($zuper_i = 0, $zuper_ii = arguments.length, $zuper = new Array($zuper_ii); $zuper_i < $zuper_ii; $zuper_i++) {
            $zuper[$zuper_i] = arguments[$zuper_i];
          }
          
          $send(self, Opal.find_super_dispatcher(self, 'initialize', TMP_Windows1252_initialize_1, false), $zuper, $iter);
          return (self.subset = Opal.const_get_relative($nesting, 'Array').$new(256));
        }, TMP_Windows1252_initialize_1.$$arity = 1);
        
        Opal.defn(self, '$to_unicode_map', TMP_Windows1252_to_unicode_map_2 = function $$to_unicode_map() {
          var self = this;

          return Opal.const_get_qualified(Opal.const_get_qualified(Opal.const_get_relative($nesting, 'Encoding'), 'Windows1252'), 'TO_UNICODE')
        }, TMP_Windows1252_to_unicode_map_2.$$arity = 0);
        
        Opal.defn(self, '$use', TMP_Windows1252_use_3 = function $$use(character) {
          var self = this, $writer = nil;

          
          $writer = [Opal.const_get_qualified(Opal.const_get_qualified(Opal.const_get_relative($nesting, 'Encoding'), 'Windows1252'), 'FROM_UNICODE')['$[]'](character), character];
          $send(self.subset, '[]=', Opal.to_a($writer));
          return $writer[$rb_minus($writer["length"], 1)];
        }, TMP_Windows1252_use_3.$$arity = 1);
        
        Opal.defn(self, '$covers?', TMP_Windows1252_covers$q_4 = function(character) {
          var self = this;

          return Opal.const_get_qualified(Opal.const_get_relative($nesting, 'Encoding'), 'Windows1252')['$covers?'](character)
        }, TMP_Windows1252_covers$q_4.$$arity = 1);
        
        Opal.defn(self, '$includes?', TMP_Windows1252_includes$q_5 = function(character) {
          var $a, self = this, code = nil;

          
          code = Opal.const_get_qualified(Opal.const_get_qualified(Opal.const_get_relative($nesting, 'Encoding'), 'Windows1252'), 'FROM_UNICODE')['$[]'](character);
          return ($truthy($a = code) ? self.subset['$[]'](code) : $a);
        }, TMP_Windows1252_includes$q_5.$$arity = 1);
        
        Opal.defn(self, '$from_unicode', TMP_Windows1252_from_unicode_6 = function $$from_unicode(character) {
          var self = this;

          return Opal.const_get_qualified(Opal.const_get_qualified(Opal.const_get_relative($nesting, 'Encoding'), 'Windows1252'), 'FROM_UNICODE')['$[]'](character)
        }, TMP_Windows1252_from_unicode_6.$$arity = 1);
        self.$protected();
        
        Opal.defn(self, '$new_cmap_table', TMP_Windows1252_new_cmap_table_8 = function $$new_cmap_table(_options) {
          var TMP_7, self = this, mapping = nil;

          
          mapping = $hash2([], {});
          $send(self.subset, 'each_with_index', [], (TMP_7 = function(unicode, cp1252){var self = TMP_7.$$s || this, $writer = nil;
if (unicode == null) unicode = nil;if (cp1252 == null) cp1252 = nil;
          if ($truthy(cp1252)) {
              
              $writer = [cp1252, self.$unicode_cmap()['$[]'](unicode)];
              $send(mapping, '[]=', Opal.to_a($writer));
              return $writer[$rb_minus($writer["length"], 1)];
              } else {
              return nil
            }}, TMP_7.$$s = self, TMP_7.$$arity = 2, TMP_7));
          return Opal.const_get_qualified(Opal.const_get_qualified(Opal.const_get_relative($nesting, 'TTFunk'), 'Table'), 'Cmap').$encode(mapping, "mac_roman");
        }, TMP_Windows1252_new_cmap_table_8.$$arity = 1);
        return (Opal.defn(self, '$original_glyph_ids', TMP_Windows1252_original_glyph_ids_10 = function $$original_glyph_ids() {
          var TMP_9, self = this;

          return $rb_plus([0], $send(self.subset, 'map', [], (TMP_9 = function(unicode){var self = TMP_9.$$s || this, $a;
if (unicode == null) unicode = nil;
          return ($truthy($a = unicode) ? self.$unicode_cmap()['$[]'](unicode) : $a)}, TMP_9.$$s = self, TMP_9.$$arity = 1, TMP_9))).$compact().$uniq().$sort()
        }, TMP_Windows1252_original_glyph_ids_10.$$arity = 0), nil) && 'original_glyph_ids';
      })($nesting[0], Opal.const_get_relative($nesting, 'Base'), $nesting)
    })($nesting[0], $nesting)
  })($nesting[0], $nesting);
};

/* Generated by Opal 0.11.0 */
Opal.modules["ttfunk/subset"] = function(Opal) {
  var self = Opal.top, $nesting = [], nil = Opal.nil, $breaker = Opal.breaker, $slice = Opal.slice, $module = Opal.module;

  Opal.add_stubs(['$to_sym', '$===', '$new', '$raise']);
  
  self.$require("ttfunk/subset"+ '/../' + "subset/unicode");
  self.$require("ttfunk/subset"+ '/../' + "subset/unicode_8bit");
  self.$require("ttfunk/subset"+ '/../' + "subset/mac_roman");
  self.$require("ttfunk/subset"+ '/../' + "subset/windows_1252");
  return (function($base, $parent_nesting) {
    var $TTFunk, self = $TTFunk = $module($base, 'TTFunk');

    var def = self.$$proto, $nesting = [self].concat($parent_nesting);

    (function($base, $parent_nesting) {
      var $Subset, self = $Subset = $module($base, 'Subset');

      var def = self.$$proto, $nesting = [self].concat($parent_nesting), TMP_Subset_for_1;

      Opal.defs(self, '$for', TMP_Subset_for_1 = function(original, encoding) {
        var self = this, $case = nil;

        return (function() {$case = encoding.$to_sym();
        if ("unicode"['$===']($case)) {return Opal.const_get_relative($nesting, 'Unicode').$new(original)}
        else if ("unicode_8bit"['$===']($case)) {return Opal.const_get_relative($nesting, 'Unicode8Bit').$new(original)}
        else if ("mac_roman"['$===']($case)) {return Opal.const_get_relative($nesting, 'MacRoman').$new(original)}
        else if ("windows_1252"['$===']($case)) {return Opal.const_get_relative($nesting, 'Windows1252').$new(original)}
        else {return self.$raise(Opal.const_get_relative($nesting, 'NotImplementedError'), "" + "encoding " + (encoding) + " is not supported")}})()
      }, TMP_Subset_for_1.$$arity = 2)
    })($nesting[0], $nesting)
  })($nesting[0], $nesting);
};

/* Generated by Opal 0.11.0 */
Opal.modules["ttfunk/subset_collection"] = function(Opal) {
  function $rb_plus(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs + rhs : lhs['$+'](rhs);
  }
  function $rb_ge(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs >= rhs : lhs['$>='](rhs);
  }
  var self = Opal.top, $nesting = [], nil = Opal.nil, $breaker = Opal.breaker, $slice = Opal.slice, $module = Opal.module, $klass = Opal.klass, $send = Opal.send, $truthy = Opal.truthy;

  Opal.add_stubs(['$for', '$[]', '$each', '$each_with_index', '$covers?', '$use', '$<<', '$last', '$empty?', '$loop', '$includes?', '$from_unicode', '$!=', '$chr', '$respond_to?', '$force_encoding', '$+', '$>=', '$length', '$%']);
  
  self.$require("ttfunk/subset_collection"+ '/../' + "subset");
  return (function($base, $parent_nesting) {
    var $TTFunk, self = $TTFunk = $module($base, 'TTFunk');

    var def = self.$$proto, $nesting = [self].concat($parent_nesting);

    (function($base, $super, $parent_nesting) {
      function $SubsetCollection(){};
      var self = $SubsetCollection = $klass($base, $super, 'SubsetCollection', $SubsetCollection);

      var def = self.$$proto, $nesting = [self].concat($parent_nesting), TMP_SubsetCollection_initialize_1, TMP_SubsetCollection_$$_2, TMP_SubsetCollection_use_5, TMP_SubsetCollection_encode_7;

      def.original = def.subsets = nil;
      
      
      Opal.defn(self, '$initialize', TMP_SubsetCollection_initialize_1 = function $$initialize(original) {
        var self = this;

        
        self.original = original;
        return (self.subsets = [Opal.const_get_relative($nesting, 'Subset').$for(self.original, "mac_roman")]);
      }, TMP_SubsetCollection_initialize_1.$$arity = 1);
      
      Opal.defn(self, '$[]', TMP_SubsetCollection_$$_2 = function(subset) {
        var self = this;

        return self.subsets['$[]'](subset)
      }, TMP_SubsetCollection_$$_2.$$arity = 1);
      
      Opal.defn(self, '$use', TMP_SubsetCollection_use_5 = function $$use(characters) {
        var TMP_3, self = this;

        return (function(){var $brk = Opal.new_brk(); try {return $send(characters, 'each', [], (TMP_3 = function(char$){var self = TMP_3.$$s || this, TMP_4, covered = nil;
          if (self.subsets == null) self.subsets = nil;
          if (self.original == null) self.original = nil;
if (char$ == null) char$ = nil;
        
          covered = false;
          (function(){var $brk = Opal.new_brk(); try {return $send(self.subsets, 'each_with_index', [], (TMP_4 = function(subset, _i){var self = TMP_4.$$s || this;
if (subset == null) subset = nil;if (_i == null) _i = nil;
          
            if ($truthy(subset['$covers?'](char$))) {
              } else {
              return nil;
            };
            subset.$use(char$);
            covered = true;
            
            Opal.brk(nil, $brk);}, TMP_4.$$s = self, TMP_4.$$brk = $brk, TMP_4.$$arity = 2, TMP_4))
          } catch (err) { if (err === $brk) { return err.$v } else { throw err } }})();
          if ($truthy(covered)) {
            return nil
            } else {
            
            self.subsets['$<<'](Opal.const_get_relative($nesting, 'Subset').$for(self.original, "unicode_8bit"));
            return self.subsets.$last().$use(char$);
          };}, TMP_3.$$s = self, TMP_3.$$brk = $brk, TMP_3.$$arity = 1, TMP_3))
        } catch (err) { if (err === $brk) { return err.$v } else { throw err } }})()
      }, TMP_SubsetCollection_use_5.$$arity = 1);
      return (Opal.defn(self, '$encode', TMP_SubsetCollection_encode_7 = function $$encode(characters) {try {

        var TMP_6, self = this, parts = nil, current_subset = nil, current_char = nil, char$ = nil;

        
        if ($truthy(characters['$empty?']())) {
          return []};
        self.$use(characters);
        parts = [];
        current_subset = 0;
        current_char = 0;
        char$ = characters['$[]'](current_char);
        return $send(self, 'loop', [], (TMP_6 = function(){var self = TMP_6.$$s || this, $a, $b, encoded_char = nil;
          if (self.subsets == null) self.subsets = nil;

        
          while ($truthy(self.subsets['$[]'](current_subset)['$includes?'](char$))) {
            
            char$ = self.subsets['$[]'](current_subset).$from_unicode(char$);
            if ($truthy(($truthy($b = parts['$empty?']()) ? $b : parts.$last()['$[]'](0)['$!='](current_subset)))) {
              
              encoded_char = char$.$chr();
              if ($truthy(encoded_char['$respond_to?']("force_encoding"))) {
                encoded_char.$force_encoding("ASCII-8BIT")};
              parts['$<<']([current_subset, encoded_char]);
              } else {
              parts.$last()['$[]'](1)['$<<'](char$)
            };
            current_char = $rb_plus(current_char, 1);
            if ($truthy($rb_ge(current_char, characters.$length()))) {
              Opal.ret(parts)};
            char$ = characters['$[]'](current_char);
          };
          return (current_subset = $rb_plus(current_subset, 1)['$%'](self.subsets.$length()));}, TMP_6.$$s = self, TMP_6.$$arity = 0, TMP_6));
        } catch ($returner) { if ($returner === Opal.returner) { return $returner.$v } throw $returner; }
      }, TMP_SubsetCollection_encode_7.$$arity = 1), nil) && 'encode';
    })($nesting[0], null, $nesting)
  })($nesting[0], $nesting);
};

/* Generated by Opal 0.11.0 */
Opal.modules["prawn/font/ttf"] = function(Opal) {
  function $rb_times(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs * rhs : lhs['$*'](rhs);
  }
  function $rb_divide(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs / rhs : lhs['$/'](rhs);
  }
  function $rb_minus(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs - rhs : lhs['$-'](rhs);
  }
  function $rb_plus(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs + rhs : lhs['$+'](rhs);
  }
  function $rb_gt(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs > rhs : lhs['$>'](rhs);
  }
  function $rb_ge(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs >= rhs : lhs['$>='](rhs);
  }
  var self = Opal.top, $nesting = [], nil = Opal.nil, $breaker = Opal.breaker, $slice = Opal.slice, $module = Opal.module, $klass = Opal.klass, $send = Opal.send, $hash2 = Opal.hash2, $truthy = Opal.truthy, $range = Opal.range;

  Opal.add_stubs(['$require', '$attr_reader', '$read_ttf_file', '$new', '$exists?', '$kerning', '$any?', '$tables', '$Integer', '$*', '$ascent', '$scale_factor', '$descent', '$line_gap', '$/', '$[]', '$size', '$inject', '$kern', '$is_a?', '$-', '$+', '$character_width_by_code', '$codepoints', '$map', '$bbox', '$chomp', '$last', '$[]=', '$<<', '$encode', '$==', '$first', '$shift', '$unpack', '$postscript_name', '$name', '$postscript', '$italic_angle', '$>>', '$&', '$!=', '$-@', '$^', '$to_f', '$os2', '$cap_height', '$x_height', '$family_class', '$include?', '$fixed_pitch?', '$|', '$serif?', '$script?', '$puts', '$raise', '$encoding', '$>', '$cmap', '$length', '$private', '$unicode', '$fail', '$each_codepoint', '$empty?', '$kern_pairs_table', '$has_kerning_data?', '$pairs', '$max', '$keys', '$code_map', '$pack', '$horizontal_metrics', '$widths', '$hmtx', '$units_per_em', '$header', '$to_sym', '$gsub', '$ref!', '$before_render', '$renderer', '$embed', '$nil?', '$file', '$stream', '$compress!', '$pdf_flags', '$stemV', '$to_unicode_map', '$sort', '$>=', '$%', '$join', '$strip', '$update', '$data', '$open']);
  
  self.$require("ttfunk");
  self.$require("ttfunk/subset_collection");
  return (function($base, $parent_nesting) {
    var $Prawn, self = $Prawn = $module($base, 'Prawn');

    var def = self.$$proto, $nesting = [self].concat($parent_nesting);

    (function($base, $super, $parent_nesting) {
      function $Font(){};
      var self = $Font = $klass($base, $super, 'Font', $Font);

      var def = self.$$proto, $nesting = [self].concat($parent_nesting);

      return (function($base, $super, $parent_nesting) {
        function $TTF(){};
        var self = $TTF = $klass($base, $super, 'TTF', $TTF);

        var def = self.$$proto, $nesting = [self].concat($parent_nesting), TMP_TTF_unicode$q_1, TMP_TTF_initialize_2, TMP_TTF_compute_width_of_6, TMP_TTF_bbox_8, TMP_TTF_has_kerning_data$q_9, TMP_TTF_encode_text_11, TMP_TTF_basename_12, TMP_TTF_stemV_13, TMP_TTF_italic_angle_14, TMP_TTF_cap_height_15, TMP_TTF_x_height_16, TMP_TTF_family_class_17, TMP_TTF_serif$q_18, TMP_TTF_script$q_19, TMP_TTF_pdf_flags_20, TMP_TTF_normalize_encoding_21, TMP_TTF_to_utf8_22, TMP_TTF_glyph_present$q_23, TMP_TTF_character_count_24, TMP_TTF_cmap_25, TMP_TTF_kern_27, TMP_TTF_kern_pairs_table_28, TMP_TTF_cid_to_gid_map_30, TMP_TTF_hmtx_31, TMP_TTF_character_width_by_code_32, TMP_TTF_scale_factor_33, TMP_TTF_register_35, TMP_TTF_embed_39, TMP_TTF_read_ttf_file_40;

        def.ttf = def.bbox = def.has_kerning_data = def.subsets = def.basename = def.italic_angle = def.cap_height = def.ascender = def.family_class = def.serif = def.script = def.flags = def.cmap = def.kerning_data = def.hmtx = def.char_widths = def.scale = def.document = def.descender = def.name = nil;
        
        self.$attr_reader("ttf", "subsets");
        
        Opal.defn(self, '$unicode?', TMP_TTF_unicode$q_1 = function() {
          var self = this;

          return true
        }, TMP_TTF_unicode$q_1.$$arity = 0);
        
        Opal.defn(self, '$initialize', TMP_TTF_initialize_2 = function $$initialize(document, name, options) {
          var $a, self = this, $iter = TMP_TTF_initialize_2.$$p, $yield = $iter || nil, $zuper = nil, $zuper_i = nil, $zuper_ii = nil;

          if (options == null) {
            options = $hash2([], {});
          }
          if ($iter) TMP_TTF_initialize_2.$$p = null;
          // Prepare super implicit arguments
          for($zuper_i = 0, $zuper_ii = arguments.length, $zuper = new Array($zuper_ii); $zuper_i < $zuper_ii; $zuper_i++) {
            $zuper[$zuper_i] = arguments[$zuper_i];
          }
          
          $send(self, Opal.find_super_dispatcher(self, 'initialize', TMP_TTF_initialize_2, false), $zuper, $iter);
          self.ttf = self.$read_ttf_file();
          self.subsets = Opal.const_get_qualified(Opal.const_get_relative($nesting, 'TTFunk'), 'SubsetCollection').$new(self.ttf);
          self.attributes = $hash2([], {});
          self.bounding_boxes = $hash2([], {});
          self.char_widths = $hash2([], {});
          self.has_kerning_data = ($truthy($a = self.ttf.$kerning()['$exists?']()) ? self.ttf.$kerning().$tables()['$any?']() : $a);
          self.ascender = self.$Integer($rb_times(self.ttf.$ascent(), self.$scale_factor()));
          self.descender = self.$Integer($rb_times(self.ttf.$descent(), self.$scale_factor()));
          return (self.line_gap = self.$Integer($rb_times(self.ttf.$line_gap(), self.$scale_factor())));
        }, TMP_TTF_initialize_2.$$arity = -3);
        
        Opal.defn(self, '$compute_width_of', TMP_TTF_compute_width_of_6 = function $$compute_width_of(string, options) {
          var $a, TMP_3, TMP_5, self = this, scale = nil;

          if (options == null) {
            options = $hash2([], {});
          }
          
          scale = $rb_divide(($truthy($a = options['$[]']("size")) ? $a : self.$size()), 1000.0);
          if ($truthy(options['$[]']("kerning"))) {
            return $rb_times($send(self.$kern(string), 'inject', [0], (TMP_3 = function(s, r){var self = TMP_3.$$s || this, TMP_4;
if (s == null) s = nil;if (r == null) r = nil;
            if ($truthy(r['$is_a?'](Opal.const_get_relative($nesting, 'Numeric')))) {
                return $rb_minus(s, r)
                } else {
                return $send(r, 'inject', [s], (TMP_4 = function(s2, u){var self = TMP_4.$$s || this;
if (s2 == null) s2 = nil;if (u == null) u = nil;
                return $rb_plus(s2, self.$character_width_by_code(u))}, TMP_4.$$s = self, TMP_4.$$arity = 2, TMP_4))
              }}, TMP_3.$$s = self, TMP_3.$$arity = 2, TMP_3)), scale)
            } else {
            return $rb_times($send(string.$codepoints(), 'inject', [0], (TMP_5 = function(s, r){var self = TMP_5.$$s || this;
if (s == null) s = nil;if (r == null) r = nil;
            return $rb_plus(s, self.$character_width_by_code(r))}, TMP_5.$$s = self, TMP_5.$$arity = 2, TMP_5)), scale)
          };
        }, TMP_TTF_compute_width_of_6.$$arity = -2);
        
        Opal.defn(self, '$bbox', TMP_TTF_bbox_8 = function $$bbox() {
          var $a, TMP_7, self = this;

          return (self.bbox = ($truthy($a = self.bbox) ? $a : $send(self.ttf.$bbox(), 'map', [], (TMP_7 = function(i){var self = TMP_7.$$s || this;
if (i == null) i = nil;
          return self.$Integer($rb_times(i, self.$scale_factor()))}, TMP_7.$$s = self, TMP_7.$$arity = 1, TMP_7))))
        }, TMP_TTF_bbox_8.$$arity = 0);
        
        Opal.defn(self, '$has_kerning_data?', TMP_TTF_has_kerning_data$q_9 = function() {
          var self = this;

          return self.has_kerning_data
        }, TMP_TTF_has_kerning_data$q_9.$$arity = 0);
        
        Opal.defn(self, '$encode_text', TMP_TTF_encode_text_11 = function $$encode_text(text, options) {
          var TMP_10, self = this, last_subset = nil;

          if (options == null) {
            options = $hash2([], {});
          }
          
          text = text.$chomp();
          if ($truthy(options['$[]']("kerning"))) {
            
            last_subset = nil;
            return $send(self.$kern(text), 'inject', [[]], (TMP_10 = function(result, element){var self = TMP_10.$$s || this, $writer = nil, encoded = nil;
              if (self.subsets == null) self.subsets = nil;
if (result == null) result = nil;if (element == null) element = nil;
            if ($truthy(element['$is_a?'](Opal.const_get_relative($nesting, 'Numeric')))) {
                
                if ($truthy(result.$last()['$[]'](1)['$is_a?'](Opal.const_get_relative($nesting, 'Array')))) {
                  } else {
                  
                  $writer = [1, [result.$last()['$[]'](1)]];
                  $send(result.$last(), '[]=', Opal.to_a($writer));
                  $writer[$rb_minus($writer["length"], 1)];
                };
                result.$last()['$[]'](1)['$<<'](element);
                return result;
                } else {
                
                encoded = self.subsets.$encode(element);
                if (encoded.$first()['$[]'](0)['$=='](last_subset)) {
                  
                  result.$last()['$[]'](1)['$<<'](encoded.$first()['$[]'](1));
                  encoded.$shift();};
                if ($truthy(encoded['$any?']())) {
                  
                  last_subset = encoded.$last()['$[]'](0);
                  return $rb_plus(result, encoded);
                  } else {
                  return result
                };
              }}, TMP_10.$$s = self, TMP_10.$$arity = 2, TMP_10));
            } else {
            return self.subsets.$encode(text.$unpack("U*"))
          };
        }, TMP_TTF_encode_text_11.$$arity = -2);
        
        Opal.defn(self, '$basename', TMP_TTF_basename_12 = function $$basename() {
          var $a, self = this;

          return (self.basename = ($truthy($a = self.basename) ? $a : self.ttf.$name().$postscript_name()))
        }, TMP_TTF_basename_12.$$arity = 0);
        
        Opal.defn(self, '$stemV', TMP_TTF_stemV_13 = function $$stemV() {
          var self = this;

          return 0
        }, TMP_TTF_stemV_13.$$arity = 0);
        
        Opal.defn(self, '$italic_angle', TMP_TTF_italic_angle_14 = function $$italic_angle() {
          var $a, self = this, raw = nil, hi = nil, low = nil;

          
          if ($truthy(self.italic_angle)) {
            return self.italic_angle};
          if ($truthy(self.ttf.$postscript()['$exists?']())) {
            
            raw = self.ttf.$postscript().$italic_angle();
            $a = [raw['$>>'](16), raw['$&'](255)], (hi = $a[0]), (low = $a[1]), $a;
            if ($truthy(hi['$&'](32768)['$!='](0))) {
              hi = $rb_plus(hi['$^'](65535), 1)['$-@']()};
            self.italic_angle = ((("" + (hi)) + ".") + (low)).$to_f();
            } else {
            self.italic_angle = 0
          };
          return self.italic_angle;
        }, TMP_TTF_italic_angle_14.$$arity = 0);
        
        Opal.defn(self, '$cap_height', TMP_TTF_cap_height_15 = function $$cap_height() {
          var $a, $b, $c, self = this, height = nil;

          return (self.cap_height = ($truthy($a = self.cap_height) ? $a : ((height = ($truthy($b = ($truthy($c = self.ttf.$os2()['$exists?']()) ? self.ttf.$os2().$cap_height() : $c)) ? $b : 0)), (function() {if (height['$=='](0)) {
            return self.ascender
            } else {
            return height
          }; return nil; })())))
        }, TMP_TTF_cap_height_15.$$arity = 0);
        
        Opal.defn(self, '$x_height', TMP_TTF_x_height_16 = function $$x_height() {
          var $a, $b, self = this;

          return ($truthy($a = ($truthy($b = self.ttf.$os2()['$exists?']()) ? self.ttf.$os2().$x_height() : $b)) ? $a : 0)
        }, TMP_TTF_x_height_16.$$arity = 0);
        
        Opal.defn(self, '$family_class', TMP_TTF_family_class_17 = function $$family_class() {
          var $a, $b, $c, self = this;

          return (self.family_class = ($truthy($a = self.family_class) ? $a : ($truthy($b = ($truthy($c = self.ttf.$os2()['$exists?']()) ? self.ttf.$os2().$family_class() : $c)) ? $b : 0)['$>>'](8)))
        }, TMP_TTF_family_class_17.$$arity = 0);
        
        Opal.defn(self, '$serif?', TMP_TTF_serif$q_18 = function() {
          var $a, self = this;

          return (self.serif = ($truthy($a = self.serif) ? $a : [1, 2, 3, 4, 5, 7]['$include?'](self.$family_class())))
        }, TMP_TTF_serif$q_18.$$arity = 0);
        
        Opal.defn(self, '$script?', TMP_TTF_script$q_19 = function() {
          var $a, self = this;

          return (self.script = ($truthy($a = self.script) ? $a : self.$family_class()['$=='](10)))
        }, TMP_TTF_script$q_19.$$arity = 0);
        
        Opal.defn(self, '$pdf_flags', TMP_TTF_pdf_flags_20 = function $$pdf_flags() {
          var $a, self = this, flags = nil;

          return (self.flags = ($truthy($a = self.flags) ? $a : ((flags = 0), (function() {if ($truthy(self.ttf.$postscript()['$fixed_pitch?']())) {
            return (flags = flags['$|'](1))
            } else {
            return nil
          }; return nil; })(), (function() {if ($truthy(self['$serif?']())) {
            return (flags = flags['$|'](2))
            } else {
            return nil
          }; return nil; })(), (function() {if ($truthy(self['$script?']())) {
            return (flags = flags['$|'](8))
            } else {
            return nil
          }; return nil; })(), (function() {if ($truthy(self.$italic_angle()['$!='](0))) {
            return (flags = flags['$|'](64))
            } else {
            return nil
          }; return nil; })(), (flags = flags['$|'](4)))))
        }, TMP_TTF_pdf_flags_20.$$arity = 0);
        
        Opal.defn(self, '$normalize_encoding', TMP_TTF_normalize_encoding_21 = function $$normalize_encoding(text) {
          var self = this, e = nil;

          
          try {
            return text.$encode(Opal.const_get_qualified(Opal.const_get_qualified('::', 'Encoding'), 'UTF_8'))
          } catch ($err) {
            if (Opal.rescue($err, [Opal.const_get_relative($nesting, 'StandardError')])) {e = $err;
              try {
                
                self.$puts(e);
                return self.$raise(Opal.const_get_qualified(Opal.const_get_qualified(Opal.const_get_relative($nesting, 'Prawn'), 'Errors'), 'IncompatibleStringEncoding'), "" + "Encoding " + ("" + (text.$encoding()) + " can not be transparently converted to UTF-8. ") + "Please ensure the encoding of the string you are attempting " + "to use is set correctly");
              } finally { Opal.pop_exception() }
            } else { throw $err; }
          };
        }, TMP_TTF_normalize_encoding_21.$$arity = 1);
        
        Opal.defn(self, '$to_utf8', TMP_TTF_to_utf8_22 = function $$to_utf8(text) {
          var self = this;

          return text.$encode("UTF-8")
        }, TMP_TTF_to_utf8_22.$$arity = 1);
        
        Opal.defn(self, '$glyph_present?', TMP_TTF_glyph_present$q_23 = function(char$) {
          var self = this, code = nil;

          
          code = char$.$codepoints().$first();
          return $rb_gt(self.$cmap()['$[]'](code), 0);
        }, TMP_TTF_glyph_present$q_23.$$arity = 1);
        
        Opal.defn(self, '$character_count', TMP_TTF_character_count_24 = function $$character_count(str) {
          var self = this;

          return str.$length()
        }, TMP_TTF_character_count_24.$$arity = 1);
        self.$private();
        
        Opal.defn(self, '$cmap', TMP_TTF_cmap_25 = function $$cmap() {
          var $a, $b, self = this;

          return ($truthy($a = (self.cmap = ($truthy($b = self.cmap) ? $b : self.ttf.$cmap().$unicode().$first()))) ? $a : self.$fail("no unicode cmap for font"))
        }, TMP_TTF_cmap_25.$$arity = 0);
        
        Opal.defn(self, '$kern', TMP_TTF_kern_27 = function $$kern(string) {
          var TMP_26, self = this, a = nil;

          
          a = [];
          $send(string, 'each_codepoint', [], (TMP_26 = function(r){var self = TMP_26.$$s || this, kern = nil;
if (r == null) r = nil;
          if ($truthy(a['$empty?']())) {
              return a['$<<']([r])
            } else if ($truthy((kern = self.$kern_pairs_table()['$[]']([self.$cmap()['$[]'](a.$last().$last()), self.$cmap()['$[]'](r)])))) {
              
              kern = $rb_times(kern, self.$scale_factor());
              return a['$<<'](kern['$-@']())['$<<']([r]);
              } else {
              return a.$last()['$<<'](r)
            }}, TMP_26.$$s = self, TMP_26.$$arity = 1, TMP_26));
          return a;
        }, TMP_TTF_kern_27.$$arity = 1);
        
        Opal.defn(self, '$kern_pairs_table', TMP_TTF_kern_pairs_table_28 = function $$kern_pairs_table() {
          var $a, self = this;

          return (self.kerning_data = ($truthy($a = self.kerning_data) ? $a : (function() {if ($truthy(self['$has_kerning_data?']())) {
            return self.ttf.$kerning().$tables().$first().$pairs()
            } else {
            return $hash2([], {})
          }; return nil; })()))
        }, TMP_TTF_kern_pairs_table_28.$$arity = 0);
        
        Opal.defn(self, '$cid_to_gid_map', TMP_TTF_cid_to_gid_map_30 = function $$cid_to_gid_map() {
          var TMP_29, self = this, max = nil;

          
          max = self.$cmap().$code_map().$keys().$max();
          return $send(Opal.Range.$new(0, max, false), 'map', [], (TMP_29 = function(cid){var self = TMP_29.$$s || this;
if (cid == null) cid = nil;
          return self.$cmap()['$[]'](cid)}, TMP_29.$$s = self, TMP_29.$$arity = 1, TMP_29)).$pack("n*");
        }, TMP_TTF_cid_to_gid_map_30.$$arity = 0);
        
        Opal.defn(self, '$hmtx', TMP_TTF_hmtx_31 = function $$hmtx() {
          var $a, self = this;

          return (self.hmtx = ($truthy($a = self.hmtx) ? $a : self.ttf.$horizontal_metrics()))
        }, TMP_TTF_hmtx_31.$$arity = 0);
        
        Opal.defn(self, '$character_width_by_code', TMP_TTF_character_width_by_code_32 = function $$character_width_by_code(code) {
          var $a, self = this, $writer = nil;

          
          if ($truthy(self.$cmap()['$[]'](code))) {
            } else {
            return 0
          };
          if (code['$=='](10)) {
            return 0.0};
          return ($truthy($a = self.char_widths['$[]'](code)) ? $a : (($writer = [code, self.$Integer($rb_times(self.$hmtx().$widths()['$[]'](self.$cmap()['$[]'](code)), self.$scale_factor()))]), $send(self.char_widths, '[]=', Opal.to_a($writer)), $writer[$rb_minus($writer["length"], 1)]));
        }, TMP_TTF_character_width_by_code_32.$$arity = 1);
        
        Opal.defn(self, '$scale_factor', TMP_TTF_scale_factor_33 = function $$scale_factor() {
          var $a, self = this;

          return (self.scale = ($truthy($a = self.scale) ? $a : $rb_divide(1000.0, self.ttf.$header().$units_per_em())))
        }, TMP_TTF_scale_factor_33.$$arity = 0);
        
        Opal.defn(self, '$register', TMP_TTF_register_35 = function $$register(subset) {
          var TMP_34, self = this, temp_name = nil, ref = nil;

          
          temp_name = self.ttf.$name().$postscript_name().$gsub("\u0000", "").$to_sym();
          ref = self.document['$ref!']($hash2(["Type", "BaseFont"], {"Type": "Font", "BaseFont": temp_name}));
          $send(self.document.$renderer(), 'before_render', [], (TMP_34 = function(doc){var self = TMP_34.$$s || this;
if (doc == null) doc = nil;
          return self.$embed(ref, subset)}, TMP_34.$$s = self, TMP_34.$$arity = 1, TMP_34));
          return ref;
        }, TMP_TTF_register_35.$$arity = 1);
        
        Opal.defn(self, '$embed', TMP_TTF_embed_39 = function $$embed(reference, subset) {
          var TMP_36, TMP_37, TMP_38, self = this, font_content = nil, font = nil, basename = nil, fontfile = nil, descriptor = nil, hmtx = nil, widths = nil, map = nil, ranges = nil, range_blocks = nil, to_unicode_cmap = nil, cmap = nil;

          
          font_content = self.subsets['$[]'](subset).$encode();
          font = Opal.const_get_qualified(Opal.const_get_relative($nesting, 'TTFunk'), 'File').$new(font_content);
          basename = font.$name().$postscript_name()['$[]'](0, 33).$gsub("\u0000", "");
          if ($truthy(basename['$nil?']())) {
            self.$fail("" + "Can't detect a postscript name for " + (self.$file()))};
          fontfile = self.document['$ref!']($hash2(["Length1"], {"Length1": font_content.$size()}));
          fontfile.$stream()['$<<'](font_content);
          fontfile.$stream()['$compress!']();
          descriptor = self.document['$ref!']($hash2(["Type", "FontName", "FontFile2", "FontBBox", "Flags", "StemV", "ItalicAngle", "Ascent", "Descent", "CapHeight", "XHeight"], {"Type": "FontDescriptor", "FontName": basename.$to_sym(), "FontFile2": fontfile, "FontBBox": self.$bbox(), "Flags": self.$pdf_flags(), "StemV": self.$stemV(), "ItalicAngle": self.$italic_angle(), "Ascent": self.ascender, "Descent": self.descender, "CapHeight": self.$cap_height(), "XHeight": self.$x_height()}));
          hmtx = font.$horizontal_metrics();
          widths = $send(font.$cmap().$tables().$first().$code_map(), 'map', [], (TMP_36 = function(gid){var self = TMP_36.$$s || this;
if (gid == null) gid = nil;
          return self.$Integer($rb_times(hmtx.$widths()['$[]'](gid), self.$scale_factor()))}, TMP_36.$$s = self, TMP_36.$$arity = 1, TMP_36))['$[]']($range(32, -1, false));
          map = self.subsets['$[]'](subset).$to_unicode_map();
          ranges = [[]];
          $send(map.$keys().$sort(), 'inject', [""], (TMP_37 = function(s, code){var self = TMP_37.$$s || this, unicode = nil;
if (s == null) s = nil;if (code == null) code = nil;
          
            if ($truthy($rb_ge(ranges.$last().$length(), 100))) {
              ranges['$<<']([])};
            unicode = map['$[]'](code);
            return ranges.$last()['$<<']("<%02x><%04x>"['$%']([code, unicode]));}, TMP_37.$$s = self, TMP_37.$$arity = 2, TMP_37));
          range_blocks = $send(ranges, 'inject', [""], (TMP_38 = function(s, list){var self = TMP_38.$$s || this;
if (s == null) s = nil;if (list == null) list = nil;
          return s['$<<']("%d beginbfchar\n%s\nendbfchar\n"['$%']([list.$length(), list.$join("\n")]))}, TMP_38.$$s = self, TMP_38.$$arity = 2, TMP_38));
          to_unicode_cmap = Opal.const_get_relative($nesting, 'UNICODE_CMAP_TEMPLATE')['$%'](range_blocks.$strip());
          cmap = self.document['$ref!']($hash2([], {}));
          cmap['$<<'](to_unicode_cmap);
          cmap.$stream()['$compress!']();
          return reference.$data().$update($hash2(["Subtype", "BaseFont", "FontDescriptor", "FirstChar", "LastChar", "Widths", "ToUnicode"], {"Subtype": "TrueType", "BaseFont": basename.$to_sym(), "FontDescriptor": descriptor, "FirstChar": 32, "LastChar": 255, "Widths": self.document['$ref!'](widths), "ToUnicode": cmap}));
        }, TMP_TTF_embed_39.$$arity = 2);
        Opal.const_set($nesting[0], 'UNICODE_CMAP_TEMPLATE', (((((((((((((((((("" + "        /CIDInit /ProcSet findresource begin\n") + "        12 dict begin\n") + "        begincmap\n") + "        /CIDSystemInfo <<\n") + "          /Registry (Adobe)\n") + "          /Ordering (UCS)\n") + "          /Supplement 0\n") + "        >> def\n") + "        /CMapName /Adobe-Identity-UCS def\n") + "        /CMapType 2 def\n") + "        1 begincodespacerange\n") + "        <00><ff>\n") + "        endcodespacerange\n") + "        %s\n") + "        endcmap\n") + "        CMapName currentdict /CMap defineresource pop\n") + "        end\n") + "        end\n").$strip().$gsub(/^\s*/, ""));
        return (Opal.defn(self, '$read_ttf_file', TMP_TTF_read_ttf_file_40 = function $$read_ttf_file() {
          var self = this;

          return Opal.const_get_qualified(Opal.const_get_relative($nesting, 'TTFunk'), 'File').$open(self.name)
        }, TMP_TTF_read_ttf_file_40.$$arity = 0), nil) && 'read_ttf_file';
      })($nesting[0], Opal.const_get_relative($nesting, 'Font'), $nesting)
    })($nesting[0], null, $nesting)
  })($nesting[0], $nesting);
};

/* Generated by Opal 0.11.0 */
Opal.modules["prawn/font/dfont"] = function(Opal) {
  var self = Opal.top, $nesting = [], nil = Opal.nil, $breaker = Opal.breaker, $slice = Opal.slice, $module = Opal.module, $klass = Opal.klass, $send = Opal.send, $truthy = Opal.truthy;

  Opal.add_stubs(['$open', '$resources_for', '$length', '$[]', '$map', '$private', '$from_dfont']);
  
  self.$require("prawn/font/dfont"+ '/../' + "ttf");
  return (function($base, $parent_nesting) {
    var $Prawn, self = $Prawn = $module($base, 'Prawn');

    var def = self.$$proto, $nesting = [self].concat($parent_nesting);

    (function($base, $super, $parent_nesting) {
      function $Font(){};
      var self = $Font = $klass($base, $super, 'Font', $Font);

      var def = self.$$proto, $nesting = [self].concat($parent_nesting);

      return (function($base, $super, $parent_nesting) {
        function $DFont(){};
        var self = $DFont = $klass($base, $super, 'DFont', $DFont);

        var def = self.$$proto, $nesting = [self].concat($parent_nesting), TMP_DFont_named_fonts_2, TMP_DFont_font_count_4, TMP_DFont_read_ttf_file_5;

        def.name = def.options = nil;
        
        Opal.defs(self, '$named_fonts', TMP_DFont_named_fonts_2 = function $$named_fonts(file) {try {

          var TMP_1, self = this;

          return $send(Opal.const_get_qualified(Opal.const_get_relative($nesting, 'TTFunk'), 'ResourceFile'), 'open', [file], (TMP_1 = function(f){var self = TMP_1.$$s || this;
if (f == null) f = nil;
          Opal.ret(f.$resources_for("sfnt"))}, TMP_1.$$s = self, TMP_1.$$arity = 1, TMP_1))
          } catch ($returner) { if ($returner === Opal.returner) { return $returner.$v } throw $returner; }
        }, TMP_DFont_named_fonts_2.$$arity = 1);
        Opal.defs(self, '$font_count', TMP_DFont_font_count_4 = function $$font_count(file) {try {

          var TMP_3, self = this;

          return $send(Opal.const_get_qualified(Opal.const_get_relative($nesting, 'TTFunk'), 'ResourceFile'), 'open', [file], (TMP_3 = function(f){var self = TMP_3.$$s || this;
if (f == null) f = nil;
          Opal.ret(f.$map()['$[]']("sfnt")['$[]']("list").$length())}, TMP_3.$$s = self, TMP_3.$$arity = 1, TMP_3))
          } catch ($returner) { if ($returner === Opal.returner) { return $returner.$v } throw $returner; }
        }, TMP_DFont_font_count_4.$$arity = 1);
        self.$private();
        return (Opal.defn(self, '$read_ttf_file', TMP_DFont_read_ttf_file_5 = function $$read_ttf_file() {
          var $a, self = this;

          return Opal.const_get_qualified(Opal.const_get_relative($nesting, 'TTFunk'), 'File').$from_dfont(self.name, ($truthy($a = self.options['$[]']("font")) ? $a : 0))
        }, TMP_DFont_read_ttf_file_5.$$arity = 0), nil) && 'read_ttf_file';
      })($nesting[0], Opal.const_get_relative($nesting, 'TTF'), $nesting)
    })($nesting[0], null, $nesting)
  })($nesting[0], $nesting);
};

/* Generated by Opal 0.11.0 */
Opal.modules["prawn/font_metric_cache"] = function(Opal) {
  function $rb_minus(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs - rhs : lhs['$-'](rhs);
  }
  function $rb_plus(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs + rhs : lhs['$+'](rhs);
  }
  function $rb_times(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs * rhs : lhs['$*'](rhs);
  }
  var self = Opal.top, $nesting = [], nil = Opal.nil, $breaker = Opal.breaker, $slice = Opal.slice, $module = Opal.module, $klass = Opal.klass, $hash2 = Opal.hash2, $truthy = Opal.truthy, $send = Opal.send;

  Opal.add_stubs(['$new', '$[]', '$find_font', '$family', '$font', '$compute_width_of', '$[]=', '$-', '$+', '$*', '$character_spacing', '$character_count']);
  return (function($base, $parent_nesting) {
    var $Prawn, self = $Prawn = $module($base, 'Prawn');

    var def = self.$$proto, $nesting = [self].concat($parent_nesting);

    (function($base, $super, $parent_nesting) {
      function $FontMetricCache(){};
      var self = $FontMetricCache = $klass($base, $super, 'FontMetricCache', $FontMetricCache);

      var def = self.$$proto, $nesting = [self].concat($parent_nesting), TMP_FontMetricCache_initialize_1, TMP_FontMetricCache_width_of_2;

      def.document = def.cache = nil;
      
      Opal.const_set($nesting[0], 'CacheEntry', Opal.const_get_relative($nesting, 'Struct').$new("font", "options", "string"));
      
      Opal.defn(self, '$initialize', TMP_FontMetricCache_initialize_1 = function $$initialize(document) {
        var self = this;

        
        self.document = document;
        return (self.cache = $hash2([], {}));
      }, TMP_FontMetricCache_initialize_1.$$arity = 1);
      return (Opal.defn(self, '$width_of', TMP_FontMetricCache_width_of_2 = function $$width_of(string, options) {
        var self = this, f = nil, key = nil, length = nil, $writer = nil;

        
        f = (function() {if ($truthy(options['$[]']("style"))) {
          return self.document.$find_font(self.document.$font().$family(), $hash2(["style"], {"style": options['$[]']("style")}))
          } else {
          return self.document.$font()
        }; return nil; })();
        key = Opal.const_get_relative($nesting, 'CacheEntry').$new(f, options, string);
        if ($truthy((length = self.cache['$[]'](key)))) {
          } else {
          length = (($writer = [key, f.$compute_width_of(string, options)]), $send(self.cache, '[]=', Opal.to_a($writer)), $writer[$rb_minus($writer["length"], 1)])
        };
        return $rb_plus(length, $rb_times(self.document.$character_spacing(), self.document.$font().$character_count(string)));
      }, TMP_FontMetricCache_width_of_2.$$arity = 2), nil) && 'width_of';
    })($nesting[0], null, $nesting)
  })($nesting[0], $nesting)
};

/* Generated by Opal 0.11.0 */
Opal.modules["prawn/font"] = function(Opal) {
  function $rb_minus(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs - rhs : lhs['$-'](rhs);
  }
  function $rb_times(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs * rhs : lhs['$*'](rhs);
  }
  function $rb_divide(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs / rhs : lhs['$/'](rhs);
  }
  function $rb_plus(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs + rhs : lhs['$+'](rhs);
  }
  var self = Opal.top, $nesting = [], nil = Opal.nil, $breaker = Opal.breaker, $slice = Opal.slice, $module = Opal.module, $klass = Opal.klass, $truthy = Opal.truthy, $send = Opal.send, $hash2 = Opal.hash2, $hash = Opal.hash;

  Opal.add_stubs(['$nil?', '$font', '$empty?', '$pages', '$state', '$!', '$in_stamp_stream?', '$page', '$fail', '$find_font', '$to_s', '$save_font', '$set_font', '$[]', '$font_size', '$is_a?', '$new', '$format', '$text_formatter', '$consumed=', '$-', '$finalize_line', '$line_width', '$width_of_string', '$merge!', '$key?', '$font_families', '$merge', '$[]=', '$font_registry', '$load', '$private', '$width_of', '$font_metric_cache', '$attr_reader', '$font_format', '$===', '$respond_to?', '$fetch', '$generate_unique_id', '$*', '$/', '$size', '$-@', '$replace', '$normalize_encoding', '$+', '$height_at', '$register', '$fonts', '$identifier_for', '$name', '$class', '$hash', '$family', '$==', '$send', '$loop', '$key_is_unique?', '$any?', '$keys', '$start_with?']);
  
  self.$require("prawn/font"+ '/../' + "font/afm");
  self.$require("prawn/font"+ '/../' + "font/ttf");
  self.$require("prawn/font"+ '/../' + "font/dfont");
  self.$require("prawn/font"+ '/../' + "font_metric_cache");
  return (function($base, $parent_nesting) {
    var $Prawn, self = $Prawn = $module($base, 'Prawn');

    var def = self.$$proto, $nesting = [self].concat($parent_nesting);

    
    (function($base, $super, $parent_nesting) {
      function $Document(){};
      var self = $Document = $klass($base, $super, 'Document', $Document);

      var def = self.$$proto, $nesting = [self].concat($parent_nesting), TMP_Document_font_1, TMP_Document_font_size_3, TMP_Document_font_size$eq_4, TMP_Document_width_of_5, TMP_Document_font_families_6, TMP_Document_set_font_7, TMP_Document_save_font_8, TMP_Document_find_font_9, TMP_Document_font_registry_10, TMP_Document_width_of_inline_formatted_string_11, TMP_Document_width_of_string_12;

      def.font = def.font_size = def.font_families = def.font_registry = nil;
      
      
      Opal.defn(self, '$font', TMP_Document_font_1 = function $$font(name, options) {
        var $a, $b, $c, TMP_2, self = this, $iter = TMP_Document_font_1.$$p, $yield = $iter || nil, new_font = nil;

        if (name == null) {
          name = nil;
        }
        if (options == null) {
          options = $hash2([], {});
        }
        if ($iter) TMP_Document_font_1.$$p = null;
        
        if ($truthy(name['$nil?']())) {
          return ($truthy($a = ($truthy($b = (($c = self['font'], $c != null && $c !== nil) ? 'instance-variable' : nil)) ? self.font : $b)) ? $a : self.$font("Helvetica"))};
        if ($truthy(($truthy($a = self.$state().$pages()['$empty?']()) ? self.$state().$page()['$in_stamp_stream?']()['$!']() : $a))) {
          self.$fail(Opal.const_get_qualified(Opal.const_get_qualified(Opal.const_get_relative($nesting, 'Prawn'), 'Errors'), 'NotOnPage'))};
        new_font = self.$find_font(name.$to_s(), options);
        if (($yield !== nil)) {
          $send(self, 'save_font', [], (TMP_2 = function(){var self = TMP_2.$$s || this;

          
            self.$set_font(new_font, options['$[]']("size"));
            return Opal.yieldX($yield, []);;}, TMP_2.$$s = self, TMP_2.$$arity = 0, TMP_2))
          } else {
          self.$set_font(new_font, options['$[]']("size"))
        };
        return self.font;
      }, TMP_Document_font_1.$$arity = -1);
      
      Opal.defn(self, '$font_size', TMP_Document_font_size_3 = function $$font_size(points) {
        var self = this, $iter = TMP_Document_font_size_3.$$p, $yield = $iter || nil, size_before_yield = nil;

        if (points == null) {
          points = nil;
        }
        if ($iter) TMP_Document_font_size_3.$$p = null;
        
        if ($truthy(points)) {
          } else {
          return self.font_size
        };
        size_before_yield = self.font_size;
        self.font_size = points;
        if (($yield !== nil)) {
          Opal.yieldX($yield, [])
          } else {
          return nil
        };
        return (self.font_size = size_before_yield);
      }, TMP_Document_font_size_3.$$arity = -1);
      
      Opal.defn(self, '$font_size=', TMP_Document_font_size$eq_4 = function(size) {
        var self = this;

        return self.$font_size(size)
      }, TMP_Document_font_size$eq_4.$$arity = 1);
      
      Opal.defn(self, '$width_of', TMP_Document_width_of_5 = function $$width_of(string, options) {
        var self = this, p = nil, arranger = nil, $writer = nil;

        if (options == null) {
          options = $hash2([], {});
        }
        if ($truthy((p = options['$[]']("inline_format")))) {
          
          if ($truthy(p['$is_a?'](Opal.const_get_relative($nesting, 'Array')))) {
            } else {
            p = []
          };
          arranger = Opal.const_get_qualified(Opal.const_get_qualified(Opal.const_get_qualified(Opal.const_get_relative($nesting, 'Prawn'), 'Text'), 'Formatted'), 'Arranger').$new(self, options);
          
          $writer = [$send(self.$text_formatter(), 'format', [string].concat(Opal.to_a(p)))];
          $send(arranger, 'consumed=', Opal.to_a($writer));
          $writer[$rb_minus($writer["length"], 1)];;
          arranger.$finalize_line();
          return arranger.$line_width();
          } else {
          return self.$width_of_string(string, options)
        }
      }, TMP_Document_width_of_5.$$arity = -2);
      
      Opal.defn(self, '$font_families', TMP_Document_font_families_6 = function $$font_families() {
        var $a, self = this;

        return (self.font_families = ($truthy($a = self.font_families) ? $a : $hash2([], {})['$merge!']($hash2(["Courier", "Times-Roman", "Helvetica"], {"Courier": $hash2(["bold", "italic", "bold_italic", "normal"], {"bold": "Courier-Bold", "italic": "Courier-Oblique", "bold_italic": "Courier-BoldOblique", "normal": "Courier"}), "Times-Roman": $hash2(["bold", "italic", "bold_italic", "normal"], {"bold": "Times-Bold", "italic": "Times-Italic", "bold_italic": "Times-BoldItalic", "normal": "Times-Roman"}), "Helvetica": $hash2(["bold", "italic", "bold_italic", "normal"], {"bold": "Helvetica-Bold", "italic": "Helvetica-Oblique", "bold_italic": "Helvetica-BoldOblique", "normal": "Helvetica"})}))))
      }, TMP_Document_font_families_6.$$arity = 0);
      
      Opal.defn(self, '$set_font', TMP_Document_set_font_7 = function $$set_font(font, size) {
        var self = this;

        if (size == null) {
          size = nil;
        }
        
        self.font = font;
        if ($truthy(size)) {
          return (self.font_size = size)
          } else {
          return nil
        };
      }, TMP_Document_set_font_7.$$arity = -2);
      
      Opal.defn(self, '$save_font', TMP_Document_save_font_8 = function $$save_font() {
        var $a, self = this, $iter = TMP_Document_save_font_8.$$p, $yield = $iter || nil, original_font = nil, original_size = nil;

        if ($iter) TMP_Document_save_font_8.$$p = null;
        return (function() { try {
        
        self.font = ($truthy($a = self.font) ? $a : self.$find_font("Helvetica"));
        original_font = self.font;
        original_size = self.font_size;
        return Opal.yieldX($yield, []);;
        } finally {
          (function() {if ($truthy(original_font)) {
            return self.$set_font(original_font, original_size)
            } else {
            return nil
          }; return nil; })()
        }; })()
      }, TMP_Document_save_font_8.$$arity = 0);
      
      Opal.defn(self, '$find_font', TMP_Document_find_font_9 = function $$find_font(name, options) {
        var $a, $b, self = this, family = nil, key = nil, $writer = nil, $logical_op_recvr_tmp_12 = nil;

        if (options == null) {
          options = $hash2([], {});
        }
        
        if ($truthy(self.$font_families()['$key?'](name))) {
          
          $a = [name, self.$font_families()['$[]'](name)['$[]'](($truthy($b = options['$[]']("style")) ? $b : "normal"))], (family = $a[0]), (name = $a[1]), $a;
          if ($truthy(name['$is_a?'](Opal.const_get_qualified('::', 'Hash')))) {
            
            options = options.$merge(name);
            name = options['$[]']("file");};};
        key = "" + (name) + ":" + (($truthy($a = options['$[]']("font")) ? $a : 0));
        if ($truthy(name['$is_a?'](Opal.const_get_qualified(Opal.const_get_relative($nesting, 'Prawn'), 'Font')))) {
          
          $writer = [key, name];
          $send(self.$font_registry(), '[]=', Opal.to_a($writer));
          return $writer[$rb_minus($writer["length"], 1)];
          } else {
          
          $logical_op_recvr_tmp_12 = self.$font_registry();
          return ($truthy($a = $logical_op_recvr_tmp_12['$[]'](key)) ? $a : (($writer = [key, Opal.const_get_relative($nesting, 'Font').$load(self, name, options.$merge($hash2(["family"], {"family": family})))]), $send($logical_op_recvr_tmp_12, '[]=', Opal.to_a($writer)), $writer[$rb_minus($writer["length"], 1)]));
        };
      }, TMP_Document_find_font_9.$$arity = -2);
      
      Opal.defn(self, '$font_registry', TMP_Document_font_registry_10 = function $$font_registry() {
        var $a, self = this;

        return (self.font_registry = ($truthy($a = self.font_registry) ? $a : $hash2([], {})))
      }, TMP_Document_font_registry_10.$$arity = 0);
      self.$private();
      
      Opal.defn(self, '$width_of_inline_formatted_string', TMP_Document_width_of_inline_formatted_string_11 = function $$width_of_inline_formatted_string(string, options) {
        var self = this, arranger = nil, $writer = nil;

        if (options == null) {
          options = $hash2([], {});
        }
        
        arranger = Opal.const_get_qualified(Opal.const_get_qualified(Opal.const_get_qualified(Opal.const_get_relative($nesting, 'Prawn'), 'Text'), 'Formatted'), 'Arranger').$new(self, options);
        
        $writer = [Opal.const_get_qualified(Opal.const_get_qualified(Opal.const_get_relative($nesting, 'Text'), 'Formatted'), 'Parser').$format(string)];
        $send(arranger, 'consumed=', Opal.to_a($writer));
        $writer[$rb_minus($writer["length"], 1)];;
        arranger.$finalize_line();
        return arranger.$line_width();
      }, TMP_Document_width_of_inline_formatted_string_11.$$arity = -2);
      return (Opal.defn(self, '$width_of_string', TMP_Document_width_of_string_12 = function $$width_of_string(string, options) {
        var self = this;

        if (options == null) {
          options = $hash2([], {});
        }
        return self.$font_metric_cache().$width_of(string, options)
      }, TMP_Document_width_of_string_12.$$arity = -2), nil) && 'width_of_string';
    })($nesting[0], null, $nesting);
    (function($base, $super, $parent_nesting) {
      function $Font(){};
      var self = $Font = $klass($base, $super, 'Font', $Font);

      var def = self.$$proto, $nesting = [self].concat($parent_nesting), TMP_Font_load_13, TMP_Font_font_format_14, TMP_Font_initialize_15, TMP_Font_ascender_16, TMP_Font_descender_17, TMP_Font_line_gap_18, TMP_Font_normalize_encoding_19, TMP_Font_normalize_encoding$B_20, TMP_Font_height_at_21, TMP_Font_height_22, TMP_Font_add_to_current_page_23, TMP_Font_identifier_for_24, TMP_Font_inspect_25, TMP_Font_hash_26, TMP_Font_eql$q_27, TMP_Font_generate_unique_id_29, TMP_Font_key_is_unique$q_31, TMP_Font_size_32;

      def.ascender = def.descender = def.line_gap = def.normalized_height = def.references = def.document = def.identifier = nil;
      
      self.$attr_reader("name");
      self.$attr_reader("family");
      self.$attr_reader("options");
      Opal.defs(self, '$load', TMP_Font_load_13 = function $$load(document, src, options) {
        var self = this, $case = nil;

        if (options == null) {
          options = $hash2([], {});
        }
        return (function() {$case = self.$font_format(src, options);
        if ("ttf"['$===']($case)) {return Opal.const_get_relative($nesting, 'TTF').$new(document, src, options)}
        else if ("dfont"['$===']($case)) {return Opal.const_get_relative($nesting, 'DFont').$new(document, src, options)}
        else {return Opal.const_get_relative($nesting, 'AFM').$new(document, src, options)}})()
      }, TMP_Font_load_13.$$arity = -3);
      Opal.defs(self, '$font_format', TMP_Font_font_format_14 = function $$font_format(src, options) {
        var self = this, $case = nil;

        
        if ($truthy(src['$respond_to?']("read"))) {
          return options.$fetch("format", "ttf")};
        return (function() {$case = src.$to_s();
        if (/\.ttf$/i['$===']($case)) {return "ttf"}
        else if (/\.dfont$/i['$===']($case)) {return "dfont"}
        else {return "afm"}})();
      }, TMP_Font_font_format_14.$$arity = 2);
      
      Opal.defn(self, '$initialize', TMP_Font_initialize_15 = function $$initialize(document, name, options) {
        var self = this;

        if (options == null) {
          options = $hash2([], {});
        }
        
        self.document = document;
        self.name = name;
        self.options = options;
        self.family = options['$[]']("family");
        self.identifier = self.$generate_unique_id();
        return (self.references = $hash2([], {}));
      }, TMP_Font_initialize_15.$$arity = -3);
      
      Opal.defn(self, '$ascender', TMP_Font_ascender_16 = function $$ascender() {
        var self = this;

        return $rb_times($rb_divide(self.ascender, 1000.0), self.$size())
      }, TMP_Font_ascender_16.$$arity = 0);
      
      Opal.defn(self, '$descender', TMP_Font_descender_17 = function $$descender() {
        var self = this;

        return $rb_times($rb_divide(self.descender['$-@'](), 1000.0), self.$size())
      }, TMP_Font_descender_17.$$arity = 0);
      
      Opal.defn(self, '$line_gap', TMP_Font_line_gap_18 = function $$line_gap() {
        var self = this;

        return $rb_times($rb_divide(self.line_gap, 1000.0), self.$size())
      }, TMP_Font_line_gap_18.$$arity = 0);
      
      Opal.defn(self, '$normalize_encoding', TMP_Font_normalize_encoding_19 = function $$normalize_encoding(string) {
        var self = this;

        return self.$fail(Opal.const_get_relative($nesting, 'NotImplementedError'), "subclasses of Prawn::Font must implement #normalize_encoding")
      }, TMP_Font_normalize_encoding_19.$$arity = 1);
      
      Opal.defn(self, '$normalize_encoding!', TMP_Font_normalize_encoding$B_20 = function(str) {
        var self = this;

        return str.$replace(self.$normalize_encoding(str))
      }, TMP_Font_normalize_encoding$B_20.$$arity = 1);
      
      Opal.defn(self, '$height_at', TMP_Font_height_at_21 = function $$height_at(size) {
        var $a, self = this;

        
        self.normalized_height = ($truthy($a = self.normalized_height) ? $a : $rb_divide($rb_plus($rb_minus(self.ascender, self.descender), self.line_gap), 1000.0));
        return $rb_times(self.normalized_height, size);
      }, TMP_Font_height_at_21.$$arity = 1);
      
      Opal.defn(self, '$height', TMP_Font_height_22 = function $$height() {
        var self = this;

        return self.$height_at(self.$size())
      }, TMP_Font_height_22.$$arity = 0);
      
      Opal.defn(self, '$add_to_current_page', TMP_Font_add_to_current_page_23 = function $$add_to_current_page(subset) {
        var $a, self = this, $writer = nil;

        
        ($truthy($a = self.references['$[]'](subset)) ? $a : (($writer = [subset, self.$register(subset)]), $send(self.references, '[]=', Opal.to_a($writer)), $writer[$rb_minus($writer["length"], 1)]));
        return self.document.$state().$page().$fonts()['$merge!']($hash(self.$identifier_for(subset), self.references['$[]'](subset)));
      }, TMP_Font_add_to_current_page_23.$$arity = 1);
      
      Opal.defn(self, '$identifier_for', TMP_Font_identifier_for_24 = function $$identifier_for(subset) {
        var self = this;

        return "" + (self.identifier) + "." + (subset)
      }, TMP_Font_identifier_for_24.$$arity = 1);
      
      Opal.defn(self, '$inspect', TMP_Font_inspect_25 = function $$inspect() {
        var self = this;

        return "" + (self.$class().$name()) + "< " + (self.$name()) + ": " + (self.$size()) + " >"
      }, TMP_Font_inspect_25.$$arity = 0);
      
      Opal.defn(self, '$hash', TMP_Font_hash_26 = function $$hash() {
        var self = this;

        return [self.$class(), self.$name(), self.$family(), self.$size()].$hash()
      }, TMP_Font_hash_26.$$arity = 0);
      
      Opal.defn(self, '$eql?', TMP_Font_eql$q_27 = function(other) {
        var $a, $b, $c, self = this;

        return ($truthy($a = ($truthy($b = (($c = self.$class()['$=='](other.$class())) ? self.$name()['$=='](other.$name()) : self.$class()['$=='](other.$class()))) ? self.$family()['$=='](other.$family()) : $b)) ? self.$size()['$=='](other.$send("size")) : $a)
      }, TMP_Font_eql$q_27.$$arity = 1);
      self.$private();
      
      Opal.defn(self, '$generate_unique_id', TMP_Font_generate_unique_id_29 = function $$generate_unique_id() {
        var TMP_28, self = this, key = nil, font_count = nil;

        
        key = nil;
        font_count = $rb_plus(self.document.$font_registry().$size(), 1);
        (function(){var $brk = Opal.new_brk(); try {return $send(self, 'loop', [], (TMP_28 = function(){var self = TMP_28.$$s || this;

        
          key = "" + "F" + (font_count);
          if ($truthy(self['$key_is_unique?'](key))) {
            
            Opal.brk(nil, $brk)};
          return (font_count = $rb_plus(font_count, 1));}, TMP_28.$$s = self, TMP_28.$$brk = $brk, TMP_28.$$arity = 0, TMP_28))
        } catch (err) { if (err === $brk) { return err.$v } else { throw err } }})();
        return key;
      }, TMP_Font_generate_unique_id_29.$$arity = 0);
      
      Opal.defn(self, '$key_is_unique?', TMP_Font_key_is_unique$q_31 = function(test_key) {
        var TMP_30, self = this;

        return $send(self.document.$state().$page().$fonts().$keys(), 'any?', [], (TMP_30 = function(key){var self = TMP_30.$$s || this;
if (key == null) key = nil;
        return key.$to_s()['$start_with?']("" + (test_key) + ".")}, TMP_30.$$s = self, TMP_30.$$arity = 1, TMP_30))['$!']()
      }, TMP_Font_key_is_unique$q_31.$$arity = 1);
      return (Opal.defn(self, '$size', TMP_Font_size_32 = function $$size() {
        var self = this;

        return self.document.$font_size()
      }, TMP_Font_size_32.$$arity = 0), nil) && 'size';
    })($nesting[0], null, $nesting);
  })($nesting[0], $nesting);
};

/* Generated by Opal 0.11.0 */
Opal.modules["prawn/measurements"] = function(Opal) {
  function $rb_times(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs * rhs : lhs['$*'](rhs);
  }
  function $rb_divide(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs / rhs : lhs['$/'](rhs);
  }
  var self = Opal.top, $nesting = [], nil = Opal.nil, $breaker = Opal.breaker, $slice = Opal.slice, $module = Opal.module;

  Opal.add_stubs(['$*', '$in2pt', '$ft2in', '$yd2in', '$/', '$mm2pt', '$cm2mm', '$dm2mm', '$m2mm']);
  return (function($base, $parent_nesting) {
    var $Prawn, self = $Prawn = $module($base, 'Prawn');

    var def = self.$$proto, $nesting = [self].concat($parent_nesting);

    (function($base, $parent_nesting) {
      var $Measurements, self = $Measurements = $module($base, 'Measurements');

      var def = self.$$proto, $nesting = [self].concat($parent_nesting), TMP_Measurements_cm2mm_1, TMP_Measurements_dm2mm_2, TMP_Measurements_m2mm_3, TMP_Measurements_ft2in_4, TMP_Measurements_yd2in_5, TMP_Measurements_pt2pt_6, TMP_Measurements_in2pt_7, TMP_Measurements_ft2pt_8, TMP_Measurements_yd2pt_9, TMP_Measurements_mm2pt_10, TMP_Measurements_cm2pt_11, TMP_Measurements_dm2pt_12, TMP_Measurements_m2pt_13, TMP_Measurements_pt2mm_14;

      
      
      Opal.defn(self, '$cm2mm', TMP_Measurements_cm2mm_1 = function $$cm2mm(cm) {
        var self = this;

        return $rb_times(cm, 10)
      }, TMP_Measurements_cm2mm_1.$$arity = 1);
      
      Opal.defn(self, '$dm2mm', TMP_Measurements_dm2mm_2 = function $$dm2mm(dm) {
        var self = this;

        return $rb_times(dm, 100)
      }, TMP_Measurements_dm2mm_2.$$arity = 1);
      
      Opal.defn(self, '$m2mm', TMP_Measurements_m2mm_3 = function $$m2mm(m) {
        var self = this;

        return $rb_times(m, 1000)
      }, TMP_Measurements_m2mm_3.$$arity = 1);
      
      Opal.defn(self, '$ft2in', TMP_Measurements_ft2in_4 = function $$ft2in(ft) {
        var self = this;

        return $rb_times(ft, 12)
      }, TMP_Measurements_ft2in_4.$$arity = 1);
      
      Opal.defn(self, '$yd2in', TMP_Measurements_yd2in_5 = function $$yd2in(yd) {
        var self = this;

        return $rb_times(yd, 36)
      }, TMP_Measurements_yd2in_5.$$arity = 1);
      
      Opal.defn(self, '$pt2pt', TMP_Measurements_pt2pt_6 = function $$pt2pt(pt) {
        var self = this;

        return pt
      }, TMP_Measurements_pt2pt_6.$$arity = 1);
      
      Opal.defn(self, '$in2pt', TMP_Measurements_in2pt_7 = function $$in2pt(inch) {
        var self = this;

        return $rb_times(inch, 72)
      }, TMP_Measurements_in2pt_7.$$arity = 1);
      
      Opal.defn(self, '$ft2pt', TMP_Measurements_ft2pt_8 = function $$ft2pt(ft) {
        var self = this;

        return self.$in2pt(self.$ft2in(ft))
      }, TMP_Measurements_ft2pt_8.$$arity = 1);
      
      Opal.defn(self, '$yd2pt', TMP_Measurements_yd2pt_9 = function $$yd2pt(yd) {
        var self = this;

        return self.$in2pt(self.$yd2in(yd))
      }, TMP_Measurements_yd2pt_9.$$arity = 1);
      
      Opal.defn(self, '$mm2pt', TMP_Measurements_mm2pt_10 = function $$mm2pt(mm) {
        var self = this;

        return $rb_times(mm, $rb_divide(72, 25.4))
      }, TMP_Measurements_mm2pt_10.$$arity = 1);
      
      Opal.defn(self, '$cm2pt', TMP_Measurements_cm2pt_11 = function $$cm2pt(cm) {
        var self = this;

        return self.$mm2pt(self.$cm2mm(cm))
      }, TMP_Measurements_cm2pt_11.$$arity = 1);
      
      Opal.defn(self, '$dm2pt', TMP_Measurements_dm2pt_12 = function $$dm2pt(dm) {
        var self = this;

        return self.$mm2pt(self.$dm2mm(dm))
      }, TMP_Measurements_dm2pt_12.$$arity = 1);
      
      Opal.defn(self, '$m2pt', TMP_Measurements_m2pt_13 = function $$m2pt(m) {
        var self = this;

        return self.$mm2pt(self.$m2mm(m))
      }, TMP_Measurements_m2pt_13.$$arity = 1);
      
      Opal.defn(self, '$pt2mm', TMP_Measurements_pt2mm_14 = function $$pt2mm(pt) {
        var self = this;

        return $rb_divide($rb_times(pt, 1), self.$mm2pt(1))
      }, TMP_Measurements_pt2mm_14.$$arity = 1);
    })($nesting[0], $nesting)
  })($nesting[0], $nesting)
};

/* Generated by Opal 0.11.0 */
Opal.modules["prawn/repeater"] = function(Opal) {
  function $rb_plus(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs + rhs : lhs['$+'](rhs);
  }
  function $rb_minus(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs - rhs : lhs['$-'](rhs);
  }
  var self = Opal.top, $nesting = [], nil = Opal.nil, $breaker = Opal.breaker, $slice = Opal.slice, $module = Opal.module, $klass = Opal.klass, $truthy = Opal.truthy, $send = Opal.send, $hash2 = Opal.hash2;

  Opal.add_stubs(['$<<', '$repeaters', '$new', '$!', '$[]', '$to_proc', '$attr_writer', '$attr_reader', '$count', '$create_stamp', '$dup', '$graphic_state', '$page', '$state', '$+', '$count=', '$-', '$page_match?', '$match?', '$stamp', '$save_graphics_state', '$send', '$call']);
  return (function($base, $parent_nesting) {
    var $Prawn, self = $Prawn = $module($base, 'Prawn');

    var def = self.$$proto, $nesting = [self].concat($parent_nesting);

    
    (function($base, $super, $parent_nesting) {
      function $Document(){};
      var self = $Document = $klass($base, $super, 'Document', $Document);

      var def = self.$$proto, $nesting = [self].concat($parent_nesting), TMP_Document_repeaters_1, TMP_Document_repeat_2;

      def.repeaters = nil;
      
      
      Opal.defn(self, '$repeaters', TMP_Document_repeaters_1 = function $$repeaters() {
        var $a, self = this;

        return (self.repeaters = ($truthy($a = self.repeaters) ? $a : []))
      }, TMP_Document_repeaters_1.$$arity = 0);
      return (Opal.defn(self, '$repeat', TMP_Document_repeat_2 = function $$repeat(page_filter, options) {
        var self = this, $iter = TMP_Document_repeat_2.$$p, block = $iter || nil;

        if (options == null) {
          options = $hash2([], {});
        }
        if ($iter) TMP_Document_repeat_2.$$p = null;
        return self.$repeaters()['$<<']($send(Opal.const_get_qualified(Opal.const_get_relative($nesting, 'Prawn'), 'Repeater'), 'new', [self, page_filter, options['$[]']("dynamic")['$!']()['$!']()], block.$to_proc()))
      }, TMP_Document_repeat_2.$$arity = -2), nil) && 'repeat';
    })($nesting[0], null, $nesting);
    (function($base, $super, $parent_nesting) {
      function $Repeater(){};
      var self = $Repeater = $klass($base, $super, 'Repeater', $Repeater);

      var def = self.$$proto, $nesting = [self].concat($parent_nesting), TMP_Repeater_initialize_4, TMP_Repeater_match$q_5, TMP_Repeater_run_7;

      def.document = def.stamp_name = def.page_filter = def.dynamic = def.block = def.graphic_state = nil;
      
      (function(self, $parent_nesting) {
        var def = self.$$proto, $nesting = [self].concat($parent_nesting), TMP_count_3;

        
        self.$attr_writer("count");
        return (Opal.defn(self, '$count', TMP_count_3 = function $$count() {
          var $a, self = this;
          if (self.count == null) self.count = nil;

          return (self.count = ($truthy($a = self.count) ? $a : 0))
        }, TMP_count_3.$$arity = 0), nil) && 'count';
      })(Opal.get_singleton_class(self), $nesting);
      self.$attr_reader("name");
      
      Opal.defn(self, '$initialize', TMP_Repeater_initialize_4 = function $$initialize(document, page_filter, dynamic) {
        var self = this, $iter = TMP_Repeater_initialize_4.$$p, block = $iter || nil, $writer = nil;

        if (dynamic == null) {
          dynamic = false;
        }
        if ($iter) TMP_Repeater_initialize_4.$$p = null;
        
        self.document = document;
        self.page_filter = page_filter;
        self.dynamic = dynamic;
        self.stamp_name = "" + "prawn_repeater(" + (Opal.const_get_relative($nesting, 'Repeater').$count()) + ")";
        if ($truthy(dynamic)) {
          } else {
          $send(self.document, 'create_stamp', [self.stamp_name], block.$to_proc())
        };
        if ($truthy(dynamic)) {
          self.block = block};
        self.graphic_state = document.$state().$page().$graphic_state().$dup();
        
        $writer = [$rb_plus(Opal.const_get_relative($nesting, 'Repeater').$count(), 1)];
        $send(Opal.const_get_relative($nesting, 'Repeater'), 'count=', Opal.to_a($writer));
        return $writer[$rb_minus($writer["length"], 1)];;
      }, TMP_Repeater_initialize_4.$$arity = -3);
      
      Opal.defn(self, '$match?', TMP_Repeater_match$q_5 = function(page_number) {
        var self = this;

        return self.document['$page_match?'](self.page_filter, page_number)
      }, TMP_Repeater_match$q_5.$$arity = 1);
      return (Opal.defn(self, '$run', TMP_Repeater_run_7 = function $$run(page_number) {
        var $a, TMP_6, self = this;

        if ($truthy(self.dynamic['$!']())) {
          if ($truthy(self['$match?'](page_number))) {
            return self.document.$stamp(self.stamp_name)
            } else {
            return nil
          }
        } else if ($truthy(($truthy($a = self.block) ? self['$match?'](page_number) : $a))) {
          return $send(self.document, 'save_graphics_state', [self.graphic_state], (TMP_6 = function(){var self = TMP_6.$$s || this;
            if (self.document == null) self.document = nil;
            if (self.block == null) self.block = nil;

          
            self.document.$send("freeze_stamp_graphics");
            return self.block.$call();}, TMP_6.$$s = self, TMP_6.$$arity = 0, TMP_6))
          } else {
          return nil
        }
      }, TMP_Repeater_run_7.$$arity = 1), nil) && 'run';
    })($nesting[0], null, $nesting);
  })($nesting[0], $nesting)
};

/* Generated by Opal 0.11.0 */
Opal.modules["prawn/outline"] = function(Opal) {
  function $rb_minus(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs - rhs : lhs['$-'](rhs);
  }
  function $rb_plus(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs + rhs : lhs['$+'](rhs);
  }
  var self = Opal.top, $nesting = [], nil = Opal.nil, $breaker = Opal.breaker, $slice = Opal.slice, $module = Opal.module, $klass = Opal.klass, $truthy = Opal.truthy, $hash2 = Opal.hash2, $send = Opal.send;

  Opal.add_stubs(['$new', '$attr_accessor', '$root', '$page_number', '$instance_eval', '$to_proc', '$[]', '$items', '$fail', '$==', '$last', '$data', '$first', '$insert_section', '$parent', '$next', '$add_outline_item', '$private', '$store', '$state', '$document', '$ref!', '$[]=', '$-', '$create_outline_item', '$set_relations', '$increase_count', '$set_variables_for_block', '$call', '$reset_parent', '$===', '$dictionary', '$pages', '$dest=', '$prev', '$prev=', '$next=', '$first=', '$last=', '$+', '$count', '$count=', '$parent=', '$adjust_relations', '$reset_root_positioning']);
  return (function($base, $parent_nesting) {
    var $Prawn, self = $Prawn = $module($base, 'Prawn');

    var def = self.$$proto, $nesting = [self].concat($parent_nesting);

    
    (function($base, $super, $parent_nesting) {
      function $Document(){};
      var self = $Document = $klass($base, $super, 'Document', $Document);

      var def = self.$$proto, $nesting = [self].concat($parent_nesting), TMP_Document_outline_1;

      def.outline = nil;
      return (Opal.defn(self, '$outline', TMP_Document_outline_1 = function $$outline() {
        var $a, self = this;

        return (self.outline = ($truthy($a = self.outline) ? $a : Opal.const_get_relative($nesting, 'Outline').$new(self)))
      }, TMP_Document_outline_1.$$arity = 0), nil) && 'outline'
    })($nesting[0], null, $nesting);
    (function($base, $super, $parent_nesting) {
      function $Outline(){};
      var self = $Outline = $klass($base, $super, 'Outline', $Outline);

      var def = self.$$proto, $nesting = [self].concat($parent_nesting), TMP_Outline_initialize_2, TMP_Outline_page_number_3, TMP_Outline_define_4, TMP_Outline_add_subsection_to_5, TMP_Outline_insert_section_after_6, TMP_Outline_section_7, TMP_Outline_page_8, TMP_Outline_root_9, TMP_Outline_add_outline_item_10, TMP_Outline_create_outline_item_11, TMP_Outline_set_relations_12, TMP_Outline_increase_count_13, TMP_Outline_set_variables_for_block_14, TMP_Outline_reset_parent_15, TMP_Outline_insert_section_16, TMP_Outline_adjust_relations_17, TMP_Outline_reset_root_positioning_18;

      def.document = def.parent = def.prev = nil;
      
      self.$attr_accessor("parent", "prev", "document", "items");
      
      Opal.defn(self, '$initialize', TMP_Outline_initialize_2 = function $$initialize(document) {
        var self = this;

        
        self.document = document;
        self.parent = self.$root();
        self.prev = nil;
        return (self.items = $hash2([], {}));
      }, TMP_Outline_initialize_2.$$arity = 1);
      
      Opal.defn(self, '$page_number', TMP_Outline_page_number_3 = function $$page_number() {
        var self = this;

        return self.document.$page_number()
      }, TMP_Outline_page_number_3.$$arity = 0);
      
      Opal.defn(self, '$define', TMP_Outline_define_4 = function $$define() {
        var self = this, $iter = TMP_Outline_define_4.$$p, block = $iter || nil;

        if ($iter) TMP_Outline_define_4.$$p = null;
        if ($truthy(block)) {
          return $send(self, 'instance_eval', [], block.$to_proc())
          } else {
          return nil
        }
      }, TMP_Outline_define_4.$$arity = 0);
      Opal.alias(self, "update", "define");
      
      Opal.defn(self, '$add_subsection_to', TMP_Outline_add_subsection_to_5 = function $$add_subsection_to(title, position) {
        var self = this, $iter = TMP_Outline_add_subsection_to_5.$$p, block = $iter || nil, nxt = nil;

        if (position == null) {
          position = "last";
        }
        if ($iter) TMP_Outline_add_subsection_to_5.$$p = null;
        
        self.parent = self.$items()['$[]'](title);
        if ($truthy(self.parent)) {
          } else {
          self.$fail(Opal.const_get_qualified(Opal.const_get_qualified(Opal.const_get_relative($nesting, 'Prawn'), 'Errors'), 'UnknownOutlineTitle'), "" + "\n No outline item with title: '" + (title) + "' exists in the outline tree")
        };
        self.prev = (function() {if (position['$==']("first")) {
          return nil
          } else {
          return self.parent.$data().$last()
        }; return nil; })();
        nxt = (function() {if (position['$==']("first")) {
          return self.parent.$data().$first()
          } else {
          return nil
        }; return nil; })();
        return $send(self, 'insert_section', [nxt], block.$to_proc());
      }, TMP_Outline_add_subsection_to_5.$$arity = -2);
      
      Opal.defn(self, '$insert_section_after', TMP_Outline_insert_section_after_6 = function $$insert_section_after(title) {
        var self = this, $iter = TMP_Outline_insert_section_after_6.$$p, block = $iter || nil, nxt = nil;

        if ($iter) TMP_Outline_insert_section_after_6.$$p = null;
        
        self.prev = self.$items()['$[]'](title);
        if ($truthy(self.prev)) {
          } else {
          self.$fail(Opal.const_get_qualified(Opal.const_get_qualified(Opal.const_get_relative($nesting, 'Prawn'), 'Errors'), 'UnknownOutlineTitle'), "" + "\n No outline item with title: '" + (title) + "' exists in the outline tree")
        };
        self.parent = self.prev.$data().$parent();
        nxt = self.prev.$data().$next();
        return $send(self, 'insert_section', [nxt], block.$to_proc());
      }, TMP_Outline_insert_section_after_6.$$arity = 1);
      
      Opal.defn(self, '$section', TMP_Outline_section_7 = function $$section(title, options) {
        var self = this, $iter = TMP_Outline_section_7.$$p, block = $iter || nil;

        if (options == null) {
          options = $hash2([], {});
        }
        if ($iter) TMP_Outline_section_7.$$p = null;
        return $send(self, 'add_outline_item', [title, options], block.$to_proc())
      }, TMP_Outline_section_7.$$arity = -2);
      
      Opal.defn(self, '$page', TMP_Outline_page_8 = function $$page(options) {
        var self = this, title = nil;

        if (options == null) {
          options = $hash2([], {});
        }
        
        if ($truthy(options['$[]']("title"))) {
          title = options['$[]']("title")
          } else {
          self.$fail(Opal.const_get_qualified(Opal.const_get_qualified(Opal.const_get_relative($nesting, 'Prawn'), 'Errors'), 'RequiredOption'), "\nTitle is a required option for page")
        };
        return self.$add_outline_item(title, options);
      }, TMP_Outline_page_8.$$arity = -1);
      self.$private();
      
      Opal.defn(self, '$root', TMP_Outline_root_9 = function $$root() {
        var $a, self = this, $logical_op_recvr_tmp_13 = nil, $writer = nil;

        
        $logical_op_recvr_tmp_13 = self.$document().$state().$store().$root().$data();
        return ($truthy($a = $logical_op_recvr_tmp_13['$[]']("Outlines")) ? $a : (($writer = ["Outlines", self.$document()['$ref!'](Opal.const_get_qualified(Opal.const_get_qualified(Opal.const_get_relative($nesting, 'PDF'), 'Core'), 'OutlineRoot').$new())]), $send($logical_op_recvr_tmp_13, '[]=', Opal.to_a($writer)), $writer[$rb_minus($writer["length"], 1)]));
      }, TMP_Outline_root_9.$$arity = 0);
      
      Opal.defn(self, '$add_outline_item', TMP_Outline_add_outline_item_10 = function $$add_outline_item(title, options) {
        var self = this, $iter = TMP_Outline_add_outline_item_10.$$p, block = $iter || nil, outline_item = nil;

        if ($iter) TMP_Outline_add_outline_item_10.$$p = null;
        
        outline_item = self.$create_outline_item(title, options);
        self.$set_relations(outline_item);
        self.$increase_count();
        self.$set_variables_for_block(outline_item, block);
        if ($truthy(block)) {
          block.$call()};
        return self.$reset_parent(outline_item);
      }, TMP_Outline_add_outline_item_10.$$arity = 2);
      
      Opal.defn(self, '$create_outline_item', TMP_Outline_create_outline_item_11 = function $$create_outline_item(title, options) {
        var self = this, outline_item = nil, $case = nil, page_index = nil, $writer = nil;

        
        outline_item = Opal.const_get_qualified(Opal.const_get_qualified(Opal.const_get_relative($nesting, 'PDF'), 'Core'), 'OutlineItem').$new(title, self.$parent(), options);
        $case = options['$[]']("destination");
        if (Opal.const_get_relative($nesting, 'Integer')['$===']($case)) {
        page_index = $rb_minus(options['$[]']("destination"), 1);
        
        $writer = [[self.$document().$state().$pages()['$[]'](page_index).$dictionary(), "Fit"]];
        $send(outline_item, 'dest=', Opal.to_a($writer));
        $writer[$rb_minus($writer["length"], 1)];;}
        else if (Opal.const_get_relative($nesting, 'Array')['$===']($case)) {
        $writer = [options['$[]']("destination")];
        $send(outline_item, 'dest=', Opal.to_a($writer));
        $writer[$rb_minus($writer["length"], 1)];};
        if ($truthy(self.prev)) {
          
          $writer = [self.$prev()];
          $send(outline_item, 'prev=', Opal.to_a($writer));
          $writer[$rb_minus($writer["length"], 1)];};
        
        $writer = [title, self.$document()['$ref!'](outline_item)];
        $send(self.$items(), '[]=', Opal.to_a($writer));
        return $writer[$rb_minus($writer["length"], 1)];;
      }, TMP_Outline_create_outline_item_11.$$arity = 2);
      
      Opal.defn(self, '$set_relations', TMP_Outline_set_relations_12 = function $$set_relations(outline_item) {
        var self = this, $writer = nil;

        
        if ($truthy(self.$prev())) {
          
          $writer = [outline_item];
          $send(self.$prev().$data(), 'next=', Opal.to_a($writer));
          $writer[$rb_minus($writer["length"], 1)];};
        if ($truthy(self.$prev())) {
          } else {
          
          $writer = [outline_item];
          $send(self.$parent().$data(), 'first=', Opal.to_a($writer));
          $writer[$rb_minus($writer["length"], 1)];
        };
        
        $writer = [outline_item];
        $send(self.$parent().$data(), 'last=', Opal.to_a($writer));
        return $writer[$rb_minus($writer["length"], 1)];;
      }, TMP_Outline_set_relations_12.$$arity = 1);
      
      Opal.defn(self, '$increase_count', TMP_Outline_increase_count_13 = function $$increase_count() {
        var $a, self = this, counting_parent = nil, $binary_op_recvr_tmp_3 = nil, $writer = nil;

        
        counting_parent = self.$parent();
        while ($truthy(counting_parent)) {
          
          
          $binary_op_recvr_tmp_3 = counting_parent.$data();
          
          $writer = [$rb_plus($binary_op_recvr_tmp_3.$count(), 1)];
          $send($binary_op_recvr_tmp_3, 'count=', Opal.to_a($writer));
          $writer[$rb_minus($writer["length"], 1)];;;
          if (counting_parent['$=='](self.$root())) {
            counting_parent = nil
            } else {
            counting_parent = counting_parent.$data().$parent()
          };
        };
      }, TMP_Outline_increase_count_13.$$arity = 0);
      
      Opal.defn(self, '$set_variables_for_block', TMP_Outline_set_variables_for_block_14 = function $$set_variables_for_block(outline_item, block) {
        var self = this, $writer = nil;

        
        
        $writer = [(function() {if ($truthy(block)) {
          return nil
          } else {
          return outline_item
        }; return nil; })()];
        $send(self, 'prev=', Opal.to_a($writer));
        $writer[$rb_minus($writer["length"], 1)];;
        if ($truthy(block)) {
          
          $writer = [outline_item];
          $send(self, 'parent=', Opal.to_a($writer));
          return $writer[$rb_minus($writer["length"], 1)];
          } else {
          return nil
        };
      }, TMP_Outline_set_variables_for_block_14.$$arity = 2);
      
      Opal.defn(self, '$reset_parent', TMP_Outline_reset_parent_15 = function $$reset_parent(outline_item) {
        var self = this, $writer = nil;

        if (self.$parent()['$=='](outline_item)) {
          
          
          $writer = [outline_item];
          $send(self, 'prev=', Opal.to_a($writer));
          $writer[$rb_minus($writer["length"], 1)];;
          
          $writer = [outline_item.$data().$parent()];
          $send(self, 'parent=', Opal.to_a($writer));
          return $writer[$rb_minus($writer["length"], 1)];;
          } else {
          return nil
        }
      }, TMP_Outline_reset_parent_15.$$arity = 1);
      
      Opal.defn(self, '$insert_section', TMP_Outline_insert_section_16 = function $$insert_section(nxt) {
        var self = this, $iter = TMP_Outline_insert_section_16.$$p, block = $iter || nil, last = nil;

        if ($iter) TMP_Outline_insert_section_16.$$p = null;
        
        last = self.parent.$data().$last();
        if ($truthy(block)) {
          block.$call()};
        self.$adjust_relations(nxt, last);
        return self.$reset_root_positioning();
      }, TMP_Outline_insert_section_16.$$arity = 1);
      
      Opal.defn(self, '$adjust_relations', TMP_Outline_adjust_relations_17 = function $$adjust_relations(nxt, last) {
        var self = this, $writer = nil;

        if ($truthy(nxt)) {
          
          
          $writer = [self.prev];
          $send(nxt.$data(), 'prev=', Opal.to_a($writer));
          $writer[$rb_minus($writer["length"], 1)];;
          
          $writer = [nxt];
          $send(self.prev.$data(), 'next=', Opal.to_a($writer));
          $writer[$rb_minus($writer["length"], 1)];;
          
          $writer = [last];
          $send(self.parent.$data(), 'last=', Opal.to_a($writer));
          return $writer[$rb_minus($writer["length"], 1)];;
          } else {
          return nil
        }
      }, TMP_Outline_adjust_relations_17.$$arity = 2);
      return (Opal.defn(self, '$reset_root_positioning', TMP_Outline_reset_root_positioning_18 = function $$reset_root_positioning() {
        var self = this;

        
        self.parent = self.$root();
        return (self.prev = self.$root().$data().$last());
      }, TMP_Outline_reset_root_positioning_18.$$arity = 0), nil) && 'reset_root_positioning';
    })($nesting[0], null, $nesting);
  })($nesting[0], $nesting)
};

/* Generated by Opal 0.11.0 */
Opal.modules["prawn/grid"] = function(Opal) {
  function $rb_minus(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs - rhs : lhs['$-'](rhs);
  }
  function $rb_divide(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs / rhs : lhs['$/'](rhs);
  }
  function $rb_times(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs * rhs : lhs['$*'](rhs);
  }
  function $rb_plus(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs + rhs : lhs['$+'](rhs);
  }
  var self = Opal.top, $nesting = [], nil = Opal.nil, $breaker = Opal.breaker, $slice = Opal.slice, $module = Opal.module, $klass = Opal.klass, $hash2 = Opal.hash2, $truthy = Opal.truthy, $send = Opal.send;

  Opal.add_stubs(['$new', '$[]', '$empty?', '$[]=', '$-', '$==', '$class', '$length', '$multi_box', '$single_box', '$attr_reader', '$verify_options', '$set_gutter', '$subdivide', '$width', '$bounds', '$pdf', '$columns', '$column_gutter', '$height', '$rows', '$row_gutter', '$times', '$show', '$grid', '$private', '$/', '$to_f', '$*', '$key?', '$to_s', '$column_width', '$row_height', '$gutter', '$+', '$left', '$total_height', '$top', '$right', '$bottom', '$bounding_box', '$top_left', '$to_proc', '$stroke_color', '$stroke_color=', '$text', '$name', '$stroke_bounds', '$join', '$map', '$right_box', '$left_box', '$top_box', '$bottom_box', '$min', '$<=>', '$max']);
  return (function($base, $parent_nesting) {
    var $Prawn, self = $Prawn = $module($base, 'Prawn');

    var def = self.$$proto, $nesting = [self].concat($parent_nesting);

    (function($base, $super, $parent_nesting) {
      function $Document(){};
      var self = $Document = $klass($base, $super, 'Document', $Document);

      var def = self.$$proto, $nesting = [self].concat($parent_nesting), TMP_Document_define_grid_1, TMP_Document_grid_2, TMP_Document_single_box_47, TMP_Document_multi_box_48;

      def.boxes = def.grid = nil;
      
      
      Opal.defn(self, '$define_grid', TMP_Document_define_grid_1 = function $$define_grid(options) {
        var self = this;

        if (options == null) {
          options = $hash2([], {});
        }
        
        self.boxes = nil;
        return (self.grid = Opal.const_get_relative($nesting, 'Grid').$new(self, options));
      }, TMP_Document_define_grid_1.$$arity = -1);
      
      Opal.defn(self, '$grid', TMP_Document_grid_2 = function $$grid($a_rest) {
        var $b, $c, $d, self = this, args, $writer = nil, g1 = nil, g2 = nil;

        var $args_len = arguments.length, $rest_len = $args_len - 0;
        if ($rest_len < 0) { $rest_len = 0; }
        args = new Array($rest_len);
        for (var $arg_idx = 0; $arg_idx < $args_len; $arg_idx++) {
          args[$arg_idx - 0] = arguments[$arg_idx];
        }
        
        self.boxes = ($truthy($b = self.boxes) ? $b : $hash2([], {}));
        if ($truthy(self.boxes['$[]'](args))) {
          return self.boxes['$[]'](args)};
        if ($truthy(args['$empty?']())) {
          
          $writer = [args, self.grid];
          $send(self.boxes, '[]=', Opal.to_a($writer));
          $writer[$rb_minus($writer["length"], 1)];
          } else {
          
          $c = args, $b = Opal.to_ary($c), (g1 = ($b[0] == null ? nil : $b[0])), (g2 = ($b[1] == null ? nil : $b[1])), $c;
          if ($truthy(($truthy($b = ($truthy($c = (($d = g1.$class()['$=='](Opal.const_get_relative($nesting, 'Array'))) ? g2.$class()['$=='](Opal.const_get_relative($nesting, 'Array')) : g1.$class()['$=='](Opal.const_get_relative($nesting, 'Array')))) ? g1.$length()['$=='](2) : $c)) ? g2.$length()['$=='](2) : $b))) {
            
            $writer = [args, self.$multi_box($send(self, 'single_box', Opal.to_a(g1)), $send(self, 'single_box', Opal.to_a(g2)))];
            $send(self.boxes, '[]=', Opal.to_a($writer));
            $writer[$rb_minus($writer["length"], 1)];
            } else {
            
            $writer = [args, self.$single_box(g1, g2)];
            $send(self.boxes, '[]=', Opal.to_a($writer));
            $writer[$rb_minus($writer["length"], 1)];
          };
        };
        return self.boxes['$[]'](args);
      }, TMP_Document_grid_2.$$arity = -1);
      (function($base, $super, $parent_nesting) {
        function $Grid(){};
        var self = $Grid = $klass($base, $super, 'Grid', $Grid);

        var def = self.$$proto, $nesting = [self].concat($parent_nesting), TMP_Grid_initialize_3, TMP_Grid_column_width_4, TMP_Grid_row_height_5, TMP_Grid_show_all_8, TMP_Grid_subdivide_9, TMP_Grid_set_gutter_10;

        def.column_width = def.row_height = def.gutter = nil;
        
        self.$attr_reader("pdf", "columns", "rows", "gutter", "row_gutter", "column_gutter");
        
        Opal.defn(self, '$initialize', TMP_Grid_initialize_3 = function $$initialize(pdf, options) {
          var self = this, valid_options = nil;

          if (options == null) {
            options = $hash2([], {});
          }
          
          valid_options = ["columns", "rows", "gutter", "row_gutter", "column_gutter"];
          Opal.const_get_relative($nesting, 'Prawn').$verify_options(valid_options, options);
          self.pdf = pdf;
          self.columns = options['$[]']("columns");
          self.rows = options['$[]']("rows");
          return self.$set_gutter(options);
        }, TMP_Grid_initialize_3.$$arity = -2);
        
        Opal.defn(self, '$column_width', TMP_Grid_column_width_4 = function $$column_width() {
          var $a, self = this;

          return (self.column_width = ($truthy($a = self.column_width) ? $a : self.$subdivide(self.$pdf().$bounds().$width(), self.$columns(), self.$column_gutter())))
        }, TMP_Grid_column_width_4.$$arity = 0);
        
        Opal.defn(self, '$row_height', TMP_Grid_row_height_5 = function $$row_height() {
          var $a, self = this;

          return (self.row_height = ($truthy($a = self.row_height) ? $a : self.$subdivide(self.$pdf().$bounds().$height(), self.$rows(), self.$row_gutter())))
        }, TMP_Grid_row_height_5.$$arity = 0);
        
        Opal.defn(self, '$show_all', TMP_Grid_show_all_8 = function $$show_all(color) {
          var TMP_6, self = this;

          if (color == null) {
            color = "CCCCCC";
          }
          return $send(self.$rows(), 'times', [], (TMP_6 = function(i){var self = TMP_6.$$s || this, TMP_7;
if (i == null) i = nil;
          return $send(self.$columns(), 'times', [], (TMP_7 = function(j){var self = TMP_7.$$s || this;
if (j == null) j = nil;
            return self.$pdf().$grid(i, j).$show(color)}, TMP_7.$$s = self, TMP_7.$$arity = 1, TMP_7))}, TMP_6.$$s = self, TMP_6.$$arity = 1, TMP_6))
        }, TMP_Grid_show_all_8.$$arity = -1);
        self.$private();
        
        Opal.defn(self, '$subdivide', TMP_Grid_subdivide_9 = function $$subdivide(total, num, gutter) {
          var self = this;

          return $rb_divide($rb_minus(total.$to_f(), $rb_times(gutter, $rb_minus(num, 1).$to_f())), num.$to_f())
        }, TMP_Grid_subdivide_9.$$arity = 3);
        return (Opal.defn(self, '$set_gutter', TMP_Grid_set_gutter_10 = function $$set_gutter(options) {
          var $a, self = this;

          if ($truthy(options['$key?']("gutter"))) {
            
            self.gutter = options['$[]']("gutter").$to_f();
            return $a = [self.gutter, self.gutter], (self.row_gutter = $a[0]), (self.column_gutter = $a[1]), $a;
            } else {
            
            self.row_gutter = options['$[]']("row_gutter").$to_f();
            self.column_gutter = options['$[]']("column_gutter").$to_f();
            return (self.gutter = 0);
          }
        }, TMP_Grid_set_gutter_10.$$arity = 1), nil) && 'set_gutter';
      })($nesting[0], null, $nesting);
      (function($base, $super, $parent_nesting) {
        function $GridBox(){};
        var self = $GridBox = $klass($base, $super, 'GridBox', $GridBox);

        var def = self.$$proto, $nesting = [self].concat($parent_nesting), TMP_GridBox_initialize_11, TMP_GridBox_name_12, TMP_GridBox_total_height_13, TMP_GridBox_width_14, TMP_GridBox_height_15, TMP_GridBox_gutter_16, TMP_GridBox_left_17, TMP_GridBox_right_18, TMP_GridBox_top_19, TMP_GridBox_bottom_20, TMP_GridBox_top_left_21, TMP_GridBox_top_right_22, TMP_GridBox_bottom_left_23, TMP_GridBox_bottom_right_24, TMP_GridBox_bounding_box_25, TMP_GridBox_show_27, TMP_GridBox_grid_28;

        def.i = def.j = def.left = def.right = def.top = def.bottom = nil;
        
        self.$attr_reader("pdf");
        
        Opal.defn(self, '$initialize', TMP_GridBox_initialize_11 = function $$initialize(pdf, i, j) {
          var self = this;

          
          self.pdf = pdf;
          self.i = i;
          return (self.j = j);
        }, TMP_GridBox_initialize_11.$$arity = 3);
        
        Opal.defn(self, '$name', TMP_GridBox_name_12 = function $$name() {
          var self = this;

          return "" + (self.i.$to_s()) + "," + (self.j.$to_s())
        }, TMP_GridBox_name_12.$$arity = 0);
        
        Opal.defn(self, '$total_height', TMP_GridBox_total_height_13 = function $$total_height() {
          var self = this;

          return self.$pdf().$bounds().$height().$to_f()
        }, TMP_GridBox_total_height_13.$$arity = 0);
        
        Opal.defn(self, '$width', TMP_GridBox_width_14 = function $$width() {
          var self = this;

          return self.$grid().$column_width().$to_f()
        }, TMP_GridBox_width_14.$$arity = 0);
        
        Opal.defn(self, '$height', TMP_GridBox_height_15 = function $$height() {
          var self = this;

          return self.$grid().$row_height().$to_f()
        }, TMP_GridBox_height_15.$$arity = 0);
        
        Opal.defn(self, '$gutter', TMP_GridBox_gutter_16 = function $$gutter() {
          var self = this;

          return self.$grid().$gutter().$to_f()
        }, TMP_GridBox_gutter_16.$$arity = 0);
        
        Opal.defn(self, '$left', TMP_GridBox_left_17 = function $$left() {
          var $a, self = this;

          return (self.left = ($truthy($a = self.left) ? $a : $rb_times($rb_plus(self.$width(), self.$grid().$column_gutter()), self.j.$to_f())))
        }, TMP_GridBox_left_17.$$arity = 0);
        
        Opal.defn(self, '$right', TMP_GridBox_right_18 = function $$right() {
          var $a, self = this;

          return (self.right = ($truthy($a = self.right) ? $a : $rb_plus(self.$left(), self.$width())))
        }, TMP_GridBox_right_18.$$arity = 0);
        
        Opal.defn(self, '$top', TMP_GridBox_top_19 = function $$top() {
          var $a, self = this;

          return (self.top = ($truthy($a = self.top) ? $a : $rb_minus(self.$total_height(), $rb_times($rb_plus(self.$height(), self.$grid().$row_gutter()), self.i.$to_f()))))
        }, TMP_GridBox_top_19.$$arity = 0);
        
        Opal.defn(self, '$bottom', TMP_GridBox_bottom_20 = function $$bottom() {
          var $a, self = this;

          return (self.bottom = ($truthy($a = self.bottom) ? $a : $rb_minus(self.$top(), self.$height())))
        }, TMP_GridBox_bottom_20.$$arity = 0);
        
        Opal.defn(self, '$top_left', TMP_GridBox_top_left_21 = function $$top_left() {
          var self = this;

          return [self.$left(), self.$top()]
        }, TMP_GridBox_top_left_21.$$arity = 0);
        
        Opal.defn(self, '$top_right', TMP_GridBox_top_right_22 = function $$top_right() {
          var self = this;

          return [self.$right(), self.$top()]
        }, TMP_GridBox_top_right_22.$$arity = 0);
        
        Opal.defn(self, '$bottom_left', TMP_GridBox_bottom_left_23 = function $$bottom_left() {
          var self = this;

          return [self.$left(), self.$bottom()]
        }, TMP_GridBox_bottom_left_23.$$arity = 0);
        
        Opal.defn(self, '$bottom_right', TMP_GridBox_bottom_right_24 = function $$bottom_right() {
          var self = this;

          return [self.$right(), self.$bottom()]
        }, TMP_GridBox_bottom_right_24.$$arity = 0);
        
        Opal.defn(self, '$bounding_box', TMP_GridBox_bounding_box_25 = function $$bounding_box() {
          var self = this, $iter = TMP_GridBox_bounding_box_25.$$p, blk = $iter || nil;

          if ($iter) TMP_GridBox_bounding_box_25.$$p = null;
          return $send(self.$pdf(), 'bounding_box', [self.$top_left(), $hash2(["width", "height"], {"width": self.$width(), "height": self.$height()})], blk.$to_proc())
        }, TMP_GridBox_bounding_box_25.$$arity = 0);
        
        Opal.defn(self, '$show', TMP_GridBox_show_27 = function $$show(grid_color) {
          var TMP_26, self = this;

          if (grid_color == null) {
            grid_color = "CCCCCC";
          }
          return $send(self, 'bounding_box', [], (TMP_26 = function(){var self = TMP_26.$$s || this, original_stroke_color = nil, $writer = nil;

          
            original_stroke_color = self.$pdf().$stroke_color();
            
            $writer = [grid_color];
            $send(self.$pdf(), 'stroke_color=', Opal.to_a($writer));
            $writer[$rb_minus($writer["length"], 1)];;
            self.$pdf().$text(self.$name());
            self.$pdf().$stroke_bounds();
            
            $writer = [original_stroke_color];
            $send(self.$pdf(), 'stroke_color=', Opal.to_a($writer));
            return $writer[$rb_minus($writer["length"], 1)];;}, TMP_26.$$s = self, TMP_26.$$arity = 0, TMP_26))
        }, TMP_GridBox_show_27.$$arity = -1);
        self.$private();
        return (Opal.defn(self, '$grid', TMP_GridBox_grid_28 = function $$grid() {
          var self = this;

          return self.$pdf().$grid()
        }, TMP_GridBox_grid_28.$$arity = 0), nil) && 'grid';
      })($nesting[0], null, $nesting);
      (function($base, $super, $parent_nesting) {
        function $MultiBox(){};
        var self = $MultiBox = $klass($base, $super, 'MultiBox', $MultiBox);

        var def = self.$$proto, $nesting = [self].concat($parent_nesting), TMP_MultiBox_initialize_29, TMP_MultiBox_name_30, TMP_MultiBox_total_height_31, TMP_MultiBox_width_32, TMP_MultiBox_height_33, TMP_MultiBox_gutter_34, TMP_MultiBox_left_35, TMP_MultiBox_right_36, TMP_MultiBox_top_37, TMP_MultiBox_bottom_38, TMP_MultiBox_left_box_40, TMP_MultiBox_right_box_42, TMP_MultiBox_top_box_44, TMP_MultiBox_bottom_box_46;

        def.bs = def.left_box = def.right_box = def.top_box = def.bottom_box = nil;
        
        
        Opal.defn(self, '$initialize', TMP_MultiBox_initialize_29 = function $$initialize(pdf, b1, b2) {
          var self = this;

          
          self.pdf = pdf;
          return (self.bs = [b1, b2]);
        }, TMP_MultiBox_initialize_29.$$arity = 3);
        
        Opal.defn(self, '$name', TMP_MultiBox_name_30 = function $$name() {
          var self = this;

          return $send(self.bs, 'map', [], "name".$to_proc()).$join(":")
        }, TMP_MultiBox_name_30.$$arity = 0);
        
        Opal.defn(self, '$total_height', TMP_MultiBox_total_height_31 = function $$total_height() {
          var self = this;

          return self.bs['$[]'](0).$total_height()
        }, TMP_MultiBox_total_height_31.$$arity = 0);
        
        Opal.defn(self, '$width', TMP_MultiBox_width_32 = function $$width() {
          var self = this;

          return $rb_minus(self.$right_box().$right(), self.$left_box().$left())
        }, TMP_MultiBox_width_32.$$arity = 0);
        
        Opal.defn(self, '$height', TMP_MultiBox_height_33 = function $$height() {
          var self = this;

          return $rb_minus(self.$top_box().$top(), self.$bottom_box().$bottom())
        }, TMP_MultiBox_height_33.$$arity = 0);
        
        Opal.defn(self, '$gutter', TMP_MultiBox_gutter_34 = function $$gutter() {
          var self = this;

          return self.bs['$[]'](0).$gutter()
        }, TMP_MultiBox_gutter_34.$$arity = 0);
        
        Opal.defn(self, '$left', TMP_MultiBox_left_35 = function $$left() {
          var self = this;

          return self.$left_box().$left()
        }, TMP_MultiBox_left_35.$$arity = 0);
        
        Opal.defn(self, '$right', TMP_MultiBox_right_36 = function $$right() {
          var self = this;

          return self.$right_box().$right()
        }, TMP_MultiBox_right_36.$$arity = 0);
        
        Opal.defn(self, '$top', TMP_MultiBox_top_37 = function $$top() {
          var self = this;

          return self.$top_box().$top()
        }, TMP_MultiBox_top_37.$$arity = 0);
        
        Opal.defn(self, '$bottom', TMP_MultiBox_bottom_38 = function $$bottom() {
          var self = this;

          return self.$bottom_box().$bottom()
        }, TMP_MultiBox_bottom_38.$$arity = 0);
        self.$private();
        
        Opal.defn(self, '$left_box', TMP_MultiBox_left_box_40 = function $$left_box() {
          var $a, TMP_39, self = this;

          return (self.left_box = ($truthy($a = self.left_box) ? $a : $send(self.bs, 'min', [], (TMP_39 = function(a, b){var self = TMP_39.$$s || this;
if (a == null) a = nil;if (b == null) b = nil;
          return a.$left()['$<=>'](b.$left())}, TMP_39.$$s = self, TMP_39.$$arity = 2, TMP_39))))
        }, TMP_MultiBox_left_box_40.$$arity = 0);
        
        Opal.defn(self, '$right_box', TMP_MultiBox_right_box_42 = function $$right_box() {
          var $a, TMP_41, self = this;

          return (self.right_box = ($truthy($a = self.right_box) ? $a : $send(self.bs, 'max', [], (TMP_41 = function(a, b){var self = TMP_41.$$s || this;
if (a == null) a = nil;if (b == null) b = nil;
          return a.$right()['$<=>'](b.$right())}, TMP_41.$$s = self, TMP_41.$$arity = 2, TMP_41))))
        }, TMP_MultiBox_right_box_42.$$arity = 0);
        
        Opal.defn(self, '$top_box', TMP_MultiBox_top_box_44 = function $$top_box() {
          var $a, TMP_43, self = this;

          return (self.top_box = ($truthy($a = self.top_box) ? $a : $send(self.bs, 'max', [], (TMP_43 = function(a, b){var self = TMP_43.$$s || this;
if (a == null) a = nil;if (b == null) b = nil;
          return a.$top()['$<=>'](b.$top())}, TMP_43.$$s = self, TMP_43.$$arity = 2, TMP_43))))
        }, TMP_MultiBox_top_box_44.$$arity = 0);
        return (Opal.defn(self, '$bottom_box', TMP_MultiBox_bottom_box_46 = function $$bottom_box() {
          var $a, TMP_45, self = this;

          return (self.bottom_box = ($truthy($a = self.bottom_box) ? $a : $send(self.bs, 'min', [], (TMP_45 = function(a, b){var self = TMP_45.$$s || this;
if (a == null) a = nil;if (b == null) b = nil;
          return a.$bottom()['$<=>'](b.$bottom())}, TMP_45.$$s = self, TMP_45.$$arity = 2, TMP_45))))
        }, TMP_MultiBox_bottom_box_46.$$arity = 0), nil) && 'bottom_box';
      })($nesting[0], Opal.const_get_relative($nesting, 'GridBox'), $nesting);
      self.$private();
      
      Opal.defn(self, '$single_box', TMP_Document_single_box_47 = function $$single_box(i, j) {
        var self = this;

        return Opal.const_get_relative($nesting, 'GridBox').$new(self, i, j)
      }, TMP_Document_single_box_47.$$arity = 2);
      return (Opal.defn(self, '$multi_box', TMP_Document_multi_box_48 = function $$multi_box(b1, b2) {
        var self = this;

        return Opal.const_get_relative($nesting, 'MultiBox').$new(self, b1, b2)
      }, TMP_Document_multi_box_48.$$arity = 2), nil) && 'multi_box';
    })($nesting[0], null, $nesting)
  })($nesting[0], $nesting)
};

/* Generated by Opal 0.11.0 */
Opal.modules["prawn/view"] = function(Opal) {
  var self = Opal.top, $nesting = [], nil = Opal.nil, $breaker = Opal.breaker, $slice = Opal.slice, $module = Opal.module, $truthy = Opal.truthy, $send = Opal.send;

  Opal.add_stubs(['$new', '$respond_to?', '$document', '$send', '$to_proc', '$instance_eval', '$render_file']);
  return (function($base, $parent_nesting) {
    var $Prawn, self = $Prawn = $module($base, 'Prawn');

    var def = self.$$proto, $nesting = [self].concat($parent_nesting);

    (function($base, $parent_nesting) {
      var $View, self = $View = $module($base, 'View');

      var def = self.$$proto, $nesting = [self].concat($parent_nesting), TMP_View_document_1, TMP_View_method_missing_2, TMP_View_update_3, TMP_View_save_as_4;

      
      
      Opal.defn(self, '$document', TMP_View_document_1 = function $$document() {
        var $a, self = this;
        if (self.document == null) self.document = nil;

        return (self.document = ($truthy($a = self.document) ? $a : Opal.const_get_qualified(Opal.const_get_relative($nesting, 'Prawn'), 'Document').$new()))
      }, TMP_View_document_1.$$arity = 0);
      
      Opal.defn(self, '$method_missing', TMP_View_method_missing_2 = function $$method_missing(m, $a_rest) {
        var self = this, a, $iter = TMP_View_method_missing_2.$$p, b = $iter || nil, $zuper = nil, $zuper_i = nil, $zuper_ii = nil;

        var $args_len = arguments.length, $rest_len = $args_len - 1;
        if ($rest_len < 0) { $rest_len = 0; }
        a = new Array($rest_len);
        for (var $arg_idx = 1; $arg_idx < $args_len; $arg_idx++) {
          a[$arg_idx - 1] = arguments[$arg_idx];
        }
        if ($iter) TMP_View_method_missing_2.$$p = null;
        // Prepare super implicit arguments
        for($zuper_i = 0, $zuper_ii = arguments.length, $zuper = new Array($zuper_ii); $zuper_i < $zuper_ii; $zuper_i++) {
          $zuper[$zuper_i] = arguments[$zuper_i];
        }
        
        if ($truthy(self.$document()['$respond_to?'](m))) {
          } else {
          return $send(self, Opal.find_super_dispatcher(self, 'method_missing', TMP_View_method_missing_2, false), $zuper, $iter)
        };
        return $send(self.$document(), 'send', [m].concat(Opal.to_a(a)), b.$to_proc());
      }, TMP_View_method_missing_2.$$arity = -2);
      
      Opal.defn(self, '$update', TMP_View_update_3 = function $$update() {
        var self = this, $iter = TMP_View_update_3.$$p, b = $iter || nil;

        if ($iter) TMP_View_update_3.$$p = null;
        return $send(self, 'instance_eval', [], b.$to_proc())
      }, TMP_View_update_3.$$arity = 0);
      
      Opal.defn(self, '$save_as', TMP_View_save_as_4 = function $$save_as(filename) {
        var self = this;

        return self.$document().$render_file(filename)
      }, TMP_View_save_as_4.$$arity = 1);
    })($nesting[0], $nesting)
  })($nesting[0], $nesting)
};

/* Generated by Opal 0.11.0 */
Opal.modules["prawn/image_handler"] = function(Opal) {
  var self = Opal.top, $nesting = [], nil = Opal.nil, $breaker = Opal.breaker, $slice = Opal.slice, $module = Opal.module, $truthy = Opal.truthy, $klass = Opal.klass, $send = Opal.send;

  Opal.add_stubs(['$new', '$delete', '$push', '$unshift', '$reject!', '$==', '$find', '$can_render?', '$fail']);
  return (function($base, $parent_nesting) {
    var $Prawn, self = $Prawn = $module($base, 'Prawn');

    var def = self.$$proto, $nesting = [self].concat($parent_nesting), TMP_Prawn_image_handler_1;

    
    Opal.defs(self, '$image_handler', TMP_Prawn_image_handler_1 = function $$image_handler() {
      var $a, self = this;
      if (self.image_handler == null) self.image_handler = nil;

      return (self.image_handler = ($truthy($a = self.image_handler) ? $a : Opal.const_get_relative($nesting, 'ImageHandler').$new()))
    }, TMP_Prawn_image_handler_1.$$arity = 0);
    (function($base, $super, $parent_nesting) {
      function $ImageHandler(){};
      var self = $ImageHandler = $klass($base, $super, 'ImageHandler', $ImageHandler);

      var def = self.$$proto, $nesting = [self].concat($parent_nesting), TMP_ImageHandler_initialize_2, TMP_ImageHandler_register_3, TMP_ImageHandler_register$B_4, TMP_ImageHandler_unregister_6, TMP_ImageHandler_find_8;

      def.handlers = nil;
      
      
      Opal.defn(self, '$initialize', TMP_ImageHandler_initialize_2 = function $$initialize() {
        var self = this;

        return (self.handlers = [])
      }, TMP_ImageHandler_initialize_2.$$arity = 0);
      
      Opal.defn(self, '$register', TMP_ImageHandler_register_3 = function $$register(handler) {
        var self = this;

        
        self.handlers.$delete(handler);
        return self.handlers.$push(handler);
      }, TMP_ImageHandler_register_3.$$arity = 1);
      
      Opal.defn(self, '$register!', TMP_ImageHandler_register$B_4 = function(handler) {
        var self = this;

        
        self.handlers.$delete(handler);
        return self.handlers.$unshift(handler);
      }, TMP_ImageHandler_register$B_4.$$arity = 1);
      
      Opal.defn(self, '$unregister', TMP_ImageHandler_unregister_6 = function $$unregister(handler) {
        var TMP_5, self = this;

        return $send(self.handlers, 'reject!', [], (TMP_5 = function(h){var self = TMP_5.$$s || this;
if (h == null) h = nil;
        return h['$=='](handler)}, TMP_5.$$s = self, TMP_5.$$arity = 1, TMP_5))
      }, TMP_ImageHandler_unregister_6.$$arity = 1);
      return (Opal.defn(self, '$find', TMP_ImageHandler_find_8 = function $$find(image_blob) {
        var TMP_7, self = this, handler = nil;

        
        handler = $send(self.handlers, 'find', [], (TMP_7 = function(h){var self = TMP_7.$$s || this;
if (h == null) h = nil;
        return h['$can_render?'](image_blob)}, TMP_7.$$s = self, TMP_7.$$arity = 1, TMP_7));
        if ($truthy(handler)) {
          return handler};
        return self.$fail(Opal.const_get_qualified(Opal.const_get_qualified(Opal.const_get_relative($nesting, 'Prawn'), 'Errors'), 'UnsupportedImageType'), "image file is an unrecognised format");
      }, TMP_ImageHandler_find_8.$$arity = 1), nil) && 'find';
    })($nesting[0], null, $nesting);
  })($nesting[0], $nesting)
};

/* Generated by Opal 0.11.0 */
Opal.modules["praw/js"] = function(Opal) {
  var self = Opal.top, $nesting = [], nil = Opal.nil, $breaker = Opal.breaker, $slice = Opal.slice;

  Opal.add_stubs(['$raise']);
  return self.$raise(Opal.const_get_relative($nesting, 'LoadError'), "can't find file: \"praw/js\" in:\n- /home/guillaume/.rvm/gems/ruby-2.4.1@prawn.js/gems/opal-0.11.0/opal\n- /home/guillaume/.rvm/gems/ruby-2.4.1@prawn.js/gems/opal-0.11.0/stdlib\n- /home/guillaume/.rvm/gems/ruby-2.4.1@prawn.js/gems/opal-0.11.0/lib\n- /home/guillaume/.rvm/gems/ruby-2.4.1@prawn.js/gems/ast-2.3.0/lib\n- /home/guillaume/.rvm/gems/ruby-2.4.1@prawn.js/gems/ast-2.3.0/lib\n- /home/guillaume/.rvm/gems/ruby-2.4.1@prawn.js/gems/parser-2.3.3.1/lib\n- /home/guillaume/workspace/opensource/prawn.js/lib\n- /home/guillaume/workspace/opensource/prawn.js/lib/prawn\n- /home/guillaume/workspace/opensource/prawn.js/build/prawn/lib\n- /home/guillaume/workspace/opensource/prawn.js/build/ttfunk/lib\n- /home/guillaume/workspace/opensource/prawn.js/build/pdf-core/lib\n\nWith the following extensions:\n- .js\n- .js.js\n- .rb\n- .js.rb\n- .opal\n- .js.opal\n- .opalerb\n- .js.opalerb\n- .erb\n- .js.erb\n\nAnd the following processors:\n- Opal::BuilderProcessors::JsProcessor\n- Opal::BuilderProcessors::RubyProcessor\n- Opal::BuilderProcessors::OpalERBProcessor\n- Opal::BuilderProcessors::ERBProcessor\n")
};

/* Generated by Opal 0.11.0 */
(function(Opal) {
  function $rb_minus(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs - rhs : lhs['$-'](rhs);
  }
  function $rb_gt(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs > rhs : lhs['$>'](rhs);
  }
  var self = Opal.top, $nesting = [], nil = Opal.nil, $breaker = Opal.breaker, $slice = Opal.slice, $module = Opal.module, $truthy = Opal.truthy, $gvars = Opal.gvars, $send = Opal.send;

  Opal.add_stubs(['$require', '$extend', '$expand_path', '$attr_accessor', '$debug', '$subset?', '$[]', '$keys', '$fail', '$inspect', '$to_a', '$-', '$load', '$dump', '$default_configuration', '$===', '$update', '$>', '$length', '$values_at', '$==', '$alias_method', '$register', '$image_handler']);
  
  self.$require("set");
  self.$require("ttfunk");
  self.$require("pdf/core");
  (function($base, $parent_nesting) {
    var $Prawn, self = $Prawn = $module($base, 'Prawn');

    var def = self.$$proto, $nesting = [self].concat($parent_nesting), TMP_Prawn_verify_options_1;

    
    self.$extend(self);
    Opal.const_set($nesting[0], 'BASEDIR', Opal.const_get_relative($nesting, 'File').$expand_path("."));
    Opal.const_set($nesting[0], 'DATADIR', Opal.const_get_relative($nesting, 'File').$expand_path("./data"));
    Opal.const_set($nesting[0], 'FLOAT_PRECISION', 1.0e-09);
    self.$attr_accessor("debug");
    
    Opal.defn(self, '$verify_options', TMP_Prawn_verify_options_1 = function $$verify_options(accepted, actual) {
      var $a, self = this, $iter = TMP_Prawn_verify_options_1.$$p, $yield = $iter || nil, act = nil, acc = nil;
      if ($gvars.DEBUG == null) $gvars.DEBUG = nil;

      if ($iter) TMP_Prawn_verify_options_1.$$p = null;
      
      if ($truthy(($truthy($a = self.$debug()) ? $a : $gvars.DEBUG))) {
        } else {
        return nil
      };
      if ($truthy((act = $send(Opal.const_get_relative($nesting, 'Set'), '[]', Opal.to_a(actual.$keys())))['$subset?']((acc = $send(Opal.const_get_relative($nesting, 'Set'), '[]', Opal.to_a(accepted)))))) {
        } else {
        self.$fail(Opal.const_get_qualified(Opal.const_get_qualified(Opal.const_get_relative($nesting, 'Prawn'), 'Errors'), 'UnknownOption'), "" + ("" + "\nDetected unknown option(s): " + ($rb_minus(act, acc).$to_a().$inspect()) + "\n") + ("" + "Accepted options are: " + (accepted.$inspect())))
      };
      if (($yield !== nil)) {
        return Opal.yieldX($yield, []);
        } else {
        return nil
      };
    }, TMP_Prawn_verify_options_1.$$arity = 2);
    (function($base, $parent_nesting) {
      var $Configurable, self = $Configurable = $module($base, 'Configurable');

      var def = self.$$proto, $nesting = [self].concat($parent_nesting), TMP_Configurable_configuration_2;

      
      
      Opal.defn(self, '$configuration', TMP_Configurable_configuration_2 = function $$configuration($a_rest) {
        var $b, self = this, args;
        if (self.config == null) self.config = nil;

        var $args_len = arguments.length, $rest_len = $args_len - 0;
        if ($rest_len < 0) { $rest_len = 0; }
        args = new Array($rest_len);
        for (var $arg_idx = 0; $arg_idx < $args_len; $arg_idx++) {
          args[$arg_idx - 0] = arguments[$arg_idx];
        }
        
        self.config = ($truthy($b = self.config) ? $b : Opal.const_get_relative($nesting, 'Marshal').$load(Opal.const_get_relative($nesting, 'Marshal').$dump(self.$default_configuration())));
        if ($truthy(Opal.const_get_relative($nesting, 'Hash')['$==='](args['$[]'](0)))) {
          return self.config.$update(args['$[]'](0))
        } else if ($truthy($rb_gt(args.$length(), 1))) {
          return $send(self.config, 'values_at', Opal.to_a(args))
        } else if (args.$length()['$=='](1)) {
          return self.config['$[]'](args['$[]'](0))
          } else {
          return self.config
        };
      }, TMP_Configurable_configuration_2.$$arity = -1);
      self.$alias_method("C", "configuration");
    })($nesting[0], $nesting);
  })($nesting[0], $nesting);
  self.$require("prawn"+ '/../' + "prawn/version");
  self.$require("prawn"+ '/../' + "prawn/errors");
  self.$require("prawn"+ '/../' + "prawn/utilities");
  self.$require("prawn"+ '/../' + "prawn/text");
  self.$require("prawn"+ '/../' + "prawn/graphics");
  self.$require("prawn"+ '/../' + "prawn/images");
  self.$require("prawn"+ '/../' + "prawn/images/image");
  self.$require("prawn"+ '/../' + "prawn/images/jpg");
  self.$require("prawn"+ '/../' + "prawn/images/png");
  self.$require("prawn"+ '/../' + "prawn/stamp");
  self.$require("prawn"+ '/../' + "prawn/soft_mask");
  self.$require("prawn"+ '/../' + "prawn/security");
  self.$require("prawn"+ '/../' + "prawn/transformation_stack");
  self.$require("prawn"+ '/../' + "prawn/document");
  self.$require("prawn"+ '/../' + "prawn/font");
  self.$require("prawn"+ '/../' + "prawn/measurements");
  self.$require("prawn"+ '/../' + "prawn/repeater");
  self.$require("prawn"+ '/../' + "prawn/outline");
  self.$require("prawn"+ '/../' + "prawn/grid");
  self.$require("prawn"+ '/../' + "prawn/view");
  self.$require("prawn"+ '/../' + "prawn/image_handler");
  self.$require("praw/js");
  Opal.const_get_relative($nesting, 'Prawn').$image_handler().$register(Opal.const_get_qualified(Opal.const_get_qualified(Opal.const_get_relative($nesting, 'Prawn'), 'Images'), 'PNG'));
  return Opal.const_get_relative($nesting, 'Prawn').$image_handler().$register(Opal.const_get_qualified(Opal.const_get_qualified(Opal.const_get_relative($nesting, 'Prawn'), 'Images'), 'JPG'));
})(Opal);
